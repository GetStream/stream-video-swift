default_platform :ios
skip_docs

require 'json'
require 'net/http'
import 'Sonarfile'
import 'Allurefile'

xcode_version = ENV['XCODE_VERSION'] || '15.0'
xcode_project = 'StreamVideo.xcodeproj'
sdk_names = ['StreamVideo', 'StreamVideoSwiftUI', 'StreamVideoUIKit']
github_repo = ENV['GITHUB_REPOSITORY'] || 'GetStream/stream-video-swift'
sinatra_port = 4567
video_buddy_port = 5678
app_secret = ENV.fetch('STREAM_VIDEO_SECRET', nil)
derived_data_path = 'derived_data'
source_packages_path = 'spm_cache'
buildcache_xcargs = 'CC=clang CPLUSPLUS=clang++ LD=clang LDPLUSPLUS=clang++'
gci = ENV['GOOGLE_CLIENT_ID'] || ''
reversed_gci = gci.split('.').reverse.join('.')
is_localhost = !is_ci
@force_check = false

before_all do |lane|
  if is_ci
    setup_ci
    ENV['FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT'] = '180'
    ENV['FASTLANE_XCODEBUILD_SETTINGS_RETRIES'] = '10'
    xcversion(version: xcode_version) unless [:publish_release, :allure_launch, :allure_upload].include?(lane)
  elsif lane == :test_e2e
    clean_up_ports_for_e2e_test
  end
  create_credentials_config
end

after_all do |lane|
  clean_up_ports_for_e2e_test if lane == :test_e2e
end

desc "Release a new version"
lane :release do |options|
  previous_version_number = last_git_tag
  swift_environment_path = File.absolute_path('../Sources/StreamVideo/Generated/SystemEnvironment+Version.swift')
  extra_changes = lambda do |release_version|
    # Set the framework version in SystemEnvironment+Version.swift
    new_content = File.read(swift_environment_path).gsub!(previous_version_number, release_version)
    File.open(swift_environment_path, 'w') { |f| f.puts(new_content) }
  end

  pod_lint
  version_number = release_ios_sdk(
    version: options[:version],
    bump_type: options[:type],
    sdk_names: sdk_names,
    github_repo: github_repo,
    extra_changes: extra_changes,
    create_pull_request: false
  )
  publish_release(version: version_number)
end

desc "Publish a new release to GitHub and CocoaPods"
lane :publish_release do |options|
  publish_ios_sdk(
    version: options[:version],
    sdk_names: sdk_names,
    github_repo: github_repo
  )
end

lane :pod_lint do
  # We don't lint StreamVideoSwiftUI and StreamVideoUIKit podspecs since pod lints them against StreamVideo's remote version instead of local one
  pod_lib_lint(podspec: 'StreamVideo.podspec', allow_warnings: true)
end

lane :match_me do |options|
  custom_match(
    api_key: appstore_api_key,
    app_identifier: [
      'io.getstream.iOS.VideoDemoApp',
      'io.getstream.iOS.DemoAppUIKit',
      'io.getstream.iOS.VideoDemoApp.CallIntent',
      'io.getstream.iOS.VideoDemoApp.ScreenSharing'
    ],
    readonly: options[:readonly],
    register_device: options[:register_device]
  )
end

private_lane :update_google_plist do |options|
  next if gci.nil?

  Dir.glob(File.join("../#{options[:app_target]}", '**', '*.plist')).each do |plist_file|
    old_content = File.read(plist_file)
    new_content = old_content.gsub('$(GOOGLE_CLIENT_ID)', gci).gsub('$(REVERSED_GOOGLE_CLIENT_ID)', reversed_gci)
    File.write(plist_file, new_content)
  end
end

lane :swiftui_testflight_build do |options|
  app_target = 'DemoApp'

  if options[:configuration] == 'Debug'
    badge(path: app_target)
    update_google_plist(app_target: app_target)
  end

  upload_beta(
    app_target: app_target,
    app_identifier: 'io.getstream.iOS.VideoDemoApp',
    configuration: options[:configuration]
  )
end

lane :uikit_testflight_build do |options|
  upload_beta(app_target: 'DemoAppUIKit', app_identifier: 'io.getstream.iOS.DemoAppUIKit')
end

private_lane :upload_beta do |options|
  match_me
  testflight_build(
    api_key: appstore_api_key,
    xcode_project: xcode_project,
    sdk_target: 'StreamVideo',
    app_target: options[:app_target],
    app_identifier: options[:app_identifier],
    configuration: options[:configuration] || 'Release',
    extensions: ['CallIntent', 'ScreenSharing']
  )
end

private_lane :appstore_api_key do
  @appstore_api_key ||= app_store_connect_api_key(
    key_id: 'MT3PRT8TB7',
    issuer_id: '69a6de96-0738-47e3-e053-5b8c7c11a4d1',
    key_content: ENV.fetch('APPSTORE_API_KEY', nil),
    in_house: false
  )
end

lane :create_credentials_config do
  # Make sure xcconfig exists even though it won't be used on CI
  sh('touch ../TestTools/Credentials.xcconfig')
end

lane :build_test_app_and_frameworks do
  scan(
    project: xcode_project,
    scheme: 'DemoApp',
    testplan: 'SwiftUIDemoApp',
    result_bundle: true,
    derived_data_path: derived_data_path,
    cloned_source_packages_path: source_packages_path,
    clean: is_localhost,
    build_for_testing: true,
    xcargs: buildcache_xcargs
  )
end

desc 'Runs LLC tests'
lane :test do |options|
  next unless is_check_required(sources: sources_matrix[:unit], force_check: @force_check)

  update_testplan_on_ci(path: "StreamVideoTests/StreamVideo.xctestplan")

  scan(
    project: xcode_project,
    scheme: 'StreamVideo',
    testplan: 'StreamVideo',
    clean: is_localhost,
    derived_data_path: derived_data_path,
    cloned_source_packages_path: source_packages_path,
    devices: options[:device],
    number_of_retries: 2,
    skip_build: options[:skip_build],
    xcargs: is_ci ? "#{buildcache_xcargs} STREAM_VIDEO_SECRET=#{app_secret}" : buildcache_xcargs
  )
end

desc 'Runs SwiftUI tests'
lane :test_swiftui do |options|
  test_ui(
    scheme: 'StreamVideoSwiftUI',
    source: :swiftui,
    device: options[:device],
    record: options[:record],
    skip_build: options[:skip_build]
  )
end

desc 'Runs UIKit tests'
lane :test_uikit do |options|
  test_ui(
    scheme: 'StreamVideoUIKit',
    source: :swiftui,
    device: options[:device],
    record: options[:record],
    skip_build: options[:skip_build]
  )
end

private_lane :test_ui do |options|
  next unless is_check_required(sources: sources_matrix[options[:source]], force_check: @force_check)

  remove_snapshots(scheme: options[:scheme]) unless options[:record].to_s.empty?

  update_testplan_on_ci(path: "#{options[:scheme]}Tests/#{options[:scheme]}.xctestplan")

  scan(
    project: xcode_project,
    scheme: options[:scheme],
    testplan: options[:scheme],
    clean: is_localhost,
    derived_data_path: derived_data_path,
    cloned_source_packages_path: source_packages_path,
    skip_build: options[:skip_build],
    result_bundle: true,
    devices: options[:device],
    xcargs: buildcache_xcargs,
    fail_build: options[:record].to_s.empty?
  )

  if options[:record] && is_ci
    next unless sh('git status --porcelain').include?('__Snapshots__')

    title = "[CI] #{options[:scheme]} Snapshots"
    base = current_branch
    head = "#{base}-snapshots"
    sh("git checkout -b #{head}")
    sh('git add -A')
    sh("git commit -m '#{title}'")
    push_to_git_remote(tags: false)
    create_pull_request(
      api_token: ENV.fetch('GITHUB_TOKEN', nil),
      repo: github_repo,
      title: title,
      head: head,
      base: base,
      body: 'This PR was created automatically by CI.'
    )
  end
end

desc 'Starts Sinatra web server'
lane :start_sinatra do
  sh('bundle exec ruby sinatra.rb > sinatra-log.txt 2>&1 &')
end

desc 'Stops Sinatra web server'
lane :stop_sinatra do
  sh("lsof -t -i:#{sinatra_port} | xargs kill -9")
end

desc 'Starts Stream Video Buddy'
lane :start_video_buddy do
  sh("stream-video-buddy auth --record-session")
  sh("stream-video-buddy server --port #{video_buddy_port} > video-buddy-log.txt 2>&1 &")
end

desc 'Stops Stream Video Buddy'
lane :stop_video_buddy do
  sh("lsof -t -i:#{video_buddy_port} | xargs kill -9")
end

desc 'Runs e2e ui tests'
lane :test_e2e do |options|
  next unless is_check_required(sources: sources_matrix[:e2e], force_check: @force_check)

  update_testplan_on_ci(path: 'SwiftUIDemoAppUITests/SwiftUIDemoApp.xctestplan')

  start_sinatra
  start_video_buddy

  prepare_simulator(device: options[:device]) if is_ci

  scan_options = {
    project: xcode_project,
    scheme: 'DemoApp',
    testplan: 'SwiftUIDemoApp',
    result_bundle: true,
    derived_data_path: derived_data_path,
    cloned_source_packages_path: source_packages_path,
    clean: is_localhost,
    test_without_building: options[:test_without_building],
    devices: options[:device],
    number_of_retries: 3,
    xcargs: is_ci ? "#{buildcache_xcargs} STREAM_VIDEO_SECRET=#{app_secret}" : buildcache_xcargs
  }

  if is_localhost || options[:cron]
    scan(scan_options)
  else
    parallelize_tests_on_ci(scan: scan_options, batch: options[:batch])
  end
end

private_lane :parallelize_tests_on_ci do |options|
  products_dir = File.expand_path("../#{derived_data_path}/Build/Products")
  xctestrun = Dir.glob(File.expand_path("#{products_dir}/*.xctestrun")).first
  tests = retrieve_xctest_names(xctestrun: xctestrun).values.flatten
  slice_size = (tests.size / ENV['MATRIX_SIZE'].to_f).ceil
  only_testing = []
  tests.each_slice(slice_size) { |test| only_testing << test }
  only_testing_batch = only_testing[options[:batch].to_i]

  UI.success("Tests in total: #{only_testing.flatten.size}. Running #{only_testing_batch.size} of them ⌛️")
  scan(options[:scan].merge(only_testing: only_testing_batch))
end

private_lane :clean_up_ports_for_e2e_test do
  stop_sinatra
  stop_video_buddy
end

private_lane :update_testplan_on_ci do |options|
  update_testplan(path: options[:path], env_vars: { key: 'CI', value: 'TRUE' }) if is_ci || options[:force]
end

desc 'Builds SwiftUI Demo app'
lane :build_swiftui_demo do
  build_example_app(scheme: 'DemoApp')
end

desc 'Builds UIKit Demo app'
lane :build_uikit_demo do
  build_example_app(scheme: 'DemoAppUIKit')
end

private_lane :build_example_app do |options|
  app_sources =
    case options[:scheme]
    when 'DemoApp'
      :swiftui_sample_apps
    when 'DemoAppUIKit'
      :uikit_sample_apps
    end
  next unless is_check_required(sources: sources_matrix[app_sources], force_check: @force_check)

  scan(
    project: xcode_project,
    scheme: options[:scheme],
    clean: is_localhost,
    derived_data_path: derived_data_path,
    cloned_source_packages_path: source_packages_path,
    xcargs: buildcache_xcargs,
    build_for_testing: true
  )
end

lane :emerge_swiftui do
  next unless is_check_required(sources: sources_matrix[:emerge_swiftui], force_check: @force_check)

  emerge_upload(scheme: 'DemoApp')
end

lane :emerge_uikit do
  next unless is_check_required(sources: sources_matrix[:emerge_uikit], force_check: @force_check)

  emerge_upload(scheme: 'DemoApp')
end

desc 'Build and upload DemoApp to Emerge'
private_lane :emerge_upload do |options|
  gym(
    export_method: 'ad-hoc',
    project: xcode_project,
    scheme: options[:scheme],
    skip_package_ipa: true,
    skip_archive: false,
    clean: is_localhost,
    xcargs: buildcache_xcargs
  )

  emerge(
    build_type: 'release',
    repo_name: github_repo,
    pr_number: ENV['GITHUB_PR_NUM'] || nil, # If `nil` then local run or merge to develop/main
    sha: ENV['GITHUB_COMMIT_SHA'] || last_git_commit[:commit_hash],
    base_sha: ENV['GITHUB_BASE_SHA'] || nil
  )
end

lane :code_generation do
  Dir.chdir('..') { sh('sh Scripts/generateCode.sh') }
  sync_xcodeproj_references
end

private_lane :git_status do |options|
  UI.user_error!('Extension should be provided') unless options[:ext]

  untracked_files = sh('git status -s', log: false).split("\n").map(&:strip)
  deleted_files = select_files_from(files: untracked_files, with_extension: options[:ext], that_start_with: 'D')
  added_files = select_files_from(files: untracked_files, with_extension: options[:ext], that_start_with: ['A', '??'])
  renamed_files = select_files_from(files: untracked_files, with_extension: options[:ext], that_start_with: 'R')
  modified_files = select_files_from(files: untracked_files, with_extension: options[:ext], that_start_with: 'M')

  renamed_files.each do |renamed_file|
    content = renamed_file.split.drop(1).join.split('->').map(&:strip)
    deleted_files << content.first
    added_files << content.last
  end
  { a: added_files, d: deleted_files, m: modified_files }
end

lane :sync_xcodeproj_references do
  Dir.chdir('..') do
    project = Xcodeproj::Project.open(xcode_project)
    status = git_status(ext: '.swift')

    status[:d].each do |file_path|
      next if file_path !~ %r{(/OpenApi/|/protobuf/)}

      file = project.files.find { |f| f.full_path.to_s == file_path }
      file.remove_from_project if file
    end

    status[:a].each do |file_path|
      next if file_path !~ %r{(/OpenApi/|/protobuf/)} || project.files.find { |f| f.full_path.to_s == file_path }

      group = project.main_group
      split_file_path = file_path.split('/')
      file_name = split_file_path.pop

      split_file_path.each do |subfolder|
        if group[subfolder]
          group = group[subfolder]
        else
          group = group.new_group(subfolder)
          group.path = subfolder
        end
      end

      file_reference = group.new_file(file_path)
      file_reference.path = file_name
      project.targets.find { |n| n.name == 'StreamVideo' }.source_build_phase.add_file_reference(file_reference)
    end

    project.save
  end
end

def select_files_from(files:, with_extension:, that_start_with:)
  files.select do |f|
    f.start_with?(*that_start_with)
  end.map do |f|
    f.split.drop(1).join
  end.select do |f|
    f.end_with?(with_extension)
  end
end

desc 'Run fastlane linting'
lane :rubocop do
  next unless is_check_required(sources: sources_matrix[:ruby], force_check: @force_check)

  sh('bundle exec rubocop')
end

desc 'Run source code linting'
lane :run_linter do
  Dir.chdir('..') do
    UI.error('SwiftFormat lint was skipped. Check out https://github.com/GetStream/ios-issues-tracking/issues/465 for more info')
    # sh('mint run swiftformat --lint --config .swiftformat Sources --exclude **/Generated, **/generated, **/protobuf, **/OpenApi')
  end
end

lane :install_sim do |options|
  xcode_install_cache_dir = File.expand_path('~/Library/Caches/XcodeInstall')
  sim_dmg_path = Dir["#{xcode_install_cache_dir}/*.dmg"].first
  sim_pkg_path = Dir["#{xcode_install_cache_dir}/*.pkg"].first
  if is_localhost || sim_dmg_path.nil? || sim_pkg_path.nil?
    sh("bundle exec xcversion simulators --install='iOS #{options[:ios]}'")
  else
    sh("hdiutil attach '#{sim_dmg_path}'")
    sh("sudo installer -pkg '#{sim_pkg_path}' -target /")
    mount_point = sh("hdiutil attach '#{sim_dmg_path}' | grep Volumes | cut -f 3").strip
    sh("hdiutil detach '#{mount_point}'")
  end
end

desc 'Remove UI Snapshots'
lane :remove_snapshots do |options|
  snapshots_path = "../#{options[:scheme]}Tests/**/__Snapshots__/**/*.png"
  if options[:only_unchanged]
    pnf_files = git_status(ext: '.png')
    changed_snapshots = (pnf_files[:a] + pnf_files[:m]).map { |f| File.expand_path(f) }
    Dir.glob(snapshots_path).select { |f| File.delete(f) unless changed_snapshots.include?(File.expand_path(f)) }
  else
    Dir.glob(snapshots_path).select { |f| File.delete(f) }
  end
end

lane :sources_matrix do
  {
    e2e: ['Sources', 'DemoApp', 'SwiftUIDemoAppUITests', xcode_project],
    unit: ['Sources', 'StreamVideoTests', xcode_project],
    swiftui: ['Sources', 'StreamVideoSwiftUITests', xcode_project],
    emerge_swiftui: ['Sources/StreamVideoSwiftUI', 'Sources/StreamVideo', xcode_project],
    emerge_uikit: ['Sources/StreamVideoUIKit'],
    uikit: ['Sources', 'StreamVideoUIKitTests', xcode_project],
    swiftui_sample_apps: ['Sources', 'DemoApp', xcode_project],
    uikit_sample_apps: ['Sources', 'DemoAppUIKit', xcode_project],
    ruby: ['fastlane']
  }
end

private_lane :current_branch do
  ENV['BRANCH_NAME'] || git_branch
end
