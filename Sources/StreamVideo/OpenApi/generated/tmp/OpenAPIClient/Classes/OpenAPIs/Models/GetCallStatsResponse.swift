//
// GetCallStatsResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation


public struct GetCallStatsResponse: Codable, JSONEncodable, Hashable {
    public var aggregated: AggregatedStats?
    public var callDurationSeconds: Int
    public var callStatus: String
    public var callTimeline: CallTimeline?
    /** Duration of the request in milliseconds */
    public var duration: String
    public var jitter: TimeStats?
    public var latency: TimeStats?
    public var maxFreezesDurationSeconds: Int
    public var maxParticipants: Int
    public var maxTotalQualityLimitationDurationSeconds: Int
    public var participantReport: [UserStats]
    public var publishingParticipants: Int
    public var qualityScore: Int
    public var sfuCount: Int
    public var sfus: [SFULocationResponse]

    public init(aggregated: AggregatedStats? = nil, callDurationSeconds: Int, callStatus: String, callTimeline: CallTimeline? = nil, duration: String, jitter: TimeStats? = nil, latency: TimeStats? = nil, maxFreezesDurationSeconds: Int, maxParticipants: Int, maxTotalQualityLimitationDurationSeconds: Int, participantReport: [UserStats], publishingParticipants: Int, qualityScore: Int, sfuCount: Int, sfus: [SFULocationResponse]) {
        self.aggregated = aggregated
        self.callDurationSeconds = callDurationSeconds
        self.callStatus = callStatus
        self.callTimeline = callTimeline
        self.duration = duration
        self.jitter = jitter
        self.latency = latency
        self.maxFreezesDurationSeconds = maxFreezesDurationSeconds
        self.maxParticipants = maxParticipants
        self.maxTotalQualityLimitationDurationSeconds = maxTotalQualityLimitationDurationSeconds
        self.participantReport = participantReport
        self.publishingParticipants = publishingParticipants
        self.qualityScore = qualityScore
        self.sfuCount = sfuCount
        self.sfus = sfus
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case aggregated
        case callDurationSeconds = "call_duration_seconds"
        case callStatus = "call_status"
        case callTimeline = "call_timeline"
        case duration
        case jitter
        case latency
        case maxFreezesDurationSeconds = "max_freezes_duration_seconds"
        case maxParticipants = "max_participants"
        case maxTotalQualityLimitationDurationSeconds = "max_total_quality_limitation_duration_seconds"
        case participantReport = "participant_report"
        case publishingParticipants = "publishing_participants"
        case qualityScore = "quality_score"
        case sfuCount = "sfu_count"
        case sfus
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(aggregated, forKey: .aggregated)
        try container.encode(callDurationSeconds, forKey: .callDurationSeconds)
        try container.encode(callStatus, forKey: .callStatus)
        try container.encodeIfPresent(callTimeline, forKey: .callTimeline)
        try container.encode(duration, forKey: .duration)
        try container.encodeIfPresent(jitter, forKey: .jitter)
        try container.encodeIfPresent(latency, forKey: .latency)
        try container.encode(maxFreezesDurationSeconds, forKey: .maxFreezesDurationSeconds)
        try container.encode(maxParticipants, forKey: .maxParticipants)
        try container.encode(maxTotalQualityLimitationDurationSeconds, forKey: .maxTotalQualityLimitationDurationSeconds)
        try container.encode(participantReport, forKey: .participantReport)
        try container.encode(publishingParticipants, forKey: .publishingParticipants)
        try container.encode(qualityScore, forKey: .qualityScore)
        try container.encode(sfuCount, forKey: .sfuCount)
        try container.encode(sfus, forKey: .sfus)
    }
}

