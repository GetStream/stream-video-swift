//
// Copyright Â© 2022 Stream.io Inc. All rights reserved.
//

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

enum Stream_Video_Coordinator_ClientV1Rpc_UserEventType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0
    case acceptedCall // = 1
    case rejectedCall // = 2
    case cancelledCall // = 3
    case UNRECOGNIZED(Int)

    init() {
        self = .unspecified
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .acceptedCall
        case 2: self = .rejectedCall
        case 3: self = .cancelledCall
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .acceptedCall: return 1
        case .rejectedCall: return 2
        case .cancelledCall: return 3
        case let .UNRECOGNIZED(i): return i
        }
    }
}

#if swift(>=4.2)

extension Stream_Video_Coordinator_ClientV1Rpc_UserEventType: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Stream_Video_Coordinator_ClientV1Rpc_UserEventType] = [
        .unspecified,
        .acceptedCall,
        .rejectedCall,
        .cancelledCall
    ]
}

#endif // swift(>=4.2)

struct Stream_Video_Coordinator_ClientV1Rpc_GetCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callCid: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_GetCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope {
        get { _call ?? Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope?
}

struct Stream_Video_Coordinator_ClientV1Rpc_MemberInput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: String = String()

    var role: String = String()

    var customJson: Data = Data()

    /// The user data for the user
    /// If the user does not exist, this will be used to create the user
    /// If the user already exists, this input will be ignored
    var userInput: Stream_Video_Coordinator_UserV1_UserInput {
        get { _userInput ?? Stream_Video_Coordinator_UserV1_UserInput() }
        set { _userInput = newValue }
    }

    /// Returns true if `userInput` has been explicitly set.
    var hasUserInput: Bool { self._userInput != nil }
    /// Clears the value of `userInput`. Subsequent reads from it will return its default value.
    mutating func clearUserInput() { _userInput = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _userInput: Stream_Video_Coordinator_UserV1_UserInput?
}

struct Stream_Video_Coordinator_ClientV1Rpc_UpsertCallMembersRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callCid: String = String()

    var members: [Stream_Video_Coordinator_ClientV1Rpc_MemberInput] = []

    /// Ringing option, used to signal to clients' UI
    var ring: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_UpsertCallMembersResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callCid: String = String()

    var userIds: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// A message that carries data for call creation
struct Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Call properties to set
    var call: Stream_Video_Coordinator_ClientV1Rpc_CallInput {
        get { _call ?? Stream_Video_Coordinator_ClientV1Rpc_CallInput() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    /// Members to add to the created call
    var members: [Stream_Video_Coordinator_ClientV1Rpc_MemberInput] = []

    /// Ringing option, used to signal to clients' UI
    var ring: Bool {
        get { _ring ?? false }
        set { _ring = newValue }
    }

    /// Returns true if `ring` has been explicitly set.
    var hasRing: Bool { self._ring != nil }
    /// Clears the value of `ring`. Subsequent reads from it will return its default value.
    mutating func clearRing() { _ring = nil }

    /// The user that creating this call, only needed if the call is created server-side
    var createdBy: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput.OneOf_CreatedBy?

    var userID: String {
        get {
            if case let .userID(v)? = createdBy { return v }
            return String()
        }
        set { createdBy = .userID(newValue) }
    }

    var user: Stream_Video_Coordinator_UserV1_UserInput {
        get {
            if case let .user(v)? = createdBy { return v }
            return Stream_Video_Coordinator_UserV1_UserInput()
        }
        set { createdBy = .user(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The user that creating this call, only needed if the call is created server-side
    enum OneOf_CreatedBy: Equatable {
        case userID(String)
        case user(Stream_Video_Coordinator_UserV1_UserInput)

        #if !swift(>=4.1)
        static func == (
            lhs: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput.OneOf_CreatedBy,
            rhs: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput.OneOf_CreatedBy
        ) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.userID, .userID): return {
                    guard case let .userID(l) = lhs, case let .userID(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.user, .user): return {
                    guard case let .user(l) = lhs, case let .user(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            default: return false
            }
        }
        #endif
    }

    init() {}

    fileprivate var _call: Stream_Video_Coordinator_ClientV1Rpc_CallInput?
    fileprivate var _ring: Bool?
}

/// A request message for GetOrCreateCall endpoint
struct Stream_Video_Coordinator_ClientV1Rpc_CreateCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Call type
    var type: String = String()

    /// Call ID. If empty, will be generated as UUIDv4
    var id: String {
        get { _id ?? String() }
        set { _id = newValue }
    }

    /// Returns true if `id` has been explicitly set.
    var hasID: Bool { self._id != nil }
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() { _id = nil }

    /// Call creation input, only used if the call does not exist
    var input: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput {
        get { _input ?? Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput() }
        set { _input = newValue }
    }

    /// Returns true if `input` has been explicitly set.
    var hasInput: Bool { self._input != nil }
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    mutating func clearInput() { _input = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _id: String?
    fileprivate var _input: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput?
}

/// A request message for GetOrCreateCall endpoint
struct Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Call type
    var type: String = String()

    /// Call ID
    var id: String = String()

    /// Call creation input, only used if the call does not exist
    var input: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput {
        get { _input ?? Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput() }
        set { _input = newValue }
    }

    /// Returns true if `input` has been explicitly set.
    var hasInput: Bool { self._input != nil }
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    mutating func clearInput() { _input = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _input: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput?
}

/// A request message for JoinCall endpoint
struct Stream_Video_Coordinator_ClientV1Rpc_JoinCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Call type
    var type: String = String()

    /// Call ID
    var id: String = String()

    /// Call creation input, only used if the call does not exist
    var input: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput {
        get { _input ?? Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput() }
        set { _input = newValue }
    }

    /// Returns true if `input` has been explicitly set.
    var hasInput: Bool { self._input != nil }
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    mutating func clearInput() { _input = nil }

    /// Preferred client datacenter. This is optional and when set, preferred datacenter selection is not guaranteed
    var datacenterID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _input: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput?
}

/// A request message for GetOrCreateCall endpoint
struct Stream_Video_Coordinator_ClientV1Rpc_JoinCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope {
        get { _call ?? Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    /// Whether a call was created
    var created: Bool = false

    /// A list of endpoints to measure latency
    var edges: [Stream_Video_Coordinator_EdgeV1_Edge] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope?
}

/// Represents all updatable room fields
struct Stream_Video_Coordinator_ClientV1Rpc_CallInput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Custom JSON object that is stored in this call
    /// All users with read permissions will have access to this object
    var customJson: Data = Data()

    /// Call settings to be overridden specifically
    var settingsOverrides: Stream_Video_Coordinator_CallV1_CallSettings {
        get { _settingsOverrides ?? Stream_Video_Coordinator_CallV1_CallSettings() }
        set { _settingsOverrides = newValue }
    }

    /// Returns true if `settingsOverrides` has been explicitly set.
    var hasSettingsOverrides: Bool { self._settingsOverrides != nil }
    /// Clears the value of `settingsOverrides`. Subsequent reads from it will return its default value.
    mutating func clearSettingsOverrides() { _settingsOverrides = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _settingsOverrides: Stream_Video_Coordinator_CallV1_CallSettings?
}

struct Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope {
        get { _call ?? Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    /// Whether a call was created
    var created: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope?
}

struct Stream_Video_Coordinator_ClientV1Rpc_UpdateCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callCid: String = String()

    var input: Stream_Video_Coordinator_ClientV1Rpc_CallInput {
        get { _input ?? Stream_Video_Coordinator_ClientV1Rpc_CallInput() }
        set { _input = newValue }
    }

    /// Returns true if `input` has been explicitly set.
    var hasInput: Bool { self._input != nil }
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    mutating func clearInput() { _input = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _input: Stream_Video_Coordinator_ClientV1Rpc_CallInput?
}

struct Stream_Video_Coordinator_ClientV1Rpc_UpdateCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope {
        get { _call ?? Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope?
}

struct Stream_Video_Coordinator_ClientV1Rpc_RoleOverride {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the users that should get the new role, cannot be empty
    var userIds: [String] = []

    /// the new role
    var roleName: String {
        get { _roleName ?? String() }
        set { _roleName = newValue }
    }

    /// Returns true if `roleName` has been explicitly set.
    var hasRoleName: Bool { self._roleName != nil }
    /// Clears the value of `roleName`. Subsequent reads from it will return its default value.
    mutating func clearRoleName() { _roleName = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _roleName: String?
}

struct Stream_Video_Coordinator_ClientV1Rpc_PermissionGrantOverride {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the users that will get the new permissions granted
    /// if empty, the grant applies to all users
    var userIds: [String] = []

    /// the list of permissions granted to users
    var permissions: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_UpdateCallPermissionsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callCid: String = String()

    var grantInput: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallPermissionsRequest.OneOf_GrantInput?

    var roleOverride: Stream_Video_Coordinator_ClientV1Rpc_RoleOverride {
        get {
            if case let .roleOverride(v)? = grantInput { return v }
            return Stream_Video_Coordinator_ClientV1Rpc_RoleOverride()
        }
        set { grantInput = .roleOverride(newValue) }
    }

    var permissionOverride: Stream_Video_Coordinator_ClientV1Rpc_PermissionGrantOverride {
        get {
            if case let .permissionOverride(v)? = grantInput { return v }
            return Stream_Video_Coordinator_ClientV1Rpc_PermissionGrantOverride()
        }
        set { grantInput = .permissionOverride(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_GrantInput: Equatable {
        case roleOverride(Stream_Video_Coordinator_ClientV1Rpc_RoleOverride)
        case permissionOverride(Stream_Video_Coordinator_ClientV1Rpc_PermissionGrantOverride)

        #if !swift(>=4.1)
        static func == (
            lhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallPermissionsRequest.OneOf_GrantInput,
            rhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallPermissionsRequest.OneOf_GrantInput
        ) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.roleOverride, .roleOverride): return {
                    guard case let .roleOverride(l) = lhs, case let .roleOverride(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.permissionOverride, .permissionOverride): return {
                    guard case let .permissionOverride(l) = lhs,
                          case let .permissionOverride(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            default: return false
            }
        }
        #endif
    }

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_UpdateCallPermissionsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_EndCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callCid: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_EndCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_CreateCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope {
        get { _call ?? Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope?
}

struct Stream_Video_Coordinator_ClientV1Rpc_QueryCallsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mqJson: Data = Data()

    var limit: Int32 {
        get { _limit ?? 0 }
        set { _limit = newValue }
    }

    /// Returns true if `limit` has been explicitly set.
    var hasLimit: Bool { self._limit != nil }
    /// Clears the value of `limit`. Subsequent reads from it will return its default value.
    mutating func clearLimit() { _limit = nil }

    var sorts: [Stream_Video_Coordinator_UtilsV1_Sort] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _limit: Int32?
}

struct Stream_Video_Coordinator_ClientV1Rpc_QueryCallsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var calls: Stream_Video_Coordinator_ClientV1Rpc_CallsEnvelope {
        get { _calls ?? Stream_Video_Coordinator_ClientV1Rpc_CallsEnvelope() }
        set { _calls = newValue }
    }

    /// Returns true if `calls` has been explicitly set.
    var hasCalls: Bool { self._calls != nil }
    /// Clears the value of `calls`. Subsequent reads from it will return its default value.
    mutating func clearCalls() { _calls = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _calls: Stream_Video_Coordinator_ClientV1Rpc_CallsEnvelope?
}

struct Stream_Video_Coordinator_ClientV1Rpc_QueryMembersRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mqJson: Data = Data()

    var limit: Int32 {
        get { _limit ?? 0 }
        set { _limit = newValue }
    }

    /// Returns true if `limit` has been explicitly set.
    var hasLimit: Bool { self._limit != nil }
    /// Clears the value of `limit`. Subsequent reads from it will return its default value.
    mutating func clearLimit() { _limit = nil }

    var sorts: [Stream_Video_Coordinator_UtilsV1_Sort] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _limit: Int32?
}

struct Stream_Video_Coordinator_ClientV1Rpc_QueryMembersResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var members: Stream_Video_Coordinator_ClientV1Rpc_MembersEnvelope {
        get { _members ?? Stream_Video_Coordinator_ClientV1Rpc_MembersEnvelope() }
        set { _members = newValue }
    }

    /// Returns true if `members` has been explicitly set.
    var hasMembers: Bool { self._members != nil }
    /// Clears the value of `members`. Subsequent reads from it will return its default value.
    mutating func clearMembers() { _members = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _members: Stream_Video_Coordinator_ClientV1Rpc_MembersEnvelope?
}

struct Stream_Video_Coordinator_ClientV1Rpc_QueryUsersRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mqJson: Data = Data()

    var limit: Int32 {
        get { _limit ?? 0 }
        set { _limit = newValue }
    }

    /// Returns true if `limit` has been explicitly set.
    var hasLimit: Bool { self._limit != nil }
    /// Clears the value of `limit`. Subsequent reads from it will return its default value.
    mutating func clearLimit() { _limit = nil }

    var sorts: [Stream_Video_Coordinator_UtilsV1_Sort] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _limit: Int32?
}

struct Stream_Video_Coordinator_ClientV1Rpc_QueryUsersResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var users: [Stream_Video_Coordinator_UserV1_User] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_UpsertUsersRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var users: [Stream_Video_Coordinator_UserV1_UserInput] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_UpsertUsersResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var users: [Stream_Video_Coordinator_UserV1_User] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// A request message for GetCallEdgeServer endpoint
struct Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Call CID to get SFU for
    var callCid: String = String()

    /// Latency measurement results
    /// Optional
    var measurements: Stream_Video_Coordinator_EdgeV1_LatencyMeasurements {
        get { _measurements ?? Stream_Video_Coordinator_EdgeV1_LatencyMeasurements() }
        set { _measurements = newValue }
    }

    /// Returns true if `measurements` has been explicitly set.
    var hasMeasurements: Bool { self._measurements != nil }
    /// Clears the value of `measurements`. Subsequent reads from it will return its default value.
    mutating func clearMeasurements() { _measurements = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _measurements: Stream_Video_Coordinator_EdgeV1_LatencyMeasurements?
}

struct Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope {
        get { _call ?? Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope() }
        set { _call = newValue }
    }

    /// Returns true if `call` has been explicitly set.
    var hasCall: Bool { self._call != nil }
    /// Clears the value of `call`. Subsequent reads from it will return its default value.
    mutating func clearCall() { _call = nil }

    /// Call edge server credentials
    var credentials: Stream_Video_Coordinator_EdgeV1_Credentials {
        get { _credentials ?? Stream_Video_Coordinator_EdgeV1_Credentials() }
        set { _credentials = newValue }
    }

    /// Returns true if `credentials` has been explicitly set.
    var hasCredentials: Bool { self._credentials != nil }
    /// Clears the value of `credentials`. Subsequent reads from it will return its default value.
    mutating func clearCredentials() { _credentials = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _call: Stream_Video_Coordinator_ClientV1Rpc_CallEnvelope?
    private var _credentials: Stream_Video_Coordinator_EdgeV1_Credentials?
}

struct Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var input: Stream_Video_Coordinator_PushV1_DeviceInput {
        get { _input ?? Stream_Video_Coordinator_PushV1_DeviceInput() }
        set { _input = newValue }
    }

    /// Returns true if `input` has been explicitly set.
    var hasInput: Bool { self._input != nil }
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    mutating func clearInput() { _input = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _input: Stream_Video_Coordinator_PushV1_DeviceInput?
}

struct Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var device: Stream_Video_Coordinator_PushV1_Device {
        get { _device ?? Stream_Video_Coordinator_PushV1_Device() }
        set { _device = newValue }
    }

    /// Returns true if `device` has been explicitly set.
    var hasDevice: Bool { self._device != nil }
    /// Clears the value of `device`. Subsequent reads from it will return its default value.
    mutating func clearDevice() { _device = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _device: Stream_Video_Coordinator_PushV1_Device?
}

struct Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var devices: [Stream_Video_Coordinator_PushV1_Device] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_SendEventRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The call cid
    var callCid: String = String()

    /// The type of event
    var eventType: Stream_Video_Coordinator_ClientV1Rpc_UserEventType = .unspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_SendEventResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The call cid
    var callCid: String = String()

    /// The type of event
    var type: String = String()

    /// The data of the event
    var dataJson: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A concatenation of call type and call id with ":" as delimiter
    var callCid: String = String()

    /// A WebRTC Stats report encoded as a JSON string, as defined in https://www.w3.org/TR/webrtc/#dom-rtcstatsreport
    var statsJson: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatEventRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A concatenation of call type and call id with ":" as delimiter
    var callCid: String = String()

    /// Event timestamp as RFC3339 string.
    var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _timestamp = newValue }
    }

    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool { self._timestamp != nil }
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() { _timestamp = nil }

    var event: Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatEventRequest.OneOf_Event?

    var participantConnected: Stream_Video_Coordinator_StatV1_ParticipantConnected {
        get {
            if case let .participantConnected(v)? = event { return v }
            return Stream_Video_Coordinator_StatV1_ParticipantConnected()
        }
        set { event = .participantConnected(newValue) }
    }

    var participantDisconnected: Stream_Video_Coordinator_StatV1_ParticipantDisconnected {
        get {
            if case let .participantDisconnected(v)? = event { return v }
            return Stream_Video_Coordinator_StatV1_ParticipantDisconnected()
        }
        set { event = .participantDisconnected(newValue) }
    }

    var mediaStateChanged: Stream_Video_Coordinator_StatV1_MediaStateChanged {
        get {
            if case let .mediaStateChanged(v)? = event { return v }
            return Stream_Video_Coordinator_StatV1_MediaStateChanged()
        }
        set { event = .mediaStateChanged(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Event: Equatable {
        case participantConnected(Stream_Video_Coordinator_StatV1_ParticipantConnected)
        case participantDisconnected(Stream_Video_Coordinator_StatV1_ParticipantDisconnected)
        case mediaStateChanged(Stream_Video_Coordinator_StatV1_MediaStateChanged)

        #if !swift(>=4.1)
        static func == (
            lhs: Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatEventRequest.OneOf_Event,
            rhs: Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatEventRequest.OneOf_Event
        ) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.participantConnected, .participantConnected): return {
                    guard case let .participantConnected(l) = lhs,
                          case let .participantConnected(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.participantDisconnected, .participantDisconnected): return {
                    guard case let .participantDisconnected(l) = lhs,
                          case let .participantDisconnected(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.mediaStateChanged, .mediaStateChanged): return {
                    guard case let .mediaStateChanged(l) = lhs, case let .mediaStateChanged(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            default: return false
            }
        }
        #endif
    }

    init() {}

    private var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp?
}

struct Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatEventResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_GetCallStatsRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A concatenation of call type and call id with ":" as delimiter
    var callCid: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_ReportIssueRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A concatenation of call type and call id with ":" as delimiter
    var callCid: String = String()

    /// Optional description.
    var description_p: String = String()

    var customJson: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_ReportIssueResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_ReviewCallRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A concatenation of call type and call id with ":" as delimiter
    var callCid: String = String()

    /// Rating between 0 and 5 stars.
    var stars: Float = 0

    /// Optional description.
    var description_p: String = String()

    /// Optional custom data.
    var customJson: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_ReviewCallResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_StartBroadcastRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Call type and id.
    var callType: String = String()

    var callID: String = String()

    /// Toggles HLS broadcasting on/off.
    var hlsBroadcast: Bool = false

    /// Enables rtmp broadcasting.
    var rtmp: Stream_Video_Coordinator_BroadcastV1_RTMPOptions {
        get { _rtmp ?? Stream_Video_Coordinator_BroadcastV1_RTMPOptions() }
        set { _rtmp = newValue }
    }

    /// Returns true if `rtmp` has been explicitly set.
    var hasRtmp: Bool { self._rtmp != nil }
    /// Clears the value of `rtmp`. Subsequent reads from it will return its default value.
    mutating func clearRtmp() { _rtmp = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _rtmp: Stream_Video_Coordinator_BroadcastV1_RTMPOptions?
}

struct Stream_Video_Coordinator_ClientV1Rpc_StartBroadcastResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var broadcast: Stream_Video_Coordinator_BroadcastV1_Broadcast {
        get { _broadcast ?? Stream_Video_Coordinator_BroadcastV1_Broadcast() }
        set { _broadcast = newValue }
    }

    /// Returns true if `broadcast` has been explicitly set.
    var hasBroadcast: Bool { self._broadcast != nil }
    /// Clears the value of `broadcast`. Subsequent reads from it will return its default value.
    mutating func clearBroadcast() { _broadcast = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _broadcast: Stream_Video_Coordinator_BroadcastV1_Broadcast?
}

struct Stream_Video_Coordinator_ClientV1Rpc_StopBroadcastRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Call type and id.
    var callType: String = String()

    var callID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_StopBroadcastResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_StartRecordingRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callType: String = String()

    var callID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_StartRecordingResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_StopRecordingRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callType: String = String()

    var callID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Coordinator_ClientV1Rpc_StopRecordingResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stream_Video_Coordinator_ClientV1Rpc_UserEventType: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_GetCallRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_GetCallResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_MemberInput: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_UpsertCallMembersRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_UpsertCallMembersResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput.OneOf_CreatedBy: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_CreateCallRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_JoinCallRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_JoinCallResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_CallInput: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_RoleOverride: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_PermissionGrantOverride: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallPermissionsRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallPermissionsRequest.OneOf_GrantInput: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallPermissionsResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_EndCallRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_EndCallResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_CreateCallResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_QueryCallsRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_QueryCallsResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_QueryMembersRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_QueryMembersResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_QueryUsersRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_QueryUsersResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_UpsertUsersRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_UpsertUsersResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_SendEventRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_SendEventResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatEventRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatEventRequest.OneOf_Event: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatEventResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_GetCallStatsRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_ReportIssueRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_ReportIssueResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_ReviewCallRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_ReviewCallResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_StartBroadcastRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_StartBroadcastResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_StopBroadcastRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_StopBroadcastResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_StartRecordingRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_StartRecordingResponse: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_StopRecordingRequest: @unchecked Sendable {}
extension Stream_Video_Coordinator_ClientV1Rpc_StopRecordingResponse: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "stream.video.coordinator.client_v1_rpc"

extension Stream_Video_Coordinator_ClientV1Rpc_UserEventType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "USER_EVENT_TYPE_UNSPECIFIED"),
        1: .same(proto: "USER_EVENT_TYPE_ACCEPTED_CALL"),
        2: .same(proto: "USER_EVENT_TYPE_REJECTED_CALL"),
        3: .same(proto: "USER_EVENT_TYPE_CANCELLED_CALL")
    ]
}

extension Stream_Video_Coordinator_ClientV1Rpc_GetCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_GetCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetCallResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallResponse
    ) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_MemberInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".MemberInput"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_id"),
        2: .same(proto: "role"),
        3: .standard(proto: "custom_json"),
        4: .standard(proto: "user_input")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.role) }()
            case 3: try { try decoder.decodeSingularBytesField(value: &self.customJson) }()
            case 4: try { try decoder.decodeSingularMessageField(value: &self._userInput) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 1)
        }
        if !role.isEmpty {
            try visitor.visitSingularStringField(value: role, fieldNumber: 2)
        }
        if !customJson.isEmpty {
            try visitor.visitSingularBytesField(value: customJson, fieldNumber: 3)
        }
        try { if let v = self._userInput {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_MemberInput,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_MemberInput
    ) -> Bool {
        if lhs.userID != rhs.userID { return false }
        if lhs.role != rhs.role { return false }
        if lhs.customJson != rhs.customJson { return false }
        if lhs._userInput != rhs._userInput { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_UpsertCallMembersRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpsertCallMembersRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .same(proto: "members"),
        3: .same(proto: "ring")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.ring) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        if !members.isEmpty {
            try visitor.visitRepeatedMessageField(value: members, fieldNumber: 2)
        }
        if ring != false {
            try visitor.visitSingularBoolField(value: ring, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_UpsertCallMembersRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_UpsertCallMembersRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs.members != rhs.members { return false }
        if lhs.ring != rhs.ring { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_UpsertCallMembersResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpsertCallMembersResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_UpsertCallMembersResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_UpsertCallMembersResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeleteCallMembersRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .standard(proto: "user_ids")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        if !userIds.isEmpty {
            try visitor.visitRepeatedStringField(value: userIds, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs.userIds != rhs.userIds { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeleteCallMembersResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_DeleteCallMembersResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateCallInput"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call"),
        2: .same(proto: "members"),
        3: .same(proto: "ring"),
        4: .standard(proto: "user_id"),
        5: .same(proto: "user")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self._ring) }()
            case 4: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v = v {
                        if self.createdBy != nil { try decoder.handleConflictingOneOf() }
                        self.createdBy = .userID(v)
                    }
                }()
            case 5: try {
                    var v: Stream_Video_Coordinator_UserV1_UserInput?
                    var hadOneofValue = false
                    if let current = self.createdBy {
                        hadOneofValue = true
                        if case let .user(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.createdBy = .user(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !members.isEmpty {
            try visitor.visitRepeatedMessageField(value: members, fieldNumber: 2)
        }
        try { if let v = self._ring {
            try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
        } }()
        switch createdBy {
        case .userID?: try {
                guard case let .userID(v)? = self.createdBy else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 4)
            }()
        case .user?: try {
                guard case let .user(v)? = self.createdBy else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_CreateCallInput
    ) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs.members != rhs.members { return false }
        if lhs._ring != rhs._ring { return false }
        if lhs.createdBy != rhs.createdBy { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_CreateCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "id"),
        3: .same(proto: "input")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self._id) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._input) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 1)
        }
        try { if let v = self._id {
            try visitor.visitSingularStringField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._input {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_CreateCallRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_CreateCallRequest
    ) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs._id != rhs._id { return false }
        if lhs._input != rhs._input { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetOrCreateCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "id"),
        3: .same(proto: "input")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._input) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 1)
        }
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 2)
        }
        try { if let v = self._input {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallRequest
    ) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.id != rhs.id { return false }
        if lhs._input != rhs._input { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_JoinCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".JoinCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "id"),
        3: .same(proto: "input"),
        4: .standard(proto: "datacenter_id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._input) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self.datacenterID) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 1)
        }
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 2)
        }
        try { if let v = self._input {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        if !datacenterID.isEmpty {
            try visitor.visitSingularStringField(value: datacenterID, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_JoinCallRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_JoinCallRequest
    ) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.id != rhs.id { return false }
        if lhs._input != rhs._input { return false }
        if lhs.datacenterID != rhs.datacenterID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_JoinCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".JoinCallResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call"),
        2: .same(proto: "created"),
        3: .same(proto: "edges")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.created) }()
            case 3: try { try decoder.decodeRepeatedMessageField(value: &self.edges) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if created != false {
            try visitor.visitSingularBoolField(value: created, fieldNumber: 2)
        }
        if !edges.isEmpty {
            try visitor.visitRepeatedMessageField(value: edges, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_JoinCallResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_JoinCallResponse
    ) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs.created != rhs.created { return false }
        if lhs.edges != rhs.edges { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_CallInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CallInput"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "custom_json"),
        2: .standard(proto: "settings_overrides")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBytesField(value: &self.customJson) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._settingsOverrides) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !customJson.isEmpty {
            try visitor.visitSingularBytesField(value: customJson, fieldNumber: 1)
        }
        try { if let v = self._settingsOverrides {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_CallInput,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_CallInput
    ) -> Bool {
        if lhs.customJson != rhs.customJson { return false }
        if lhs._settingsOverrides != rhs._settingsOverrides { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetOrCreateCallResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call"),
        2: .same(proto: "created")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.created) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if created != false {
            try visitor.visitSingularBoolField(value: created, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_GetOrCreateCallResponse
    ) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs.created != rhs.created { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .same(proto: "input")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._input) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        try { if let v = self._input {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs._input != rhs._input { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateCallResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallResponse
    ) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_RoleOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RoleOverride"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_ids"),
        2: .standard(proto: "role_name")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self._roleName) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !userIds.isEmpty {
            try visitor.visitRepeatedStringField(value: userIds, fieldNumber: 1)
        }
        try { if let v = self._roleName {
            try visitor.visitSingularStringField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_RoleOverride,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_RoleOverride
    ) -> Bool {
        if lhs.userIds != rhs.userIds { return false }
        if lhs._roleName != rhs._roleName { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_PermissionGrantOverride: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PermissionGrantOverride"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_ids"),
        2: .same(proto: "permissions")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
            case 2: try { try decoder.decodeRepeatedStringField(value: &self.permissions) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !userIds.isEmpty {
            try visitor.visitRepeatedStringField(value: userIds, fieldNumber: 1)
        }
        if !permissions.isEmpty {
            try visitor.visitRepeatedStringField(value: permissions, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_PermissionGrantOverride,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_PermissionGrantOverride
    ) -> Bool {
        if lhs.userIds != rhs.userIds { return false }
        if lhs.permissions != rhs.permissions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallPermissionsRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateCallPermissionsRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .standard(proto: "role_override"),
        3: .standard(proto: "permission_override")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try {
                    var v: Stream_Video_Coordinator_ClientV1Rpc_RoleOverride?
                    var hadOneofValue = false
                    if let current = self.grantInput {
                        hadOneofValue = true
                        if case let .roleOverride(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.grantInput = .roleOverride(v)
                    }
                }()
            case 3: try {
                    var v: Stream_Video_Coordinator_ClientV1Rpc_PermissionGrantOverride?
                    var hadOneofValue = false
                    if let current = self.grantInput {
                        hadOneofValue = true
                        if case let .permissionOverride(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.grantInput = .permissionOverride(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        switch grantInput {
        case .roleOverride?: try {
                guard case let .roleOverride(v)? = self.grantInput else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .permissionOverride?: try {
                guard case let .permissionOverride(v)? = self.grantInput else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallPermissionsRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallPermissionsRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs.grantInput != rhs.grantInput { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_UpdateCallPermissionsResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateCallPermissionsResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallPermissionsResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_UpdateCallPermissionsResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_EndCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".EndCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_EndCallRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_EndCallRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_EndCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".EndCallResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_EndCallResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_EndCallResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_CreateCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateCallResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_CreateCallResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_CreateCallResponse
    ) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_QueryCallsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".QueryCallsRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "mq_json"),
        2: .same(proto: "limit"),
        3: .same(proto: "sorts")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBytesField(value: &self.mqJson) }()
            case 2: try { try decoder.decodeSingularInt32Field(value: &self._limit) }()
            case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sorts) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !mqJson.isEmpty {
            try visitor.visitSingularBytesField(value: mqJson, fieldNumber: 1)
        }
        try { if let v = self._limit {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
        } }()
        if !sorts.isEmpty {
            try visitor.visitRepeatedMessageField(value: sorts, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_QueryCallsRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_QueryCallsRequest
    ) -> Bool {
        if lhs.mqJson != rhs.mqJson { return false }
        if lhs._limit != rhs._limit { return false }
        if lhs.sorts != rhs.sorts { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_QueryCallsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".QueryCallsResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "calls")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._calls) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._calls {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_QueryCallsResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_QueryCallsResponse
    ) -> Bool {
        if lhs._calls != rhs._calls { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_QueryMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".QueryMembersRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "mq_json"),
        2: .same(proto: "limit"),
        3: .same(proto: "sorts")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBytesField(value: &self.mqJson) }()
            case 2: try { try decoder.decodeSingularInt32Field(value: &self._limit) }()
            case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sorts) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !mqJson.isEmpty {
            try visitor.visitSingularBytesField(value: mqJson, fieldNumber: 1)
        }
        try { if let v = self._limit {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
        } }()
        if !sorts.isEmpty {
            try visitor.visitRepeatedMessageField(value: sorts, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_QueryMembersRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_QueryMembersRequest
    ) -> Bool {
        if lhs.mqJson != rhs.mqJson { return false }
        if lhs._limit != rhs._limit { return false }
        if lhs.sorts != rhs.sorts { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_QueryMembersResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".QueryMembersResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "members")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._members) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._members {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_QueryMembersResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_QueryMembersResponse
    ) -> Bool {
        if lhs._members != rhs._members { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_QueryUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".QueryUsersRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "mq_json"),
        2: .same(proto: "limit"),
        3: .same(proto: "sorts")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBytesField(value: &self.mqJson) }()
            case 2: try { try decoder.decodeSingularInt32Field(value: &self._limit) }()
            case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sorts) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !mqJson.isEmpty {
            try visitor.visitSingularBytesField(value: mqJson, fieldNumber: 1)
        }
        try { if let v = self._limit {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
        } }()
        if !sorts.isEmpty {
            try visitor.visitRepeatedMessageField(value: sorts, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_QueryUsersRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_QueryUsersRequest
    ) -> Bool {
        if lhs.mqJson != rhs.mqJson { return false }
        if lhs._limit != rhs._limit { return false }
        if lhs.sorts != rhs.sorts { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_QueryUsersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".QueryUsersResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "users")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !users.isEmpty {
            try visitor.visitRepeatedMessageField(value: users, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_QueryUsersResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_QueryUsersResponse
    ) -> Bool {
        if lhs.users != rhs.users { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_UpsertUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpsertUsersRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "users")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !users.isEmpty {
            try visitor.visitRepeatedMessageField(value: users, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_UpsertUsersRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_UpsertUsersRequest
    ) -> Bool {
        if lhs.users != rhs.users { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_UpsertUsersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpsertUsersResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "users")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !users.isEmpty {
            try visitor.visitRepeatedMessageField(value: users, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_UpsertUsersResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_UpsertUsersResponse
    ) -> Bool {
        if lhs.users != rhs.users { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetCallEdgeServerRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .same(proto: "measurements")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._measurements) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        try { if let v = self._measurements {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs._measurements != rhs._measurements { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetCallEdgeServerResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "call"),
        2: .same(proto: "credentials")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._credentials) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._call {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._credentials {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallEdgeServerResponse
    ) -> Bool {
        if lhs._call != rhs._call { return false }
        if lhs._credentials != rhs._credentials { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateDeviceRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "input")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._input) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._input {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceRequest
    ) -> Bool {
        if lhs._input != rhs._input { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateDeviceResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "device")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._device {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_CreateDeviceResponse
    ) -> Bool {
        if lhs._device != rhs._device { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeleteDeviceRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceRequest
    ) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeleteDeviceResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_DeleteDeviceResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".QueryDevicesRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesRequest
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".QueryDevicesResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "devices")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !devices.isEmpty {
            try visitor.visitRepeatedMessageField(value: devices, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_QueryDevicesResponse
    ) -> Bool {
        if lhs.devices != rhs.devices { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_SendEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SendEventRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .standard(proto: "event_type")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeSingularEnumField(value: &self.eventType) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        if eventType != .unspecified {
            try visitor.visitSingularEnumField(value: eventType, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_SendEventRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_SendEventRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs.eventType != rhs.eventType { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_SendEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SendEventResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_SendEventResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_SendEventResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SendCustomEventRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .same(proto: "type"),
        3: .standard(proto: "data_json")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
            case 3: try { try decoder.decodeSingularBytesField(value: &self.dataJson) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 2)
        }
        if !dataJson.isEmpty {
            try visitor.visitSingularBytesField(value: dataJson, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs.type != rhs.type { return false }
        if lhs.dataJson != rhs.dataJson { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SendCustomEventResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_SendCustomEventResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReportCallStatsRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .standard(proto: "stats_json")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeSingularBytesField(value: &self.statsJson) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        if !statsJson.isEmpty {
            try visitor.visitSingularBytesField(value: statsJson, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs.statsJson != rhs.statsJson { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReportCallStatsResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatsResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatEventRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReportCallStatEventRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .same(proto: "timestamp"),
        3: .standard(proto: "participant_connected"),
        4: .standard(proto: "participant_disconnected"),
        5: .standard(proto: "media_state_changed")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
            case 3: try {
                    var v: Stream_Video_Coordinator_StatV1_ParticipantConnected?
                    var hadOneofValue = false
                    if let current = self.event {
                        hadOneofValue = true
                        if case let .participantConnected(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.event = .participantConnected(v)
                    }
                }()
            case 4: try {
                    var v: Stream_Video_Coordinator_StatV1_ParticipantDisconnected?
                    var hadOneofValue = false
                    if let current = self.event {
                        hadOneofValue = true
                        if case let .participantDisconnected(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.event = .participantDisconnected(v)
                    }
                }()
            case 5: try {
                    var v: Stream_Video_Coordinator_StatV1_MediaStateChanged?
                    var hadOneofValue = false
                    if let current = self.event {
                        hadOneofValue = true
                        if case let .mediaStateChanged(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.event = .mediaStateChanged(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        try { if let v = self._timestamp {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        switch event {
        case .participantConnected?: try {
                guard case let .participantConnected(v)? = self.event else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .participantDisconnected?: try {
                guard case let .participantDisconnected(v)? = self.event else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .mediaStateChanged?: try {
                guard case let .mediaStateChanged(v)? = self.event else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatEventRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatEventRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs._timestamp != rhs._timestamp { return false }
        if lhs.event != rhs.event { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatEventResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReportCallStatEventResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatEventResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_ReportCallStatEventResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_GetCallStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GetCallStatsRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallStatsRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_GetCallStatsRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_ReportIssueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReportIssueRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .same(proto: "description"),
        3: .standard(proto: "custom_json")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
            case 3: try { try decoder.decodeSingularBytesField(value: &self.customJson) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 2)
        }
        if !customJson.isEmpty {
            try visitor.visitSingularBytesField(value: customJson, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_ReportIssueRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_ReportIssueRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.customJson != rhs.customJson { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_ReportIssueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReportIssueResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_ReportIssueResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_ReportIssueResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_ReviewCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReviewCallRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .same(proto: "stars"),
        3: .same(proto: "description"),
        4: .standard(proto: "custom_json")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeSingularFloatField(value: &self.stars) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
            case 4: try { try decoder.decodeSingularBytesField(value: &self.customJson) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        if stars != 0 {
            try visitor.visitSingularFloatField(value: stars, fieldNumber: 2)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 3)
        }
        if !customJson.isEmpty {
            try visitor.visitSingularBytesField(value: customJson, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_ReviewCallRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_ReviewCallRequest
    ) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs.stars != rhs.stars { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.customJson != rhs.customJson { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_ReviewCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ReviewCallResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_ReviewCallResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_ReviewCallResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_StartBroadcastRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StartBroadcastRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id"),
        3: .standard(proto: "hls_broadcast"),
        5: .same(proto: "rtmp")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.hlsBroadcast) }()
            case 5: try { try decoder.decodeSingularMessageField(value: &self._rtmp) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        if hlsBroadcast != false {
            try visitor.visitSingularBoolField(value: hlsBroadcast, fieldNumber: 3)
        }
        try { if let v = self._rtmp {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_StartBroadcastRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_StartBroadcastRequest
    ) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.hlsBroadcast != rhs.hlsBroadcast { return false }
        if lhs._rtmp != rhs._rtmp { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_StartBroadcastResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StartBroadcastResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "broadcast")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._broadcast) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._broadcast {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_StartBroadcastResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_StartBroadcastResponse
    ) -> Bool {
        if lhs._broadcast != rhs._broadcast { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_StopBroadcastRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StopBroadcastRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_StopBroadcastRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_StopBroadcastRequest
    ) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_StopBroadcastResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StopBroadcastResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_StopBroadcastResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_StopBroadcastResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_StartRecordingRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StartRecordingRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_StartRecordingRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_StartRecordingRequest
    ) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_StartRecordingResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StartRecordingResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_StartRecordingResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_StartRecordingResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_StopRecordingRequest: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StopRecordingRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_type"),
        2: .standard(proto: "call_id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.callID) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !callType.isEmpty {
            try visitor.visitSingularStringField(value: callType, fieldNumber: 1)
        }
        if !callID.isEmpty {
            try visitor.visitSingularStringField(value: callID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_StopRecordingRequest,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_StopRecordingRequest
    ) -> Bool {
        if lhs.callType != rhs.callType { return false }
        if lhs.callID != rhs.callID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Coordinator_ClientV1Rpc_StopRecordingResponse: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StopRecordingResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Coordinator_ClientV1Rpc_StopRecordingResponse,
        rhs: Stream_Video_Coordinator_ClientV1Rpc_StopRecordingResponse
    ) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
