// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: video/sfu/models/models.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Stream_Video_Sfu_Models_PeerType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// todo fix me (marcelo)
  case publisherUnspecified // = 0
  case subscriber // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .publisherUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .publisherUnspecified
    case 1: self = .subscriber
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .publisherUnspecified: return 0
    case .subscriber: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Sfu_Models_PeerType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Sfu_Models_PeerType] = [
    .publisherUnspecified,
    .subscriber,
  ]
}

#endif  // swift(>=4.2)

enum Stream_Video_Sfu_Models_ConnectionQuality: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case poor // = 1
  case good // = 2
  case excellent // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .poor
    case 2: self = .good
    case 3: self = .excellent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .poor: return 1
    case .good: return 2
    case .excellent: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Sfu_Models_ConnectionQuality: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Sfu_Models_ConnectionQuality] = [
    .unspecified,
    .poor,
    .good,
    .excellent,
  ]
}

#endif  // swift(>=4.2)

enum Stream_Video_Sfu_Models_VideoQuality: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case lowUnspecified // = 0
  case mid // = 1
  case high // = 2
  case off // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .lowUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .lowUnspecified
    case 1: self = .mid
    case 2: self = .high
    case 3: self = .off
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .lowUnspecified: return 0
    case .mid: return 1
    case .high: return 2
    case .off: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Sfu_Models_VideoQuality: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Sfu_Models_VideoQuality] = [
    .lowUnspecified,
    .mid,
    .high,
    .off,
  ]
}

#endif  // swift(>=4.2)

enum Stream_Video_Sfu_Models_TrackType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case audio // = 1
  case video // = 2
  case screenShare // = 3
  case screenShareAudio // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .audio
    case 2: self = .video
    case 3: self = .screenShare
    case 4: self = .screenShareAudio
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .audio: return 1
    case .video: return 2
    case .screenShare: return 3
    case .screenShareAudio: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Sfu_Models_TrackType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Sfu_Models_TrackType] = [
    .unspecified,
    .audio,
    .video,
    .screenShare,
    .screenShareAudio,
  ]
}

#endif  // swift(>=4.2)

enum Stream_Video_Sfu_Models_ErrorCode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case publishTrackNotFound // = 100
  case publishTracksMismatch // = 101
  case publishTrackOutOfOrder // = 102
  case publishTrackVideoLayerNotFound // = 103
  case participantNotFound // = 200
  case callNotFound // = 300
  case requestValidationFailed // = 400
  case permissionDenied // = 403
  case internalServerError // = 500
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 100: self = .publishTrackNotFound
    case 101: self = .publishTracksMismatch
    case 102: self = .publishTrackOutOfOrder
    case 103: self = .publishTrackVideoLayerNotFound
    case 200: self = .participantNotFound
    case 300: self = .callNotFound
    case 400: self = .requestValidationFailed
    case 403: self = .permissionDenied
    case 500: self = .internalServerError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .publishTrackNotFound: return 100
    case .publishTracksMismatch: return 101
    case .publishTrackOutOfOrder: return 102
    case .publishTrackVideoLayerNotFound: return 103
    case .participantNotFound: return 200
    case .callNotFound: return 300
    case .requestValidationFailed: return 400
    case .permissionDenied: return 403
    case .internalServerError: return 500
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Sfu_Models_ErrorCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Sfu_Models_ErrorCode] = [
    .unspecified,
    .publishTrackNotFound,
    .publishTracksMismatch,
    .publishTrackOutOfOrder,
    .publishTrackVideoLayerNotFound,
    .participantNotFound,
    .callNotFound,
    .requestValidationFailed,
    .permissionDenied,
    .internalServerError,
  ]
}

#endif  // swift(>=4.2)

struct Stream_Video_Sfu_Models_CallState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var participants: [Stream_Video_Sfu_Models_Participant] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// those who are online in the call
struct Stream_Video_Sfu_Models_Participant {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var sessionID: String = String()

  /// map of track id to track type
  var publishedTracks: [Stream_Video_Sfu_Models_TrackType] = []

  var joinedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _joinedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_joinedAt = newValue}
  }
  /// Returns true if `joinedAt` has been explicitly set.
  var hasJoinedAt: Bool {return self._joinedAt != nil}
  /// Clears the value of `joinedAt`. Subsequent reads from it will return its default value.
  mutating func clearJoinedAt() {self._joinedAt = nil}

  var trackLookupPrefix: String = String()

  var connectionQuality: Stream_Video_Sfu_Models_ConnectionQuality = .unspecified

  var isSpeaking: Bool = false

  var isDominantSpeaker: Bool = false

  var audioLevel: Float = 0

  var name: String = String()

  var image: String = String()

  var custom: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _custom ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_custom = newValue}
  }
  /// Returns true if `custom` has been explicitly set.
  var hasCustom: Bool {return self._custom != nil}
  /// Clears the value of `custom`. Subsequent reads from it will return its default value.
  mutating func clearCustom() {self._custom = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _joinedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

struct Stream_Video_Sfu_Models_StreamQuality {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var videoQuality: Stream_Video_Sfu_Models_VideoQuality = .lowUnspecified

  var userID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Models_VideoDimension {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: UInt32 = 0

  var height: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Models_VideoLayer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// for tracks with a single layer, this should be HIGH
  var rid: String = String()

  var videoDimension: Stream_Video_Sfu_Models_VideoDimension {
    get {return _videoDimension ?? Stream_Video_Sfu_Models_VideoDimension()}
    set {_videoDimension = newValue}
  }
  /// Returns true if `videoDimension` has been explicitly set.
  var hasVideoDimension: Bool {return self._videoDimension != nil}
  /// Clears the value of `videoDimension`. Subsequent reads from it will return its default value.
  mutating func clearVideoDimension() {self._videoDimension = nil}

  /// target bitrate, server will measure actual
  var bitrate: UInt32 = 0

  var fps: UInt32 = 0

  var quality: Stream_Video_Sfu_Models_VideoQuality = .lowUnspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _videoDimension: Stream_Video_Sfu_Models_VideoDimension? = nil
}

struct Stream_Video_Sfu_Models_Codec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payloadType: UInt32 = 0

  var name: String = String()

  var fmtpLine: String = String()

  var clockRate: UInt32 = 0

  var encodingParameters: String = String()

  var feedbacks: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Models_ICETrickle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peerType: Stream_Video_Sfu_Models_PeerType = .publisherUnspecified

  var iceCandidate: String = String()

  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Models_TrackInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trackID: String = String()

  var trackType: Stream_Video_Sfu_Models_TrackType = .unspecified

  var layers: [Stream_Video_Sfu_Models_VideoLayer] = []

  var mid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// todo remove this
struct Stream_Video_Sfu_Models_Call {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the call type
  var type: String = String()

  /// the call id
  var id: String = String()

  /// the id of the user that created this call
  var createdByUserID: String = String()

  /// the id of the current host for this call
  var hostUserID: String = String()

  var custom: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _custom ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_custom = newValue}
  }
  /// Returns true if `custom` has been explicitly set.
  var hasCustom: Bool {return self._custom != nil}
  /// Clears the value of `custom`. Subsequent reads from it will return its default value.
  mutating func clearCustom() {self._custom = nil}

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Stream_Video_Sfu_Models_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Stream_Video_Sfu_Models_ErrorCode = .unspecified

  var message: String = String()

  var shouldRetry: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stream_Video_Sfu_Models_PeerType: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_ConnectionQuality: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_VideoQuality: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_TrackType: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_ErrorCode: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_CallState: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_Participant: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_StreamQuality: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_VideoDimension: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_VideoLayer: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_Codec: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_ICETrickle: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_TrackInfo: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_Call: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_Error: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stream.video.sfu.models"

extension Stream_Video_Sfu_Models_PeerType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PEER_TYPE_PUBLISHER_UNSPECIFIED"),
    1: .same(proto: "PEER_TYPE_SUBSCRIBER"),
  ]
}

extension Stream_Video_Sfu_Models_ConnectionQuality: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONNECTION_QUALITY_UNSPECIFIED"),
    1: .same(proto: "CONNECTION_QUALITY_POOR"),
    2: .same(proto: "CONNECTION_QUALITY_GOOD"),
    3: .same(proto: "CONNECTION_QUALITY_EXCELLENT"),
  ]
}

extension Stream_Video_Sfu_Models_VideoQuality: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VIDEO_QUALITY_LOW_UNSPECIFIED"),
    1: .same(proto: "VIDEO_QUALITY_MID"),
    2: .same(proto: "VIDEO_QUALITY_HIGH"),
    3: .same(proto: "VIDEO_QUALITY_OFF"),
  ]
}

extension Stream_Video_Sfu_Models_TrackType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRACK_TYPE_UNSPECIFIED"),
    1: .same(proto: "TRACK_TYPE_AUDIO"),
    2: .same(proto: "TRACK_TYPE_VIDEO"),
    3: .same(proto: "TRACK_TYPE_SCREEN_SHARE"),
    4: .same(proto: "TRACK_TYPE_SCREEN_SHARE_AUDIO"),
  ]
}

extension Stream_Video_Sfu_Models_ErrorCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR_CODE_UNSPECIFIED"),
    100: .same(proto: "ERROR_CODE_PUBLISH_TRACK_NOT_FOUND"),
    101: .same(proto: "ERROR_CODE_PUBLISH_TRACKS_MISMATCH"),
    102: .same(proto: "ERROR_CODE_PUBLISH_TRACK_OUT_OF_ORDER"),
    103: .same(proto: "ERROR_CODE_PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND"),
    200: .same(proto: "ERROR_CODE_PARTICIPANT_NOT_FOUND"),
    300: .same(proto: "ERROR_CODE_CALL_NOT_FOUND"),
    400: .same(proto: "ERROR_CODE_REQUEST_VALIDATION_FAILED"),
    403: .same(proto: "ERROR_CODE_PERMISSION_DENIED"),
    500: .same(proto: "ERROR_CODE_INTERNAL_SERVER_ERROR"),
  ]
}

extension Stream_Video_Sfu_Models_CallState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "participants"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.participants) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.participants.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.participants, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_CallState, rhs: Stream_Video_Sfu_Models_CallState) -> Bool {
    if lhs.participants != rhs.participants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_Participant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Participant"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "session_id"),
    3: .standard(proto: "published_tracks"),
    4: .standard(proto: "joined_at"),
    5: .standard(proto: "track_lookup_prefix"),
    6: .standard(proto: "connection_quality"),
    7: .standard(proto: "is_speaking"),
    8: .standard(proto: "is_dominant_speaker"),
    9: .standard(proto: "audio_level"),
    10: .same(proto: "name"),
    11: .same(proto: "image"),
    12: .same(proto: "custom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.publishedTracks) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._joinedAt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.trackLookupPrefix) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.connectionQuality) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isSpeaking) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.isDominantSpeaker) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.audioLevel) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.image) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    if !self.publishedTracks.isEmpty {
      try visitor.visitPackedEnumField(value: self.publishedTracks, fieldNumber: 3)
    }
    try { if let v = self._joinedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.trackLookupPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.trackLookupPrefix, fieldNumber: 5)
    }
    if self.connectionQuality != .unspecified {
      try visitor.visitSingularEnumField(value: self.connectionQuality, fieldNumber: 6)
    }
    if self.isSpeaking != false {
      try visitor.visitSingularBoolField(value: self.isSpeaking, fieldNumber: 7)
    }
    if self.isDominantSpeaker != false {
      try visitor.visitSingularBoolField(value: self.isDominantSpeaker, fieldNumber: 8)
    }
    if self.audioLevel != 0 {
      try visitor.visitSingularFloatField(value: self.audioLevel, fieldNumber: 9)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 10)
    }
    if !self.image.isEmpty {
      try visitor.visitSingularStringField(value: self.image, fieldNumber: 11)
    }
    try { if let v = self._custom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_Participant, rhs: Stream_Video_Sfu_Models_Participant) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.publishedTracks != rhs.publishedTracks {return false}
    if lhs._joinedAt != rhs._joinedAt {return false}
    if lhs.trackLookupPrefix != rhs.trackLookupPrefix {return false}
    if lhs.connectionQuality != rhs.connectionQuality {return false}
    if lhs.isSpeaking != rhs.isSpeaking {return false}
    if lhs.isDominantSpeaker != rhs.isDominantSpeaker {return false}
    if lhs.audioLevel != rhs.audioLevel {return false}
    if lhs.name != rhs.name {return false}
    if lhs.image != rhs.image {return false}
    if lhs._custom != rhs._custom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_StreamQuality: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamQuality"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "video_quality"),
    2: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.videoQuality) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.videoQuality != .lowUnspecified {
      try visitor.visitSingularEnumField(value: self.videoQuality, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_StreamQuality, rhs: Stream_Video_Sfu_Models_StreamQuality) -> Bool {
    if lhs.videoQuality != rhs.videoQuality {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_VideoDimension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoDimension"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_VideoDimension, rhs: Stream_Video_Sfu_Models_VideoDimension) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_VideoLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoLayer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rid"),
    2: .standard(proto: "video_dimension"),
    4: .same(proto: "bitrate"),
    5: .same(proto: "fps"),
    6: .same(proto: "quality"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._videoDimension) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.bitrate) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.fps) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.quality) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rid.isEmpty {
      try visitor.visitSingularStringField(value: self.rid, fieldNumber: 1)
    }
    try { if let v = self._videoDimension {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.bitrate != 0 {
      try visitor.visitSingularUInt32Field(value: self.bitrate, fieldNumber: 4)
    }
    if self.fps != 0 {
      try visitor.visitSingularUInt32Field(value: self.fps, fieldNumber: 5)
    }
    if self.quality != .lowUnspecified {
      try visitor.visitSingularEnumField(value: self.quality, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_VideoLayer, rhs: Stream_Video_Sfu_Models_VideoLayer) -> Bool {
    if lhs.rid != rhs.rid {return false}
    if lhs._videoDimension != rhs._videoDimension {return false}
    if lhs.bitrate != rhs.bitrate {return false}
    if lhs.fps != rhs.fps {return false}
    if lhs.quality != rhs.quality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_Codec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Codec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payload_type"),
    2: .same(proto: "name"),
    3: .standard(proto: "fmtp_line"),
    4: .standard(proto: "clock_rate"),
    5: .standard(proto: "encoding_parameters"),
    6: .same(proto: "feedbacks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.payloadType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fmtpLine) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.clockRate) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.encodingParameters) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.feedbacks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.payloadType != 0 {
      try visitor.visitSingularUInt32Field(value: self.payloadType, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.fmtpLine.isEmpty {
      try visitor.visitSingularStringField(value: self.fmtpLine, fieldNumber: 3)
    }
    if self.clockRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.clockRate, fieldNumber: 4)
    }
    if !self.encodingParameters.isEmpty {
      try visitor.visitSingularStringField(value: self.encodingParameters, fieldNumber: 5)
    }
    if !self.feedbacks.isEmpty {
      try visitor.visitRepeatedStringField(value: self.feedbacks, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_Codec, rhs: Stream_Video_Sfu_Models_Codec) -> Bool {
    if lhs.payloadType != rhs.payloadType {return false}
    if lhs.name != rhs.name {return false}
    if lhs.fmtpLine != rhs.fmtpLine {return false}
    if lhs.clockRate != rhs.clockRate {return false}
    if lhs.encodingParameters != rhs.encodingParameters {return false}
    if lhs.feedbacks != rhs.feedbacks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_ICETrickle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ICETrickle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_type"),
    2: .standard(proto: "ice_candidate"),
    3: .standard(proto: "session_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.peerType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.iceCandidate) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.peerType != .publisherUnspecified {
      try visitor.visitSingularEnumField(value: self.peerType, fieldNumber: 1)
    }
    if !self.iceCandidate.isEmpty {
      try visitor.visitSingularStringField(value: self.iceCandidate, fieldNumber: 2)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_ICETrickle, rhs: Stream_Video_Sfu_Models_ICETrickle) -> Bool {
    if lhs.peerType != rhs.peerType {return false}
    if lhs.iceCandidate != rhs.iceCandidate {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_TrackInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "track_id"),
    2: .standard(proto: "track_type"),
    5: .same(proto: "layers"),
    6: .same(proto: "mid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.trackType) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.layers) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.mid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackID, fieldNumber: 1)
    }
    if self.trackType != .unspecified {
      try visitor.visitSingularEnumField(value: self.trackType, fieldNumber: 2)
    }
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 5)
    }
    if !self.mid.isEmpty {
      try visitor.visitSingularStringField(value: self.mid, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_TrackInfo, rhs: Stream_Video_Sfu_Models_TrackInfo) -> Bool {
    if lhs.trackID != rhs.trackID {return false}
    if lhs.trackType != rhs.trackType {return false}
    if lhs.layers != rhs.layers {return false}
    if lhs.mid != rhs.mid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_Call: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Call"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .standard(proto: "created_by_user_id"),
    4: .standard(proto: "host_user_id"),
    5: .same(proto: "custom"),
    6: .standard(proto: "created_at"),
    7: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.createdByUserID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.hostUserID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.createdByUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.createdByUserID, fieldNumber: 3)
    }
    if !self.hostUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.hostUserID, fieldNumber: 4)
    }
    try { if let v = self._custom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_Call, rhs: Stream_Video_Sfu_Models_Call) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.createdByUserID != rhs.createdByUserID {return false}
    if lhs.hostUserID != rhs.hostUserID {return false}
    if lhs._custom != rhs._custom {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .standard(proto: "should_retry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.shouldRetry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .unspecified {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.shouldRetry != false {
      try visitor.visitSingularBoolField(value: self.shouldRetry, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_Error, rhs: Stream_Video_Sfu_Models_Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.shouldRetry != rhs.shouldRetry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
