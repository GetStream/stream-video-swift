// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: video/sfu/models/models.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Stream_Video_Sfu_Models_PeerType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// todo fix me (marcelo)
  case publisherUnspecified // = 0
  case subscriber // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .publisherUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .publisherUnspecified
    case 1: self = .subscriber
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .publisherUnspecified: return 0
    case .subscriber: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Sfu_Models_PeerType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Sfu_Models_PeerType] = [
    .publisherUnspecified,
    .subscriber,
  ]
}

#endif  // swift(>=4.2)

enum Stream_Video_Sfu_Models_ConnectionQuality: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case poor // = 1
  case good // = 2
  case excellent // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .poor
    case 2: self = .good
    case 3: self = .excellent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .poor: return 1
    case .good: return 2
    case .excellent: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Sfu_Models_ConnectionQuality: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Sfu_Models_ConnectionQuality] = [
    .unspecified,
    .poor,
    .good,
    .excellent,
  ]
}

#endif  // swift(>=4.2)

enum Stream_Video_Sfu_Models_VideoQuality: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case lowUnspecified // = 0
  case mid // = 1
  case high // = 2
  case off // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .lowUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .lowUnspecified
    case 1: self = .mid
    case 2: self = .high
    case 3: self = .off
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .lowUnspecified: return 0
    case .mid: return 1
    case .high: return 2
    case .off: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Sfu_Models_VideoQuality: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Sfu_Models_VideoQuality] = [
    .lowUnspecified,
    .mid,
    .high,
    .off,
  ]
}

#endif  // swift(>=4.2)

enum Stream_Video_Sfu_Models_TrackType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case audio // = 1
  case video // = 2
  case screenShare // = 3
  case screenShareAudio // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .audio
    case 2: self = .video
    case 3: self = .screenShare
    case 4: self = .screenShareAudio
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .audio: return 1
    case .video: return 2
    case .screenShare: return 3
    case .screenShareAudio: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Sfu_Models_TrackType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Sfu_Models_TrackType] = [
    .unspecified,
    .audio,
    .video,
    .screenShare,
    .screenShareAudio,
  ]
}

#endif  // swift(>=4.2)

enum Stream_Video_Sfu_Models_ErrorCode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case publishTrackNotFound // = 100
  case publishTracksMismatch // = 101
  case publishTrackOutOfOrder // = 102
  case publishTrackVideoLayerNotFound // = 103
  case liveEnded // = 104
  case participantNotFound // = 200
  case participantMigratingOut // = 201
  case participantMigrationFailed // = 202
  case participantMigrating // = 203
  case participantReconnectFailed // = 204
  case participantMediaTransportFailure // = 205
  case callNotFound // = 300
  case requestValidationFailed // = 400
  case unauthenticated // = 401
  case permissionDenied // = 403
  case tooManyRequests // = 429
  case internalServerError // = 500
  case sfuShuttingDown // = 600
  case sfuFull // = 700
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 100: self = .publishTrackNotFound
    case 101: self = .publishTracksMismatch
    case 102: self = .publishTrackOutOfOrder
    case 103: self = .publishTrackVideoLayerNotFound
    case 104: self = .liveEnded
    case 200: self = .participantNotFound
    case 201: self = .participantMigratingOut
    case 202: self = .participantMigrationFailed
    case 203: self = .participantMigrating
    case 204: self = .participantReconnectFailed
    case 205: self = .participantMediaTransportFailure
    case 300: self = .callNotFound
    case 400: self = .requestValidationFailed
    case 401: self = .unauthenticated
    case 403: self = .permissionDenied
    case 429: self = .tooManyRequests
    case 500: self = .internalServerError
    case 600: self = .sfuShuttingDown
    case 700: self = .sfuFull
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .publishTrackNotFound: return 100
    case .publishTracksMismatch: return 101
    case .publishTrackOutOfOrder: return 102
    case .publishTrackVideoLayerNotFound: return 103
    case .liveEnded: return 104
    case .participantNotFound: return 200
    case .participantMigratingOut: return 201
    case .participantMigrationFailed: return 202
    case .participantMigrating: return 203
    case .participantReconnectFailed: return 204
    case .participantMediaTransportFailure: return 205
    case .callNotFound: return 300
    case .requestValidationFailed: return 400
    case .unauthenticated: return 401
    case .permissionDenied: return 403
    case .tooManyRequests: return 429
    case .internalServerError: return 500
    case .sfuShuttingDown: return 600
    case .sfuFull: return 700
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Sfu_Models_ErrorCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Sfu_Models_ErrorCode] = [
    .unspecified,
    .publishTrackNotFound,
    .publishTracksMismatch,
    .publishTrackOutOfOrder,
    .publishTrackVideoLayerNotFound,
    .liveEnded,
    .participantNotFound,
    .participantMigratingOut,
    .participantMigrationFailed,
    .participantMigrating,
    .participantReconnectFailed,
    .participantMediaTransportFailure,
    .callNotFound,
    .requestValidationFailed,
    .unauthenticated,
    .permissionDenied,
    .tooManyRequests,
    .internalServerError,
    .sfuShuttingDown,
    .sfuFull,
  ]
}

#endif  // swift(>=4.2)

enum Stream_Video_Sfu_Models_SdkType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case react // = 1
  case angular // = 2
  case android // = 3
  case ios // = 4
  case flutter // = 5
  case reactNative // = 6
  case unity // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .react
    case 2: self = .angular
    case 3: self = .android
    case 4: self = .ios
    case 5: self = .flutter
    case 6: self = .reactNative
    case 7: self = .unity
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .react: return 1
    case .angular: return 2
    case .android: return 3
    case .ios: return 4
    case .flutter: return 5
    case .reactNative: return 6
    case .unity: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Sfu_Models_SdkType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Sfu_Models_SdkType] = [
    .unspecified,
    .react,
    .angular,
    .android,
    .ios,
    .flutter,
    .reactNative,
    .unity,
  ]
}

#endif  // swift(>=4.2)

enum Stream_Video_Sfu_Models_TrackUnpublishReason: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Default value which is used when the specific reason
  /// for muting the track is not known.
  case unspecified // = 0

  /// Represents user muting their tracks.
  case userMuted // = 1

  /// Represents muting the track because the permission to
  /// publish the track has been revoked.
  case permissionRevoked // = 2

  /// Represents muting the track due to moderation actions.
  /// This is different from permission revoked because the
  /// participant can unmute themselves here whereas in case
  /// of "permission revoke" it is not possible until the
  /// call permissions are updated.
  case moderation // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .userMuted
    case 2: self = .permissionRevoked
    case 3: self = .moderation
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .userMuted: return 1
    case .permissionRevoked: return 2
    case .moderation: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Sfu_Models_TrackUnpublishReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Sfu_Models_TrackUnpublishReason] = [
    .unspecified,
    .userMuted,
    .permissionRevoked,
    .moderation,
  ]
}

#endif  // swift(>=4.2)

/// GoAwayReason represents the reason for the SFU to
/// disconnect the client.
enum Stream_Video_Sfu_Models_GoAwayReason: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case shuttingDown // = 1
  case rebalance // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .shuttingDown
    case 2: self = .rebalance
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .shuttingDown: return 1
    case .rebalance: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Sfu_Models_GoAwayReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Sfu_Models_GoAwayReason] = [
    .unspecified,
    .shuttingDown,
    .rebalance,
  ]
}

#endif  // swift(>=4.2)

/// CallEndedReason represents the reason for the call to end.
enum Stream_Video_Sfu_Models_CallEndedReason: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case ended // = 1
  case liveEnded // = 2
  case kicked // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .ended
    case 2: self = .liveEnded
    case 3: self = .kicked
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .ended: return 1
    case .liveEnded: return 2
    case .kicked: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Stream_Video_Sfu_Models_CallEndedReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Sfu_Models_CallEndedReason] = [
    .unspecified,
    .ended,
    .liveEnded,
    .kicked,
  ]
}

#endif  // swift(>=4.2)

/// CallState is the current state of the call
/// as seen by an SFU.
struct Stream_Video_Sfu_Models_CallState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// participants is the list of participants in the call.
  /// In large calls, the list could be truncated in which
  /// case, the list of participants contains fewer participants
  /// than the counts returned in participant_count. Anonymous
  /// participants are **NOT** included in the list.
  var participants: [Stream_Video_Sfu_Models_Participant] = []

  /// started_at is the time the call session actually started.
  var startedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startedAt = newValue}
  }
  /// Returns true if `startedAt` has been explicitly set.
  var hasStartedAt: Bool {return self._startedAt != nil}
  /// Clears the value of `startedAt`. Subsequent reads from it will return its default value.
  mutating func clearStartedAt() {self._startedAt = nil}

  /// participant_count contains the summary of the counts.
  var participantCount: Stream_Video_Sfu_Models_ParticipantCount {
    get {return _participantCount ?? Stream_Video_Sfu_Models_ParticipantCount()}
    set {_participantCount = newValue}
  }
  /// Returns true if `participantCount` has been explicitly set.
  var hasParticipantCount: Bool {return self._participantCount != nil}
  /// Clears the value of `participantCount`. Subsequent reads from it will return its default value.
  mutating func clearParticipantCount() {self._participantCount = nil}

  /// the list of pins in the call.
  /// Pins are ordered in descending order (most important first).
  var pins: [Stream_Video_Sfu_Models_Pin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _participantCount: Stream_Video_Sfu_Models_ParticipantCount? = nil
}

struct Stream_Video_Sfu_Models_ParticipantCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Total number of participants in the call including
  /// the anonymous participants.
  var total: UInt32 = 0

  /// Total number of anonymous participants in the call.
  var anonymous: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Models_Pin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the user to pin
  var userID: String = String()

  /// the user sesion_id to pin, if not provided, applies to all sessions
  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// those who are online in the call
struct Stream_Video_Sfu_Models_Participant {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var sessionID: String = String()

  /// map of track id to track type
  var publishedTracks: [Stream_Video_Sfu_Models_TrackType] = []

  var joinedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _joinedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_joinedAt = newValue}
  }
  /// Returns true if `joinedAt` has been explicitly set.
  var hasJoinedAt: Bool {return self._joinedAt != nil}
  /// Clears the value of `joinedAt`. Subsequent reads from it will return its default value.
  mutating func clearJoinedAt() {self._joinedAt = nil}

  var trackLookupPrefix: String = String()

  var connectionQuality: Stream_Video_Sfu_Models_ConnectionQuality = .unspecified

  var isSpeaking: Bool = false

  var isDominantSpeaker: Bool = false

  var audioLevel: Float = 0

  var name: String = String()

  var image: String = String()

  var custom: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _custom ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_custom = newValue}
  }
  /// Returns true if `custom` has been explicitly set.
  var hasCustom: Bool {return self._custom != nil}
  /// Clears the value of `custom`. Subsequent reads from it will return its default value.
  mutating func clearCustom() {self._custom = nil}

  var roles: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _joinedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

struct Stream_Video_Sfu_Models_StreamQuality {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var videoQuality: Stream_Video_Sfu_Models_VideoQuality = .lowUnspecified

  var userID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Models_VideoDimension {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: UInt32 = 0

  var height: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Models_VideoLayer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// for tracks with a single layer, this should be HIGH
  var rid: String = String()

  var videoDimension: Stream_Video_Sfu_Models_VideoDimension {
    get {return _videoDimension ?? Stream_Video_Sfu_Models_VideoDimension()}
    set {_videoDimension = newValue}
  }
  /// Returns true if `videoDimension` has been explicitly set.
  var hasVideoDimension: Bool {return self._videoDimension != nil}
  /// Clears the value of `videoDimension`. Subsequent reads from it will return its default value.
  mutating func clearVideoDimension() {self._videoDimension = nil}

  /// target bitrate, server will measure actual
  var bitrate: UInt32 = 0

  var fps: UInt32 = 0

  var quality: Stream_Video_Sfu_Models_VideoQuality = .lowUnspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _videoDimension: Stream_Video_Sfu_Models_VideoDimension? = nil
}

struct Stream_Video_Sfu_Models_Codec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payloadType: UInt32 = 0

  var name: String = String()

  var fmtpLine: String = String()

  var clockRate: UInt32 = 0

  var encodingParameters: String = String()

  var feedbacks: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Models_ICETrickle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peerType: Stream_Video_Sfu_Models_PeerType = .publisherUnspecified

  var iceCandidate: String = String()

  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Models_TrackInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trackID: String = String()

  var trackType: Stream_Video_Sfu_Models_TrackType = .unspecified

  var layers: [Stream_Video_Sfu_Models_VideoLayer] = []

  var mid: String = String()

  /// for audio tracks
  var dtx: Bool = false

  var stereo: Bool = false

  var red: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// todo remove this
struct Stream_Video_Sfu_Models_Call {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the call type
  var type: String = String()

  /// the call id
  var id: String = String()

  /// the id of the user that created this call
  var createdByUserID: String = String()

  /// the id of the current host for this call
  var hostUserID: String = String()

  var custom: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _custom ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_custom = newValue}
  }
  /// Returns true if `custom` has been explicitly set.
  var hasCustom: Bool {return self._custom != nil}
  /// Clears the value of `custom`. Subsequent reads from it will return its default value.
  mutating func clearCustom() {self._custom = nil}

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _custom: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Stream_Video_Sfu_Models_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Stream_Video_Sfu_Models_ErrorCode = .unspecified

  var message: String = String()

  var shouldRetry: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Models_ClientDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sdk: Stream_Video_Sfu_Models_Sdk {
    get {return _sdk ?? Stream_Video_Sfu_Models_Sdk()}
    set {_sdk = newValue}
  }
  /// Returns true if `sdk` has been explicitly set.
  var hasSdk: Bool {return self._sdk != nil}
  /// Clears the value of `sdk`. Subsequent reads from it will return its default value.
  mutating func clearSdk() {self._sdk = nil}

  var os: Stream_Video_Sfu_Models_OS {
    get {return _os ?? Stream_Video_Sfu_Models_OS()}
    set {_os = newValue}
  }
  /// Returns true if `os` has been explicitly set.
  var hasOs: Bool {return self._os != nil}
  /// Clears the value of `os`. Subsequent reads from it will return its default value.
  mutating func clearOs() {self._os = nil}

  var browser: Stream_Video_Sfu_Models_Browser {
    get {return _browser ?? Stream_Video_Sfu_Models_Browser()}
    set {_browser = newValue}
  }
  /// Returns true if `browser` has been explicitly set.
  var hasBrowser: Bool {return self._browser != nil}
  /// Clears the value of `browser`. Subsequent reads from it will return its default value.
  mutating func clearBrowser() {self._browser = nil}

  var device: Stream_Video_Sfu_Models_Device {
    get {return _device ?? Stream_Video_Sfu_Models_Device()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {self._device = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sdk: Stream_Video_Sfu_Models_Sdk? = nil
  fileprivate var _os: Stream_Video_Sfu_Models_OS? = nil
  fileprivate var _browser: Stream_Video_Sfu_Models_Browser? = nil
  fileprivate var _device: Stream_Video_Sfu_Models_Device? = nil
}

struct Stream_Video_Sfu_Models_Sdk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Stream_Video_Sfu_Models_SdkType = .unspecified

  var major: String = String()

  var minor: String = String()

  var patch: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Models_OS {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var version: String = String()

  var architecture: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Models_Browser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var version: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Models_Device {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var version: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CallGrants represents the set of permissions given
/// to the user for the current call.
struct Stream_Video_Sfu_Models_CallGrants {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var canPublishAudio: Bool = false

  var canPublishVideo: Bool = false

  var canScreenshare: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stream_Video_Sfu_Models_PeerType: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_ConnectionQuality: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_VideoQuality: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_TrackType: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_ErrorCode: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_SdkType: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_TrackUnpublishReason: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_GoAwayReason: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_CallEndedReason: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_CallState: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_ParticipantCount: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_Pin: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_Participant: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_StreamQuality: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_VideoDimension: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_VideoLayer: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_Codec: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_ICETrickle: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_TrackInfo: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_Call: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_Error: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_ClientDetails: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_Sdk: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_OS: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_Browser: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_Device: @unchecked Sendable {}
extension Stream_Video_Sfu_Models_CallGrants: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stream.video.sfu.models"

extension Stream_Video_Sfu_Models_PeerType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PEER_TYPE_PUBLISHER_UNSPECIFIED"),
    1: .same(proto: "PEER_TYPE_SUBSCRIBER"),
  ]
}

extension Stream_Video_Sfu_Models_ConnectionQuality: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONNECTION_QUALITY_UNSPECIFIED"),
    1: .same(proto: "CONNECTION_QUALITY_POOR"),
    2: .same(proto: "CONNECTION_QUALITY_GOOD"),
    3: .same(proto: "CONNECTION_QUALITY_EXCELLENT"),
  ]
}

extension Stream_Video_Sfu_Models_VideoQuality: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VIDEO_QUALITY_LOW_UNSPECIFIED"),
    1: .same(proto: "VIDEO_QUALITY_MID"),
    2: .same(proto: "VIDEO_QUALITY_HIGH"),
    3: .same(proto: "VIDEO_QUALITY_OFF"),
  ]
}

extension Stream_Video_Sfu_Models_TrackType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRACK_TYPE_UNSPECIFIED"),
    1: .same(proto: "TRACK_TYPE_AUDIO"),
    2: .same(proto: "TRACK_TYPE_VIDEO"),
    3: .same(proto: "TRACK_TYPE_SCREEN_SHARE"),
    4: .same(proto: "TRACK_TYPE_SCREEN_SHARE_AUDIO"),
  ]
}

extension Stream_Video_Sfu_Models_ErrorCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR_CODE_UNSPECIFIED"),
    100: .same(proto: "ERROR_CODE_PUBLISH_TRACK_NOT_FOUND"),
    101: .same(proto: "ERROR_CODE_PUBLISH_TRACKS_MISMATCH"),
    102: .same(proto: "ERROR_CODE_PUBLISH_TRACK_OUT_OF_ORDER"),
    103: .same(proto: "ERROR_CODE_PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND"),
    104: .same(proto: "ERROR_CODE_LIVE_ENDED"),
    200: .same(proto: "ERROR_CODE_PARTICIPANT_NOT_FOUND"),
    201: .same(proto: "ERROR_CODE_PARTICIPANT_MIGRATING_OUT"),
    202: .same(proto: "ERROR_CODE_PARTICIPANT_MIGRATION_FAILED"),
    203: .same(proto: "ERROR_CODE_PARTICIPANT_MIGRATING"),
    204: .same(proto: "ERROR_CODE_PARTICIPANT_RECONNECT_FAILED"),
    205: .same(proto: "ERROR_CODE_PARTICIPANT_MEDIA_TRANSPORT_FAILURE"),
    300: .same(proto: "ERROR_CODE_CALL_NOT_FOUND"),
    400: .same(proto: "ERROR_CODE_REQUEST_VALIDATION_FAILED"),
    401: .same(proto: "ERROR_CODE_UNAUTHENTICATED"),
    403: .same(proto: "ERROR_CODE_PERMISSION_DENIED"),
    429: .same(proto: "ERROR_CODE_TOO_MANY_REQUESTS"),
    500: .same(proto: "ERROR_CODE_INTERNAL_SERVER_ERROR"),
    600: .same(proto: "ERROR_CODE_SFU_SHUTTING_DOWN"),
    700: .same(proto: "ERROR_CODE_SFU_FULL"),
  ]
}

extension Stream_Video_Sfu_Models_SdkType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SDK_TYPE_UNSPECIFIED"),
    1: .same(proto: "SDK_TYPE_REACT"),
    2: .same(proto: "SDK_TYPE_ANGULAR"),
    3: .same(proto: "SDK_TYPE_ANDROID"),
    4: .same(proto: "SDK_TYPE_IOS"),
    5: .same(proto: "SDK_TYPE_FLUTTER"),
    6: .same(proto: "SDK_TYPE_REACT_NATIVE"),
    7: .same(proto: "SDK_TYPE_UNITY"),
  ]
}

extension Stream_Video_Sfu_Models_TrackUnpublishReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRACK_UNPUBLISH_REASON_UNSPECIFIED"),
    1: .same(proto: "TRACK_UNPUBLISH_REASON_USER_MUTED"),
    2: .same(proto: "TRACK_UNPUBLISH_REASON_PERMISSION_REVOKED"),
    3: .same(proto: "TRACK_UNPUBLISH_REASON_MODERATION"),
  ]
}

extension Stream_Video_Sfu_Models_GoAwayReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GO_AWAY_REASON_UNSPECIFIED"),
    1: .same(proto: "GO_AWAY_REASON_SHUTTING_DOWN"),
    2: .same(proto: "GO_AWAY_REASON_REBALANCE"),
  ]
}

extension Stream_Video_Sfu_Models_CallEndedReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CALL_ENDED_REASON_UNSPECIFIED"),
    1: .same(proto: "CALL_ENDED_REASON_ENDED"),
    2: .same(proto: "CALL_ENDED_REASON_LIVE_ENDED"),
    3: .same(proto: "CALL_ENDED_REASON_KICKED"),
  ]
}

extension Stream_Video_Sfu_Models_CallState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "participants"),
    2: .standard(proto: "started_at"),
    3: .standard(proto: "participant_count"),
    4: .same(proto: "pins"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.participants) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startedAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._participantCount) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.pins) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.participants.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.participants, fieldNumber: 1)
    }
    try { if let v = self._startedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._participantCount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.pins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pins, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_CallState, rhs: Stream_Video_Sfu_Models_CallState) -> Bool {
    if lhs.participants != rhs.participants {return false}
    if lhs._startedAt != rhs._startedAt {return false}
    if lhs._participantCount != rhs._participantCount {return false}
    if lhs.pins != rhs.pins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_ParticipantCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantCount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "anonymous"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.anonymous) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularUInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.anonymous != 0 {
      try visitor.visitSingularUInt32Field(value: self.anonymous, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_ParticipantCount, rhs: Stream_Video_Sfu_Models_ParticipantCount) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.anonymous != rhs.anonymous {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_Pin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "session_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_Pin, rhs: Stream_Video_Sfu_Models_Pin) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_Participant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Participant"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "session_id"),
    3: .standard(proto: "published_tracks"),
    4: .standard(proto: "joined_at"),
    5: .standard(proto: "track_lookup_prefix"),
    6: .standard(proto: "connection_quality"),
    7: .standard(proto: "is_speaking"),
    8: .standard(proto: "is_dominant_speaker"),
    9: .standard(proto: "audio_level"),
    10: .same(proto: "name"),
    11: .same(proto: "image"),
    12: .same(proto: "custom"),
    13: .same(proto: "roles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.publishedTracks) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._joinedAt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.trackLookupPrefix) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.connectionQuality) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isSpeaking) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.isDominantSpeaker) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.audioLevel) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.image) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
      case 13: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    if !self.publishedTracks.isEmpty {
      try visitor.visitPackedEnumField(value: self.publishedTracks, fieldNumber: 3)
    }
    try { if let v = self._joinedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.trackLookupPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.trackLookupPrefix, fieldNumber: 5)
    }
    if self.connectionQuality != .unspecified {
      try visitor.visitSingularEnumField(value: self.connectionQuality, fieldNumber: 6)
    }
    if self.isSpeaking != false {
      try visitor.visitSingularBoolField(value: self.isSpeaking, fieldNumber: 7)
    }
    if self.isDominantSpeaker != false {
      try visitor.visitSingularBoolField(value: self.isDominantSpeaker, fieldNumber: 8)
    }
    if self.audioLevel != 0 {
      try visitor.visitSingularFloatField(value: self.audioLevel, fieldNumber: 9)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 10)
    }
    if !self.image.isEmpty {
      try visitor.visitSingularStringField(value: self.image, fieldNumber: 11)
    }
    try { if let v = self._custom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_Participant, rhs: Stream_Video_Sfu_Models_Participant) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.publishedTracks != rhs.publishedTracks {return false}
    if lhs._joinedAt != rhs._joinedAt {return false}
    if lhs.trackLookupPrefix != rhs.trackLookupPrefix {return false}
    if lhs.connectionQuality != rhs.connectionQuality {return false}
    if lhs.isSpeaking != rhs.isSpeaking {return false}
    if lhs.isDominantSpeaker != rhs.isDominantSpeaker {return false}
    if lhs.audioLevel != rhs.audioLevel {return false}
    if lhs.name != rhs.name {return false}
    if lhs.image != rhs.image {return false}
    if lhs._custom != rhs._custom {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_StreamQuality: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamQuality"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "video_quality"),
    2: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.videoQuality) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.videoQuality != .lowUnspecified {
      try visitor.visitSingularEnumField(value: self.videoQuality, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_StreamQuality, rhs: Stream_Video_Sfu_Models_StreamQuality) -> Bool {
    if lhs.videoQuality != rhs.videoQuality {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_VideoDimension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoDimension"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_VideoDimension, rhs: Stream_Video_Sfu_Models_VideoDimension) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_VideoLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoLayer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rid"),
    2: .standard(proto: "video_dimension"),
    4: .same(proto: "bitrate"),
    5: .same(proto: "fps"),
    6: .same(proto: "quality"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._videoDimension) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.bitrate) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.fps) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.quality) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rid.isEmpty {
      try visitor.visitSingularStringField(value: self.rid, fieldNumber: 1)
    }
    try { if let v = self._videoDimension {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.bitrate != 0 {
      try visitor.visitSingularUInt32Field(value: self.bitrate, fieldNumber: 4)
    }
    if self.fps != 0 {
      try visitor.visitSingularUInt32Field(value: self.fps, fieldNumber: 5)
    }
    if self.quality != .lowUnspecified {
      try visitor.visitSingularEnumField(value: self.quality, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_VideoLayer, rhs: Stream_Video_Sfu_Models_VideoLayer) -> Bool {
    if lhs.rid != rhs.rid {return false}
    if lhs._videoDimension != rhs._videoDimension {return false}
    if lhs.bitrate != rhs.bitrate {return false}
    if lhs.fps != rhs.fps {return false}
    if lhs.quality != rhs.quality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_Codec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Codec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payload_type"),
    2: .same(proto: "name"),
    3: .standard(proto: "fmtp_line"),
    4: .standard(proto: "clock_rate"),
    5: .standard(proto: "encoding_parameters"),
    6: .same(proto: "feedbacks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.payloadType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fmtpLine) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.clockRate) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.encodingParameters) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.feedbacks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.payloadType != 0 {
      try visitor.visitSingularUInt32Field(value: self.payloadType, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.fmtpLine.isEmpty {
      try visitor.visitSingularStringField(value: self.fmtpLine, fieldNumber: 3)
    }
    if self.clockRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.clockRate, fieldNumber: 4)
    }
    if !self.encodingParameters.isEmpty {
      try visitor.visitSingularStringField(value: self.encodingParameters, fieldNumber: 5)
    }
    if !self.feedbacks.isEmpty {
      try visitor.visitRepeatedStringField(value: self.feedbacks, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_Codec, rhs: Stream_Video_Sfu_Models_Codec) -> Bool {
    if lhs.payloadType != rhs.payloadType {return false}
    if lhs.name != rhs.name {return false}
    if lhs.fmtpLine != rhs.fmtpLine {return false}
    if lhs.clockRate != rhs.clockRate {return false}
    if lhs.encodingParameters != rhs.encodingParameters {return false}
    if lhs.feedbacks != rhs.feedbacks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_ICETrickle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ICETrickle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_type"),
    2: .standard(proto: "ice_candidate"),
    3: .standard(proto: "session_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.peerType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.iceCandidate) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.peerType != .publisherUnspecified {
      try visitor.visitSingularEnumField(value: self.peerType, fieldNumber: 1)
    }
    if !self.iceCandidate.isEmpty {
      try visitor.visitSingularStringField(value: self.iceCandidate, fieldNumber: 2)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_ICETrickle, rhs: Stream_Video_Sfu_Models_ICETrickle) -> Bool {
    if lhs.peerType != rhs.peerType {return false}
    if lhs.iceCandidate != rhs.iceCandidate {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_TrackInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "track_id"),
    2: .standard(proto: "track_type"),
    5: .same(proto: "layers"),
    6: .same(proto: "mid"),
    7: .same(proto: "dtx"),
    8: .same(proto: "stereo"),
    9: .same(proto: "red"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.trackType) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.layers) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.mid) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.dtx) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.stereo) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.red) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackID, fieldNumber: 1)
    }
    if self.trackType != .unspecified {
      try visitor.visitSingularEnumField(value: self.trackType, fieldNumber: 2)
    }
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 5)
    }
    if !self.mid.isEmpty {
      try visitor.visitSingularStringField(value: self.mid, fieldNumber: 6)
    }
    if self.dtx != false {
      try visitor.visitSingularBoolField(value: self.dtx, fieldNumber: 7)
    }
    if self.stereo != false {
      try visitor.visitSingularBoolField(value: self.stereo, fieldNumber: 8)
    }
    if self.red != false {
      try visitor.visitSingularBoolField(value: self.red, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_TrackInfo, rhs: Stream_Video_Sfu_Models_TrackInfo) -> Bool {
    if lhs.trackID != rhs.trackID {return false}
    if lhs.trackType != rhs.trackType {return false}
    if lhs.layers != rhs.layers {return false}
    if lhs.mid != rhs.mid {return false}
    if lhs.dtx != rhs.dtx {return false}
    if lhs.stereo != rhs.stereo {return false}
    if lhs.red != rhs.red {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_Call: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Call"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .standard(proto: "created_by_user_id"),
    4: .standard(proto: "host_user_id"),
    5: .same(proto: "custom"),
    6: .standard(proto: "created_at"),
    7: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.createdByUserID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.hostUserID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._custom) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.createdByUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.createdByUserID, fieldNumber: 3)
    }
    if !self.hostUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.hostUserID, fieldNumber: 4)
    }
    try { if let v = self._custom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_Call, rhs: Stream_Video_Sfu_Models_Call) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.createdByUserID != rhs.createdByUserID {return false}
    if lhs.hostUserID != rhs.hostUserID {return false}
    if lhs._custom != rhs._custom {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .standard(proto: "should_retry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.shouldRetry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .unspecified {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.shouldRetry != false {
      try visitor.visitSingularBoolField(value: self.shouldRetry, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_Error, rhs: Stream_Video_Sfu_Models_Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.shouldRetry != rhs.shouldRetry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_ClientDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sdk"),
    2: .same(proto: "os"),
    3: .same(proto: "browser"),
    4: .same(proto: "device"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sdk) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._os) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._browser) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sdk {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._os {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._browser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_ClientDetails, rhs: Stream_Video_Sfu_Models_ClientDetails) -> Bool {
    if lhs._sdk != rhs._sdk {return false}
    if lhs._os != rhs._os {return false}
    if lhs._browser != rhs._browser {return false}
    if lhs._device != rhs._device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_Sdk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Sdk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "major"),
    3: .same(proto: "minor"),
    4: .same(proto: "patch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.major) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.minor) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.patch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.major.isEmpty {
      try visitor.visitSingularStringField(value: self.major, fieldNumber: 2)
    }
    if !self.minor.isEmpty {
      try visitor.visitSingularStringField(value: self.minor, fieldNumber: 3)
    }
    if !self.patch.isEmpty {
      try visitor.visitSingularStringField(value: self.patch, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_Sdk, rhs: Stream_Video_Sfu_Models_Sdk) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.major != rhs.major {return false}
    if lhs.minor != rhs.minor {return false}
    if lhs.patch != rhs.patch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_OS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OS"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "version"),
    3: .same(proto: "architecture"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.architecture) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.architecture.isEmpty {
      try visitor.visitSingularStringField(value: self.architecture, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_OS, rhs: Stream_Video_Sfu_Models_OS) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.version != rhs.version {return false}
    if lhs.architecture != rhs.architecture {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_Browser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Browser"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_Browser, rhs: Stream_Video_Sfu_Models_Browser) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Device"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_Device, rhs: Stream_Video_Sfu_Models_Device) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Models_CallGrants: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallGrants"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_publish_audio"),
    2: .standard(proto: "can_publish_video"),
    3: .standard(proto: "can_screenshare"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canPublishAudio) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canPublishVideo) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canScreenshare) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canPublishAudio != false {
      try visitor.visitSingularBoolField(value: self.canPublishAudio, fieldNumber: 1)
    }
    if self.canPublishVideo != false {
      try visitor.visitSingularBoolField(value: self.canPublishVideo, fieldNumber: 2)
    }
    if self.canScreenshare != false {
      try visitor.visitSingularBoolField(value: self.canScreenshare, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Models_CallGrants, rhs: Stream_Video_Sfu_Models_CallGrants) -> Bool {
    if lhs.canPublishAudio != rhs.canPublishAudio {return false}
    if lhs.canPublishVideo != rhs.canPublishVideo {return false}
    if lhs.canScreenshare != rhs.canScreenshare {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
