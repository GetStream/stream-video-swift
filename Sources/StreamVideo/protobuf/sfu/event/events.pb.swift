// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: video/sfu/event/events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// SFUEvent is a message that is sent from the SFU to the client.
struct Stream_Video_Sfu_Event_SfuEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventPayload: Stream_Video_Sfu_Event_SfuEvent.OneOf_EventPayload? = nil

  /// SubscriberOffer sends the SDP offer for establishing the
  /// subscriber PeerConnection.
  var subscriberOffer: Stream_Video_Sfu_Event_SubscriberOffer {
    get {
      if case .subscriberOffer(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_SubscriberOffer()
    }
    set {eventPayload = .subscriberOffer(newValue)}
  }

  /// PublisherAnswer sends the SDP answer to the offer sent by
  /// the client for establishing the Publisher PeerConnection.
  var publisherAnswer: Stream_Video_Sfu_Event_PublisherAnswer {
    get {
      if case .publisherAnswer(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_PublisherAnswer()
    }
    set {eventPayload = .publisherAnswer(newValue)}
  }

  /// ConnectionQualityChanged is sent to inform the connection
  /// quality of the participants in the call. It does not have
  /// to contain the full list of call participants in it.
  var connectionQualityChanged: Stream_Video_Sfu_Event_ConnectionQualityChanged {
    get {
      if case .connectionQualityChanged(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_ConnectionQualityChanged()
    }
    set {eventPayload = .connectionQualityChanged(newValue)}
  }

  /// AudioLevelChanged is sent for change in audio levels of
  /// the participants.
  var audioLevelChanged: Stream_Video_Sfu_Event_AudioLevelChanged {
    get {
      if case .audioLevelChanged(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_AudioLevelChanged()
    }
    set {eventPayload = .audioLevelChanged(newValue)}
  }

  /// ICETrickle contains the ICE candidate required to establish
  /// the ICE transport: part of establishing the PeerConnection
  /// and also for ICE restarts.
  var iceTrickle: Stream_Video_Sfu_Models_ICETrickle {
    get {
      if case .iceTrickle(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Models_ICETrickle()
    }
    set {eventPayload = .iceTrickle(newValue)}
  }

  /// ChangePublishQuality advises the publisher to switch on/off
  /// various qualities of their video stream based on the subscription.
  /// This is done to save the bandwidth and the CPU of the publisher.
  var changePublishQuality: Stream_Video_Sfu_Event_ChangePublishQuality {
    get {
      if case .changePublishQuality(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_ChangePublishQuality()
    }
    set {eventPayload = .changePublishQuality(newValue)}
  }

  /// ParticipantJoined notifies the client that a new participant
  /// has joined the call. This is not sent for anonymous users.
  var participantJoined: Stream_Video_Sfu_Event_ParticipantJoined {
    get {
      if case .participantJoined(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_ParticipantJoined()
    }
    set {eventPayload = .participantJoined(newValue)}
  }

  /// ParticipantLeft notifies the client that a call participant
  /// has left the call. This is not sent for anonymous users.
  var participantLeft: Stream_Video_Sfu_Event_ParticipantLeft {
    get {
      if case .participantLeft(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_ParticipantLeft()
    }
    set {eventPayload = .participantLeft(newValue)}
  }

  /// DominantSpeakerChanged notifies the client about the current
  /// dominant speaker. This is required for certain use cases like
  /// the spotlight view.
  var dominantSpeakerChanged: Stream_Video_Sfu_Event_DominantSpeakerChanged {
    get {
      if case .dominantSpeakerChanged(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_DominantSpeakerChanged()
    }
    set {eventPayload = .dominantSpeakerChanged(newValue)}
  }

  /// JoinResponse acknowledges a participant successfully joining
  /// the call. This is sent in response to the JoinRequest.
  var joinResponse: Stream_Video_Sfu_Event_JoinResponse {
    get {
      if case .joinResponse(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_JoinResponse()
    }
    set {eventPayload = .joinResponse(newValue)}
  }

  /// HealthCheckResponse is sent in response to the HealthCheckRequest.
  /// It contains the participant count in the call.
  var healthCheckResponse: Stream_Video_Sfu_Event_HealthCheckResponse {
    get {
      if case .healthCheckResponse(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_HealthCheckResponse()
    }
    set {eventPayload = .healthCheckResponse(newValue)}
  }

  /// TrackPublished is sent when a new track (like audio, video, screenshare)
  /// is published by a participant in the call. It is also sent on mute/unmute.
  var trackPublished: Stream_Video_Sfu_Event_TrackPublished {
    get {
      if case .trackPublished(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_TrackPublished()
    }
    set {eventPayload = .trackPublished(newValue)}
  }

  /// TrackUnpublished is sent when a track (like audio, video, screenshare)
  /// is no longer published. It is sent on muting a track or when the participant
  /// is leaving the call.
  var trackUnpublished: Stream_Video_Sfu_Event_TrackUnpublished {
    get {
      if case .trackUnpublished(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_TrackUnpublished()
    }
    set {eventPayload = .trackUnpublished(newValue)}
  }

  /// Error is used to communicate any error related to the participant. The
  /// error code and the message explain what went wrong. Whether the participant
  /// can retry is also indicated.
  var error: Stream_Video_Sfu_Event_Error {
    get {
      if case .error(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_Error()
    }
    set {eventPayload = .error(newValue)}
  }

  /// CallGrantsUpdated tells what tracks a participant is allowed to publish.
  var callGrantsUpdated: Stream_Video_Sfu_Event_CallGrantsUpdated {
    get {
      if case .callGrantsUpdated(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_CallGrantsUpdated()
    }
    set {eventPayload = .callGrantsUpdated(newValue)}
  }

  /// GoAway tells the client to migrate away from the SFU it is connected to.
  /// The reason field indicates why this message was sent.
  var goAway: Stream_Video_Sfu_Event_GoAway {
    get {
      if case .goAway(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_GoAway()
    }
    set {eventPayload = .goAway(newValue)}
  }

  /// ICERestart tells the client to perform ICE restart.
  var iceRestart: Stream_Video_Sfu_Event_ICERestart {
    get {
      if case .iceRestart(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_ICERestart()
    }
    set {eventPayload = .iceRestart(newValue)}
  }

  /// PinsChanged is sent the list of pins in the call changes. This event contains the entire list of pins.
  var pinsUpdated: Stream_Video_Sfu_Event_PinsChanged {
    get {
      if case .pinsUpdated(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_PinsChanged()
    }
    set {eventPayload = .pinsUpdated(newValue)}
  }

  /// CallEnded is sent by the SFU to the client to signal that the call has ended.
  /// The reason may specify why the call has ended.
  var callEnded: Stream_Video_Sfu_Event_CallEnded {
    get {
      if case .callEnded(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_CallEnded()
    }
    set {eventPayload = .callEnded(newValue)}
  }

  /// ParticipantUpdated is sent when user data is updated
  var participantUpdated: Stream_Video_Sfu_Event_ParticipantUpdated {
    get {
      if case .participantUpdated(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_ParticipantUpdated()
    }
    set {eventPayload = .participantUpdated(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_EventPayload: Equatable {
    /// SubscriberOffer sends the SDP offer for establishing the
    /// subscriber PeerConnection.
    case subscriberOffer(Stream_Video_Sfu_Event_SubscriberOffer)
    /// PublisherAnswer sends the SDP answer to the offer sent by
    /// the client for establishing the Publisher PeerConnection.
    case publisherAnswer(Stream_Video_Sfu_Event_PublisherAnswer)
    /// ConnectionQualityChanged is sent to inform the connection
    /// quality of the participants in the call. It does not have
    /// to contain the full list of call participants in it.
    case connectionQualityChanged(Stream_Video_Sfu_Event_ConnectionQualityChanged)
    /// AudioLevelChanged is sent for change in audio levels of
    /// the participants.
    case audioLevelChanged(Stream_Video_Sfu_Event_AudioLevelChanged)
    /// ICETrickle contains the ICE candidate required to establish
    /// the ICE transport: part of establishing the PeerConnection
    /// and also for ICE restarts.
    case iceTrickle(Stream_Video_Sfu_Models_ICETrickle)
    /// ChangePublishQuality advises the publisher to switch on/off
    /// various qualities of their video stream based on the subscription.
    /// This is done to save the bandwidth and the CPU of the publisher.
    case changePublishQuality(Stream_Video_Sfu_Event_ChangePublishQuality)
    /// ParticipantJoined notifies the client that a new participant
    /// has joined the call. This is not sent for anonymous users.
    case participantJoined(Stream_Video_Sfu_Event_ParticipantJoined)
    /// ParticipantLeft notifies the client that a call participant
    /// has left the call. This is not sent for anonymous users.
    case participantLeft(Stream_Video_Sfu_Event_ParticipantLeft)
    /// DominantSpeakerChanged notifies the client about the current
    /// dominant speaker. This is required for certain use cases like
    /// the spotlight view.
    case dominantSpeakerChanged(Stream_Video_Sfu_Event_DominantSpeakerChanged)
    /// JoinResponse acknowledges a participant successfully joining
    /// the call. This is sent in response to the JoinRequest.
    case joinResponse(Stream_Video_Sfu_Event_JoinResponse)
    /// HealthCheckResponse is sent in response to the HealthCheckRequest.
    /// It contains the participant count in the call.
    case healthCheckResponse(Stream_Video_Sfu_Event_HealthCheckResponse)
    /// TrackPublished is sent when a new track (like audio, video, screenshare)
    /// is published by a participant in the call. It is also sent on mute/unmute.
    case trackPublished(Stream_Video_Sfu_Event_TrackPublished)
    /// TrackUnpublished is sent when a track (like audio, video, screenshare)
    /// is no longer published. It is sent on muting a track or when the participant
    /// is leaving the call.
    case trackUnpublished(Stream_Video_Sfu_Event_TrackUnpublished)
    /// Error is used to communicate any error related to the participant. The
    /// error code and the message explain what went wrong. Whether the participant
    /// can retry is also indicated.
    case error(Stream_Video_Sfu_Event_Error)
    /// CallGrantsUpdated tells what tracks a participant is allowed to publish.
    case callGrantsUpdated(Stream_Video_Sfu_Event_CallGrantsUpdated)
    /// GoAway tells the client to migrate away from the SFU it is connected to.
    /// The reason field indicates why this message was sent.
    case goAway(Stream_Video_Sfu_Event_GoAway)
    /// ICERestart tells the client to perform ICE restart.
    case iceRestart(Stream_Video_Sfu_Event_ICERestart)
    /// PinsChanged is sent the list of pins in the call changes. This event contains the entire list of pins.
    case pinsUpdated(Stream_Video_Sfu_Event_PinsChanged)
    /// CallEnded is sent by the SFU to the client to signal that the call has ended.
    /// The reason may specify why the call has ended.
    case callEnded(Stream_Video_Sfu_Event_CallEnded)
    /// ParticipantUpdated is sent when user data is updated
    case participantUpdated(Stream_Video_Sfu_Event_ParticipantUpdated)

  #if !swift(>=4.1)
    static func ==(lhs: Stream_Video_Sfu_Event_SfuEvent.OneOf_EventPayload, rhs: Stream_Video_Sfu_Event_SfuEvent.OneOf_EventPayload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.subscriberOffer, .subscriberOffer): return {
        guard case .subscriberOffer(let l) = lhs, case .subscriberOffer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.publisherAnswer, .publisherAnswer): return {
        guard case .publisherAnswer(let l) = lhs, case .publisherAnswer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.connectionQualityChanged, .connectionQualityChanged): return {
        guard case .connectionQualityChanged(let l) = lhs, case .connectionQualityChanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audioLevelChanged, .audioLevelChanged): return {
        guard case .audioLevelChanged(let l) = lhs, case .audioLevelChanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iceTrickle, .iceTrickle): return {
        guard case .iceTrickle(let l) = lhs, case .iceTrickle(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.changePublishQuality, .changePublishQuality): return {
        guard case .changePublishQuality(let l) = lhs, case .changePublishQuality(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.participantJoined, .participantJoined): return {
        guard case .participantJoined(let l) = lhs, case .participantJoined(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.participantLeft, .participantLeft): return {
        guard case .participantLeft(let l) = lhs, case .participantLeft(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dominantSpeakerChanged, .dominantSpeakerChanged): return {
        guard case .dominantSpeakerChanged(let l) = lhs, case .dominantSpeakerChanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.joinResponse, .joinResponse): return {
        guard case .joinResponse(let l) = lhs, case .joinResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.healthCheckResponse, .healthCheckResponse): return {
        guard case .healthCheckResponse(let l) = lhs, case .healthCheckResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trackPublished, .trackPublished): return {
        guard case .trackPublished(let l) = lhs, case .trackPublished(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trackUnpublished, .trackUnpublished): return {
        guard case .trackUnpublished(let l) = lhs, case .trackUnpublished(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callGrantsUpdated, .callGrantsUpdated): return {
        guard case .callGrantsUpdated(let l) = lhs, case .callGrantsUpdated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.goAway, .goAway): return {
        guard case .goAway(let l) = lhs, case .goAway(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iceRestart, .iceRestart): return {
        guard case .iceRestart(let l) = lhs, case .iceRestart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pinsUpdated, .pinsUpdated): return {
        guard case .pinsUpdated(let l) = lhs, case .pinsUpdated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callEnded, .callEnded): return {
        guard case .callEnded(let l) = lhs, case .callEnded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.participantUpdated, .participantUpdated): return {
        guard case .participantUpdated(let l) = lhs, case .participantUpdated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Stream_Video_Sfu_Event_PinsChanged {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the list of pins in the call.
  /// Pins are ordered in descending order (most important first).
  var pins: [Stream_Video_Sfu_Models_Pin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Stream_Video_Sfu_Models_Error {
    get {return _error ?? Stream_Video_Sfu_Models_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  /// returns the reconnect strategy to be used by the client
  var reconnectStrategy: Stream_Video_Sfu_Models_WebsocketReconnectStrategy = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Stream_Video_Sfu_Models_Error? = nil
}

struct Stream_Video_Sfu_Event_ICETrickle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peerType: Stream_Video_Sfu_Models_PeerType = .publisherUnspecified

  var iceCandidate: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_ICERestart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peerType: Stream_Video_Sfu_Models_PeerType = .publisherUnspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SfuRequest is a message that is sent from the client to the SFU.
struct Stream_Video_Sfu_Event_SfuRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestPayload: Stream_Video_Sfu_Event_SfuRequest.OneOf_RequestPayload? = nil

  var joinRequest: Stream_Video_Sfu_Event_JoinRequest {
    get {
      if case .joinRequest(let v)? = requestPayload {return v}
      return Stream_Video_Sfu_Event_JoinRequest()
    }
    set {requestPayload = .joinRequest(newValue)}
  }

  var healthCheckRequest: Stream_Video_Sfu_Event_HealthCheckRequest {
    get {
      if case .healthCheckRequest(let v)? = requestPayload {return v}
      return Stream_Video_Sfu_Event_HealthCheckRequest()
    }
    set {requestPayload = .healthCheckRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_RequestPayload: Equatable {
    case joinRequest(Stream_Video_Sfu_Event_JoinRequest)
    case healthCheckRequest(Stream_Video_Sfu_Event_HealthCheckRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Stream_Video_Sfu_Event_SfuRequest.OneOf_RequestPayload, rhs: Stream_Video_Sfu_Event_SfuRequest.OneOf_RequestPayload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.joinRequest, .joinRequest): return {
        guard case .joinRequest(let l) = lhs, case .joinRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.healthCheckRequest, .healthCheckRequest): return {
        guard case .healthCheckRequest(let l) = lhs, case .healthCheckRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Stream_Video_Sfu_Event_HealthCheckRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_HealthCheckResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var participantCount: Stream_Video_Sfu_Models_ParticipantCount {
    get {return _participantCount ?? Stream_Video_Sfu_Models_ParticipantCount()}
    set {_participantCount = newValue}
  }
  /// Returns true if `participantCount` has been explicitly set.
  var hasParticipantCount: Bool {return self._participantCount != nil}
  /// Clears the value of `participantCount`. Subsequent reads from it will return its default value.
  mutating func clearParticipantCount() {self._participantCount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _participantCount: Stream_Video_Sfu_Models_ParticipantCount? = nil
}

struct Stream_Video_Sfu_Event_TrackPublished {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  var sessionID: String {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  var type: Stream_Video_Sfu_Models_TrackType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// Participant information here is included as an optimisation
  /// for large calls where broadcasting on every participant join
  /// is expensive. You should **NOT** assume that this will always
  /// be available though you can use it to update the participant
  /// list when it is there.
  var participant: Stream_Video_Sfu_Models_Participant {
    get {return _storage._participant ?? Stream_Video_Sfu_Models_Participant()}
    set {_uniqueStorage()._participant = newValue}
  }
  /// Returns true if `participant` has been explicitly set.
  var hasParticipant: Bool {return _storage._participant != nil}
  /// Clears the value of `participant`. Subsequent reads from it will return its default value.
  mutating func clearParticipant() {_uniqueStorage()._participant = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Stream_Video_Sfu_Event_TrackUnpublished {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  var sessionID: String {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  var type: Stream_Video_Sfu_Models_TrackType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var cause: Stream_Video_Sfu_Models_TrackUnpublishReason {
    get {return _storage._cause}
    set {_uniqueStorage()._cause = newValue}
  }

  /// Participant information here is included as an optimisation
  /// for large calls where broadcasting on every participant join
  /// is expensive. You should **NOT** assume that this will always
  /// be available though you can use it to update the participant
  /// list when it is there.
  var participant: Stream_Video_Sfu_Models_Participant {
    get {return _storage._participant ?? Stream_Video_Sfu_Models_Participant()}
    set {_uniqueStorage()._participant = newValue}
  }
  /// Returns true if `participant` has been explicitly set.
  var hasParticipant: Bool {return _storage._participant != nil}
  /// Clears the value of `participant`. Subsequent reads from it will return its default value.
  mutating func clearParticipant() {_uniqueStorage()._participant = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Stream_Video_Sfu_Event_JoinRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  var sessionID: String {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  /// dumb SDP that allow us to extract subscriber's decode codecs
  var subscriberSdp: String {
    get {return _storage._subscriberSdp}
    set {_uniqueStorage()._subscriberSdp = newValue}
  }

  var clientDetails: Stream_Video_Sfu_Models_ClientDetails {
    get {return _storage._clientDetails ?? Stream_Video_Sfu_Models_ClientDetails()}
    set {_uniqueStorage()._clientDetails = newValue}
  }
  /// Returns true if `clientDetails` has been explicitly set.
  var hasClientDetails: Bool {return _storage._clientDetails != nil}
  /// Clears the value of `clientDetails`. Subsequent reads from it will return its default value.
  mutating func clearClientDetails() {_uniqueStorage()._clientDetails = nil}

  /// TODO: we should know if this is going to be
  /// - publishing and subscribing, or just subscribing for future routing
  var migration: Stream_Video_Sfu_Event_Migration {
    get {return _storage._migration ?? Stream_Video_Sfu_Event_Migration()}
    set {_uniqueStorage()._migration = newValue}
  }
  /// Returns true if `migration` has been explicitly set.
  var hasMigration: Bool {return _storage._migration != nil}
  /// Clears the value of `migration`. Subsequent reads from it will return its default value.
  mutating func clearMigration() {_uniqueStorage()._migration = nil}

  /// Fast reconnect flag explicitly indicates that if the participant session
  /// and the associated state is still present in the SFU, the client is ready
  /// to restore the PeerConnection with an ICE restart. If the SFU replies with
  /// "reconnected: true" in its JoinResponse, then it is safe to perform an ICE
  /// restart or else the existing PeerConnections must be cleaned up.
  ///
  /// For the SFU, fast_reconnect:false indicates that even if it has the state
  /// cached, the client state is not in sync and hence it must be cleaned up before
  /// proceeding further.
  var fastReconnect: Bool {
    get {return _storage._fastReconnect}
    set {_uniqueStorage()._fastReconnect = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Stream_Video_Sfu_Event_Migration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fromSfuID: String = String()

  var announcedTracks: [Stream_Video_Sfu_Models_TrackInfo] = []

  var subscriptions: [Stream_Video_Sfu_Signal_TrackSubscriptionDetails] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_JoinResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var callState: Stream_Video_Sfu_Models_CallState {
    get {return _callState ?? Stream_Video_Sfu_Models_CallState()}
    set {_callState = newValue}
  }
  /// Returns true if `callState` has been explicitly set.
  var hasCallState: Bool {return self._callState != nil}
  /// Clears the value of `callState`. Subsequent reads from it will return its default value.
  mutating func clearCallState() {self._callState = nil}

  var reconnected: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _callState: Stream_Video_Sfu_Models_CallState? = nil
}

/// ParticipantJoined is fired when a user joins a call
struct Stream_Video_Sfu_Event_ParticipantJoined {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var callCid: String = String()

  var participant: Stream_Video_Sfu_Models_Participant {
    get {return _participant ?? Stream_Video_Sfu_Models_Participant()}
    set {_participant = newValue}
  }
  /// Returns true if `participant` has been explicitly set.
  var hasParticipant: Bool {return self._participant != nil}
  /// Clears the value of `participant`. Subsequent reads from it will return its default value.
  mutating func clearParticipant() {self._participant = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _participant: Stream_Video_Sfu_Models_Participant? = nil
}

/// ParticipantJoined is fired when a user leaves a call
struct Stream_Video_Sfu_Event_ParticipantLeft {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var callCid: String = String()

  var participant: Stream_Video_Sfu_Models_Participant {
    get {return _participant ?? Stream_Video_Sfu_Models_Participant()}
    set {_participant = newValue}
  }
  /// Returns true if `participant` has been explicitly set.
  var hasParticipant: Bool {return self._participant != nil}
  /// Clears the value of `participant`. Subsequent reads from it will return its default value.
  mutating func clearParticipant() {self._participant = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _participant: Stream_Video_Sfu_Models_Participant? = nil
}

/// ParticipantUpdated is fired when user data is updated
struct Stream_Video_Sfu_Event_ParticipantUpdated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var callCid: String = String()

  var participant: Stream_Video_Sfu_Models_Participant {
    get {return _participant ?? Stream_Video_Sfu_Models_Participant()}
    set {_participant = newValue}
  }
  /// Returns true if `participant` has been explicitly set.
  var hasParticipant: Bool {return self._participant != nil}
  /// Clears the value of `participant`. Subsequent reads from it will return its default value.
  mutating func clearParticipant() {self._participant = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _participant: Stream_Video_Sfu_Models_Participant? = nil
}

/// SubscriberOffer is sent when the SFU adds tracks to a subscription
struct Stream_Video_Sfu_Event_SubscriberOffer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var iceRestart: Bool = false

  var sdp: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_PublisherAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sdp: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ConnectionQuality is sent to inform about connection quality changes
/// eg. thierry's connection is not good -> render a red icon Zoom style
struct Stream_Video_Sfu_Event_ConnectionQualityChanged {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectionQualityUpdates: [Stream_Video_Sfu_Event_ConnectionQualityInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_ConnectionQualityInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var sessionID: String = String()

  var connectionQuality: Stream_Video_Sfu_Models_ConnectionQuality = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DominantSpeakerChanged is sent by the SFU to notify when there is a new dominant speaker in the call
struct Stream_Video_Sfu_Event_DominantSpeakerChanged {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_AudioLevel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var sessionID: String = String()

  /// 0.0 means complete silence, 1.0 loudest
  var level: Float = 0

  var isSpeaking: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AudioLevelChanged is sent by the SFU to notify about audio levels by user
struct Stream_Video_Sfu_Event_AudioLevelChanged {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var audioLevels: [Stream_Video_Sfu_Event_AudioLevel] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_AudioMediaRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelCount: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_AudioSender {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mediaRequest: Stream_Video_Sfu_Event_AudioMediaRequest {
    get {return _mediaRequest ?? Stream_Video_Sfu_Event_AudioMediaRequest()}
    set {_mediaRequest = newValue}
  }
  /// Returns true if `mediaRequest` has been explicitly set.
  var hasMediaRequest: Bool {return self._mediaRequest != nil}
  /// Clears the value of `mediaRequest`. Subsequent reads from it will return its default value.
  mutating func clearMediaRequest() {self._mediaRequest = nil}

  var codec: Stream_Video_Sfu_Models_Codec {
    get {return _codec ?? Stream_Video_Sfu_Models_Codec()}
    set {_codec = newValue}
  }
  /// Returns true if `codec` has been explicitly set.
  var hasCodec: Bool {return self._codec != nil}
  /// Clears the value of `codec`. Subsequent reads from it will return its default value.
  mutating func clearCodec() {self._codec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mediaRequest: Stream_Video_Sfu_Event_AudioMediaRequest? = nil
  fileprivate var _codec: Stream_Video_Sfu_Models_Codec? = nil
}

struct Stream_Video_Sfu_Event_VideoMediaRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var idealHeight: Int32 = 0

  var idealWidth: Int32 = 0

  var idealFrameRate: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// VideoLayerSetting is used to specify various parameters of a particular encoding in simulcast.
/// The parameters are specified here - https://developer.mozilla.org/en-US/docs/Web/API/RTCRtpEncodingParameters
/// SDKs use these parameters sent from the server to dynamically adjust these parameters to save CPU, bandwidth
struct Stream_Video_Sfu_Event_VideoLayerSetting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var active: Bool = false

  var maxBitrate: Int32 = 0

  var scaleResolutionDownBy: Float = 0

  var priority: Stream_Video_Sfu_Event_VideoLayerSetting.Priority = .highUnspecified

  var codec: Stream_Video_Sfu_Models_Codec {
    get {return _codec ?? Stream_Video_Sfu_Models_Codec()}
    set {_codec = newValue}
  }
  /// Returns true if `codec` has been explicitly set.
  var hasCodec: Bool {return self._codec != nil}
  /// Clears the value of `codec`. Subsequent reads from it will return its default value.
  mutating func clearCodec() {self._codec = nil}

  var maxFramerate: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Priority: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case highUnspecified // = 0
    case low // = 1
    case medium // = 2
    case veryLow // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .highUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .highUnspecified
      case 1: self = .low
      case 2: self = .medium
      case 3: self = .veryLow
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .highUnspecified: return 0
      case .low: return 1
      case .medium: return 2
      case .veryLow: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _codec: Stream_Video_Sfu_Models_Codec? = nil
}

#if swift(>=4.2)

extension Stream_Video_Sfu_Event_VideoLayerSetting.Priority: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Sfu_Event_VideoLayerSetting.Priority] = [
    .highUnspecified,
    .low,
    .medium,
    .veryLow,
  ]
}

#endif  // swift(>=4.2)

struct Stream_Video_Sfu_Event_VideoSender {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mediaRequest: Stream_Video_Sfu_Event_VideoMediaRequest {
    get {return _mediaRequest ?? Stream_Video_Sfu_Event_VideoMediaRequest()}
    set {_mediaRequest = newValue}
  }
  /// Returns true if `mediaRequest` has been explicitly set.
  var hasMediaRequest: Bool {return self._mediaRequest != nil}
  /// Clears the value of `mediaRequest`. Subsequent reads from it will return its default value.
  mutating func clearMediaRequest() {self._mediaRequest = nil}

  var codec: Stream_Video_Sfu_Models_Codec {
    get {return _codec ?? Stream_Video_Sfu_Models_Codec()}
    set {_codec = newValue}
  }
  /// Returns true if `codec` has been explicitly set.
  var hasCodec: Bool {return self._codec != nil}
  /// Clears the value of `codec`. Subsequent reads from it will return its default value.
  mutating func clearCodec() {self._codec = nil}

  var layers: [Stream_Video_Sfu_Event_VideoLayerSetting] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mediaRequest: Stream_Video_Sfu_Event_VideoMediaRequest? = nil
  fileprivate var _codec: Stream_Video_Sfu_Models_Codec? = nil
}

/// sent to users when they need to change the quality of their video
struct Stream_Video_Sfu_Event_ChangePublishQuality {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var audioSenders: [Stream_Video_Sfu_Event_AudioSender] = []

  var videoSenders: [Stream_Video_Sfu_Event_VideoSender] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CallGrants is sent to users when there is a change in the call permissions
/// to publish audio, video or share the screen for a user or a role. This is
/// idempotent and can be sent at any time. Only the current_grants in the latest
/// message should be considered. In other words, this is not dependent on any
/// other message (including previous call_grants_updated message)
///
/// When this message is received, the client (say, React component) should mute
/// the tracks which are not allowed anymore. For example, if the message has
/// grants {audio:true, video:false} while the user is publishing video, then the
/// client component should mute the video track and gray out the video button.
/// This way, the user will not be able to publish video until the permissions
/// are granted again. Also, muting the track on the client side will prevent
/// the SFU from receiving the video track and will save bandwidth.
///
/// In simple words, this is exactly the same as muting a track on the client.
/// Here, instead of the user instructing the client, SFU would be doing it.
struct Stream_Video_Sfu_Event_CallGrantsUpdated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currentGrants: Stream_Video_Sfu_Models_CallGrants {
    get {return _currentGrants ?? Stream_Video_Sfu_Models_CallGrants()}
    set {_currentGrants = newValue}
  }
  /// Returns true if `currentGrants` has been explicitly set.
  var hasCurrentGrants: Bool {return self._currentGrants != nil}
  /// Clears the value of `currentGrants`. Subsequent reads from it will return its default value.
  mutating func clearCurrentGrants() {self._currentGrants = nil}

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _currentGrants: Stream_Video_Sfu_Models_CallGrants? = nil
}

/// Go away is sent by the SFU to the client to signal to migrate away from the SFU.
/// The evict reason may specify why the user is being evicted.
struct Stream_Video_Sfu_Event_GoAway {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: Stream_Video_Sfu_Models_GoAwayReason = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CallEnded is sent by the SFU to the client to signal that the call has ended.
/// The reason may specify why the call has ended.
struct Stream_Video_Sfu_Event_CallEnded {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: Stream_Video_Sfu_Models_CallEndedReason = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stream_Video_Sfu_Event_SfuEvent: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_SfuEvent.OneOf_EventPayload: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_PinsChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_Error: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ICETrickle: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ICERestart: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_SfuRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_SfuRequest.OneOf_RequestPayload: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_HealthCheckRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_HealthCheckResponse: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_TrackPublished: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_TrackUnpublished: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_JoinRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_Migration: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_JoinResponse: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ParticipantJoined: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ParticipantLeft: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ParticipantUpdated: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_SubscriberOffer: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_PublisherAnswer: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ConnectionQualityChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ConnectionQualityInfo: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_DominantSpeakerChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioLevel: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioLevelChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioMediaRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioSender: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoMediaRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoLayerSetting: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoLayerSetting.Priority: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoSender: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ChangePublishQuality: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_CallGrantsUpdated: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_GoAway: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_CallEnded: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stream.video.sfu.event"

extension Stream_Video_Sfu_Event_SfuEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SfuEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscriber_offer"),
    2: .standard(proto: "publisher_answer"),
    3: .standard(proto: "connection_quality_changed"),
    4: .standard(proto: "audio_level_changed"),
    5: .standard(proto: "ice_trickle"),
    6: .standard(proto: "change_publish_quality"),
    10: .standard(proto: "participant_joined"),
    11: .standard(proto: "participant_left"),
    12: .standard(proto: "dominant_speaker_changed"),
    13: .standard(proto: "join_response"),
    14: .standard(proto: "health_check_response"),
    16: .standard(proto: "track_published"),
    17: .standard(proto: "track_unpublished"),
    18: .same(proto: "error"),
    19: .standard(proto: "call_grants_updated"),
    20: .standard(proto: "go_away"),
    21: .standard(proto: "ice_restart"),
    22: .standard(proto: "pins_updated"),
    23: .standard(proto: "call_ended"),
    24: .standard(proto: "participant_updated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Stream_Video_Sfu_Event_SubscriberOffer?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .subscriberOffer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .subscriberOffer(v)
        }
      }()
      case 2: try {
        var v: Stream_Video_Sfu_Event_PublisherAnswer?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .publisherAnswer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .publisherAnswer(v)
        }
      }()
      case 3: try {
        var v: Stream_Video_Sfu_Event_ConnectionQualityChanged?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .connectionQualityChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .connectionQualityChanged(v)
        }
      }()
      case 4: try {
        var v: Stream_Video_Sfu_Event_AudioLevelChanged?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .audioLevelChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .audioLevelChanged(v)
        }
      }()
      case 5: try {
        var v: Stream_Video_Sfu_Models_ICETrickle?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .iceTrickle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .iceTrickle(v)
        }
      }()
      case 6: try {
        var v: Stream_Video_Sfu_Event_ChangePublishQuality?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .changePublishQuality(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .changePublishQuality(v)
        }
      }()
      case 10: try {
        var v: Stream_Video_Sfu_Event_ParticipantJoined?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .participantJoined(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .participantJoined(v)
        }
      }()
      case 11: try {
        var v: Stream_Video_Sfu_Event_ParticipantLeft?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .participantLeft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .participantLeft(v)
        }
      }()
      case 12: try {
        var v: Stream_Video_Sfu_Event_DominantSpeakerChanged?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .dominantSpeakerChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .dominantSpeakerChanged(v)
        }
      }()
      case 13: try {
        var v: Stream_Video_Sfu_Event_JoinResponse?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .joinResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .joinResponse(v)
        }
      }()
      case 14: try {
        var v: Stream_Video_Sfu_Event_HealthCheckResponse?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .healthCheckResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .healthCheckResponse(v)
        }
      }()
      case 16: try {
        var v: Stream_Video_Sfu_Event_TrackPublished?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .trackPublished(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .trackPublished(v)
        }
      }()
      case 17: try {
        var v: Stream_Video_Sfu_Event_TrackUnpublished?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .trackUnpublished(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .trackUnpublished(v)
        }
      }()
      case 18: try {
        var v: Stream_Video_Sfu_Event_Error?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .error(v)
        }
      }()
      case 19: try {
        var v: Stream_Video_Sfu_Event_CallGrantsUpdated?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .callGrantsUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .callGrantsUpdated(v)
        }
      }()
      case 20: try {
        var v: Stream_Video_Sfu_Event_GoAway?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .goAway(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .goAway(v)
        }
      }()
      case 21: try {
        var v: Stream_Video_Sfu_Event_ICERestart?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .iceRestart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .iceRestart(v)
        }
      }()
      case 22: try {
        var v: Stream_Video_Sfu_Event_PinsChanged?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .pinsUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .pinsUpdated(v)
        }
      }()
      case 23: try {
        var v: Stream_Video_Sfu_Event_CallEnded?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .callEnded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .callEnded(v)
        }
      }()
      case 24: try {
        var v: Stream_Video_Sfu_Event_ParticipantUpdated?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .participantUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .participantUpdated(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.eventPayload {
    case .subscriberOffer?: try {
      guard case .subscriberOffer(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .publisherAnswer?: try {
      guard case .publisherAnswer(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .connectionQualityChanged?: try {
      guard case .connectionQualityChanged(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .audioLevelChanged?: try {
      guard case .audioLevelChanged(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .iceTrickle?: try {
      guard case .iceTrickle(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .changePublishQuality?: try {
      guard case .changePublishQuality(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .participantJoined?: try {
      guard case .participantJoined(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .participantLeft?: try {
      guard case .participantLeft(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .dominantSpeakerChanged?: try {
      guard case .dominantSpeakerChanged(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .joinResponse?: try {
      guard case .joinResponse(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .healthCheckResponse?: try {
      guard case .healthCheckResponse(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .trackPublished?: try {
      guard case .trackPublished(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .trackUnpublished?: try {
      guard case .trackUnpublished(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .error?: try {
      guard case .error(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .callGrantsUpdated?: try {
      guard case .callGrantsUpdated(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .goAway?: try {
      guard case .goAway(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .iceRestart?: try {
      guard case .iceRestart(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .pinsUpdated?: try {
      guard case .pinsUpdated(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .callEnded?: try {
      guard case .callEnded(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .participantUpdated?: try {
      guard case .participantUpdated(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_SfuEvent, rhs: Stream_Video_Sfu_Event_SfuEvent) -> Bool {
    if lhs.eventPayload != rhs.eventPayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_PinsChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PinsChanged"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pins"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pins) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pins, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_PinsChanged, rhs: Stream_Video_Sfu_Event_PinsChanged) -> Bool {
    if lhs.pins != rhs.pins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "error"),
    5: .standard(proto: "reconnect_strategy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.reconnectStrategy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.reconnectStrategy != .unspecified {
      try visitor.visitSingularEnumField(value: self.reconnectStrategy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_Error, rhs: Stream_Video_Sfu_Event_Error) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.reconnectStrategy != rhs.reconnectStrategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_ICETrickle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ICETrickle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_type"),
    2: .standard(proto: "ice_candidate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.peerType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.iceCandidate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.peerType != .publisherUnspecified {
      try visitor.visitSingularEnumField(value: self.peerType, fieldNumber: 1)
    }
    if !self.iceCandidate.isEmpty {
      try visitor.visitSingularStringField(value: self.iceCandidate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_ICETrickle, rhs: Stream_Video_Sfu_Event_ICETrickle) -> Bool {
    if lhs.peerType != rhs.peerType {return false}
    if lhs.iceCandidate != rhs.iceCandidate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_ICERestart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ICERestart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.peerType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.peerType != .publisherUnspecified {
      try visitor.visitSingularEnumField(value: self.peerType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_ICERestart, rhs: Stream_Video_Sfu_Event_ICERestart) -> Bool {
    if lhs.peerType != rhs.peerType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_SfuRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SfuRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "join_request"),
    2: .standard(proto: "health_check_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Stream_Video_Sfu_Event_JoinRequest?
        var hadOneofValue = false
        if let current = self.requestPayload {
          hadOneofValue = true
          if case .joinRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestPayload = .joinRequest(v)
        }
      }()
      case 2: try {
        var v: Stream_Video_Sfu_Event_HealthCheckRequest?
        var hadOneofValue = false
        if let current = self.requestPayload {
          hadOneofValue = true
          if case .healthCheckRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestPayload = .healthCheckRequest(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.requestPayload {
    case .joinRequest?: try {
      guard case .joinRequest(let v)? = self.requestPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .healthCheckRequest?: try {
      guard case .healthCheckRequest(let v)? = self.requestPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_SfuRequest, rhs: Stream_Video_Sfu_Event_SfuRequest) -> Bool {
    if lhs.requestPayload != rhs.requestPayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_HealthCheckRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HealthCheckRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_HealthCheckRequest, rhs: Stream_Video_Sfu_Event_HealthCheckRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_HealthCheckResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HealthCheckResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "participant_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._participantCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._participantCount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_HealthCheckResponse, rhs: Stream_Video_Sfu_Event_HealthCheckResponse) -> Bool {
    if lhs._participantCount != rhs._participantCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_TrackPublished: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackPublished"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "session_id"),
    3: .same(proto: "type"),
    4: .same(proto: "participant"),
  ]

  fileprivate class _StorageClass {
    var _userID: String = String()
    var _sessionID: String = String()
    var _type: Stream_Video_Sfu_Models_TrackType = .unspecified
    var _participant: Stream_Video_Sfu_Models_Participant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _userID = source._userID
      _sessionID = source._sessionID
      _type = source._type
      _participant = source._participant
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._participant) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 1)
      }
      if !_storage._sessionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionID, fieldNumber: 2)
      }
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 3)
      }
      try { if let v = _storage._participant {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_TrackPublished, rhs: Stream_Video_Sfu_Event_TrackPublished) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._participant != rhs_storage._participant {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_TrackUnpublished: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackUnpublished"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "session_id"),
    3: .same(proto: "type"),
    4: .same(proto: "cause"),
    5: .same(proto: "participant"),
  ]

  fileprivate class _StorageClass {
    var _userID: String = String()
    var _sessionID: String = String()
    var _type: Stream_Video_Sfu_Models_TrackType = .unspecified
    var _cause: Stream_Video_Sfu_Models_TrackUnpublishReason = .unspecified
    var _participant: Stream_Video_Sfu_Models_Participant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _userID = source._userID
      _sessionID = source._sessionID
      _type = source._type
      _cause = source._cause
      _participant = source._participant
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._cause) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._participant) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 1)
      }
      if !_storage._sessionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionID, fieldNumber: 2)
      }
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 3)
      }
      if _storage._cause != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._cause, fieldNumber: 4)
      }
      try { if let v = _storage._participant {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_TrackUnpublished, rhs: Stream_Video_Sfu_Event_TrackUnpublished) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._cause != rhs_storage._cause {return false}
        if _storage._participant != rhs_storage._participant {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_JoinRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JoinRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .standard(proto: "session_id"),
    3: .standard(proto: "subscriber_sdp"),
    4: .standard(proto: "client_details"),
    5: .same(proto: "migration"),
    6: .standard(proto: "fast_reconnect"),
  ]

  fileprivate class _StorageClass {
    var _token: String = String()
    var _sessionID: String = String()
    var _subscriberSdp: String = String()
    var _clientDetails: Stream_Video_Sfu_Models_ClientDetails? = nil
    var _migration: Stream_Video_Sfu_Event_Migration? = nil
    var _fastReconnect: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _token = source._token
      _sessionID = source._sessionID
      _subscriberSdp = source._subscriberSdp
      _clientDetails = source._clientDetails
      _migration = source._migration
      _fastReconnect = source._fastReconnect
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._token) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._subscriberSdp) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._clientDetails) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._migration) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._fastReconnect) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 1)
      }
      if !_storage._sessionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionID, fieldNumber: 2)
      }
      if !_storage._subscriberSdp.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subscriberSdp, fieldNumber: 3)
      }
      try { if let v = _storage._clientDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._migration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._fastReconnect != false {
        try visitor.visitSingularBoolField(value: _storage._fastReconnect, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_JoinRequest, rhs: Stream_Video_Sfu_Event_JoinRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._token != rhs_storage._token {return false}
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._subscriberSdp != rhs_storage._subscriberSdp {return false}
        if _storage._clientDetails != rhs_storage._clientDetails {return false}
        if _storage._migration != rhs_storage._migration {return false}
        if _storage._fastReconnect != rhs_storage._fastReconnect {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_Migration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Migration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_sfu_id"),
    2: .standard(proto: "announced_tracks"),
    3: .same(proto: "subscriptions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fromSfuID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.announcedTracks) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.subscriptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fromSfuID.isEmpty {
      try visitor.visitSingularStringField(value: self.fromSfuID, fieldNumber: 1)
    }
    if !self.announcedTracks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.announcedTracks, fieldNumber: 2)
    }
    if !self.subscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subscriptions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_Migration, rhs: Stream_Video_Sfu_Event_Migration) -> Bool {
    if lhs.fromSfuID != rhs.fromSfuID {return false}
    if lhs.announcedTracks != rhs.announcedTracks {return false}
    if lhs.subscriptions != rhs.subscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_JoinResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JoinResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_state"),
    2: .same(proto: "reconnected"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._callState) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.reconnected) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._callState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.reconnected != false {
      try visitor.visitSingularBoolField(value: self.reconnected, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_JoinResponse, rhs: Stream_Video_Sfu_Event_JoinResponse) -> Bool {
    if lhs._callState != rhs._callState {return false}
    if lhs.reconnected != rhs.reconnected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_ParticipantJoined: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantJoined"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_cid"),
    2: .same(proto: "participant"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._participant) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callCid.isEmpty {
      try visitor.visitSingularStringField(value: self.callCid, fieldNumber: 1)
    }
    try { if let v = self._participant {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_ParticipantJoined, rhs: Stream_Video_Sfu_Event_ParticipantJoined) -> Bool {
    if lhs.callCid != rhs.callCid {return false}
    if lhs._participant != rhs._participant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_ParticipantLeft: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantLeft"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_cid"),
    2: .same(proto: "participant"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._participant) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callCid.isEmpty {
      try visitor.visitSingularStringField(value: self.callCid, fieldNumber: 1)
    }
    try { if let v = self._participant {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_ParticipantLeft, rhs: Stream_Video_Sfu_Event_ParticipantLeft) -> Bool {
    if lhs.callCid != rhs.callCid {return false}
    if lhs._participant != rhs._participant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_ParticipantUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_cid"),
    2: .same(proto: "participant"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._participant) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callCid.isEmpty {
      try visitor.visitSingularStringField(value: self.callCid, fieldNumber: 1)
    }
    try { if let v = self._participant {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_ParticipantUpdated, rhs: Stream_Video_Sfu_Event_ParticipantUpdated) -> Bool {
    if lhs.callCid != rhs.callCid {return false}
    if lhs._participant != rhs._participant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_SubscriberOffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscriberOffer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ice_restart"),
    2: .same(proto: "sdp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.iceRestart) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sdp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.iceRestart != false {
      try visitor.visitSingularBoolField(value: self.iceRestart, fieldNumber: 1)
    }
    if !self.sdp.isEmpty {
      try visitor.visitSingularStringField(value: self.sdp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_SubscriberOffer, rhs: Stream_Video_Sfu_Event_SubscriberOffer) -> Bool {
    if lhs.iceRestart != rhs.iceRestart {return false}
    if lhs.sdp != rhs.sdp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_PublisherAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublisherAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sdp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sdp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sdp.isEmpty {
      try visitor.visitSingularStringField(value: self.sdp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_PublisherAnswer, rhs: Stream_Video_Sfu_Event_PublisherAnswer) -> Bool {
    if lhs.sdp != rhs.sdp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_ConnectionQualityChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionQualityChanged"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "connection_quality_updates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.connectionQualityUpdates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectionQualityUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.connectionQualityUpdates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_ConnectionQualityChanged, rhs: Stream_Video_Sfu_Event_ConnectionQualityChanged) -> Bool {
    if lhs.connectionQualityUpdates != rhs.connectionQualityUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_ConnectionQualityInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionQualityInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "session_id"),
    3: .standard(proto: "connection_quality"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.connectionQuality) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    if self.connectionQuality != .unspecified {
      try visitor.visitSingularEnumField(value: self.connectionQuality, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_ConnectionQualityInfo, rhs: Stream_Video_Sfu_Event_ConnectionQualityInfo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.connectionQuality != rhs.connectionQuality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_DominantSpeakerChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DominantSpeakerChanged"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "session_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_DominantSpeakerChanged, rhs: Stream_Video_Sfu_Event_DominantSpeakerChanged) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_AudioLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AudioLevel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "session_id"),
    3: .same(proto: "level"),
    4: .standard(proto: "is_speaking"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.level) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isSpeaking) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    if self.level != 0 {
      try visitor.visitSingularFloatField(value: self.level, fieldNumber: 3)
    }
    if self.isSpeaking != false {
      try visitor.visitSingularBoolField(value: self.isSpeaking, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_AudioLevel, rhs: Stream_Video_Sfu_Event_AudioLevel) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.level != rhs.level {return false}
    if lhs.isSpeaking != rhs.isSpeaking {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_AudioLevelChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AudioLevelChanged"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_levels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.audioLevels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.audioLevels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.audioLevels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_AudioLevelChanged, rhs: Stream_Video_Sfu_Event_AudioLevelChanged) -> Bool {
    if lhs.audioLevels != rhs.audioLevels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_AudioMediaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AudioMediaRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.channelCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelCount != 0 {
      try visitor.visitSingularInt32Field(value: self.channelCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_AudioMediaRequest, rhs: Stream_Video_Sfu_Event_AudioMediaRequest) -> Bool {
    if lhs.channelCount != rhs.channelCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_AudioSender: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AudioSender"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "media_request"),
    2: .same(proto: "codec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mediaRequest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._codec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mediaRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._codec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_AudioSender, rhs: Stream_Video_Sfu_Event_AudioSender) -> Bool {
    if lhs._mediaRequest != rhs._mediaRequest {return false}
    if lhs._codec != rhs._codec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_VideoMediaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoMediaRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ideal_height"),
    2: .standard(proto: "ideal_width"),
    3: .standard(proto: "ideal_frame_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.idealHeight) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.idealWidth) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.idealFrameRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.idealHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.idealHeight, fieldNumber: 1)
    }
    if self.idealWidth != 0 {
      try visitor.visitSingularInt32Field(value: self.idealWidth, fieldNumber: 2)
    }
    if self.idealFrameRate != 0 {
      try visitor.visitSingularInt32Field(value: self.idealFrameRate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_VideoMediaRequest, rhs: Stream_Video_Sfu_Event_VideoMediaRequest) -> Bool {
    if lhs.idealHeight != rhs.idealHeight {return false}
    if lhs.idealWidth != rhs.idealWidth {return false}
    if lhs.idealFrameRate != rhs.idealFrameRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_VideoLayerSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoLayerSetting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "active"),
    3: .standard(proto: "max_bitrate"),
    4: .standard(proto: "scale_resolution_down_by"),
    5: .same(proto: "priority"),
    6: .same(proto: "codec"),
    7: .standard(proto: "max_framerate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxBitrate) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.scaleResolutionDownBy) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.priority) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._codec) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.maxFramerate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 2)
    }
    if self.maxBitrate != 0 {
      try visitor.visitSingularInt32Field(value: self.maxBitrate, fieldNumber: 3)
    }
    if self.scaleResolutionDownBy != 0 {
      try visitor.visitSingularFloatField(value: self.scaleResolutionDownBy, fieldNumber: 4)
    }
    if self.priority != .highUnspecified {
      try visitor.visitSingularEnumField(value: self.priority, fieldNumber: 5)
    }
    try { if let v = self._codec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.maxFramerate != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxFramerate, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_VideoLayerSetting, rhs: Stream_Video_Sfu_Event_VideoLayerSetting) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.active != rhs.active {return false}
    if lhs.maxBitrate != rhs.maxBitrate {return false}
    if lhs.scaleResolutionDownBy != rhs.scaleResolutionDownBy {return false}
    if lhs.priority != rhs.priority {return false}
    if lhs._codec != rhs._codec {return false}
    if lhs.maxFramerate != rhs.maxFramerate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_VideoLayerSetting.Priority: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRIORITY_HIGH_UNSPECIFIED"),
    1: .same(proto: "PRIORITY_LOW"),
    2: .same(proto: "PRIORITY_MEDIUM"),
    3: .same(proto: "PRIORITY_VERY_LOW"),
  ]
}

extension Stream_Video_Sfu_Event_VideoSender: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoSender"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "media_request"),
    2: .same(proto: "codec"),
    3: .same(proto: "layers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mediaRequest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._codec) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.layers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mediaRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._codec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_VideoSender, rhs: Stream_Video_Sfu_Event_VideoSender) -> Bool {
    if lhs._mediaRequest != rhs._mediaRequest {return false}
    if lhs._codec != rhs._codec {return false}
    if lhs.layers != rhs.layers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_ChangePublishQuality: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangePublishQuality"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_senders"),
    2: .standard(proto: "video_senders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.audioSenders) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.videoSenders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.audioSenders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.audioSenders, fieldNumber: 1)
    }
    if !self.videoSenders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.videoSenders, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_ChangePublishQuality, rhs: Stream_Video_Sfu_Event_ChangePublishQuality) -> Bool {
    if lhs.audioSenders != rhs.audioSenders {return false}
    if lhs.videoSenders != rhs.videoSenders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_CallGrantsUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallGrantsUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_grants"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._currentGrants) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currentGrants {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_CallGrantsUpdated, rhs: Stream_Video_Sfu_Event_CallGrantsUpdated) -> Bool {
    if lhs._currentGrants != rhs._currentGrants {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_GoAway: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GoAway"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unspecified {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_GoAway, rhs: Stream_Video_Sfu_Event_GoAway) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_CallEnded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallEnded"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unspecified {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_CallEnded, rhs: Stream_Video_Sfu_Event_CallEnded) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
