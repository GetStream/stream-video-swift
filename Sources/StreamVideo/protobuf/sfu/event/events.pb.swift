//
// Copyright Â© 2023 Stream.io Inc. All rights reserved.
//

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// SFUEvent is a message that is sent from the SFU to the client.
struct Stream_Video_Sfu_Event_SfuEvent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var eventPayload: Stream_Video_Sfu_Event_SfuEvent.OneOf_EventPayload?

    var subscriberOffer: Stream_Video_Sfu_Event_SubscriberOffer {
        get {
            if case let .subscriberOffer(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_SubscriberOffer()
        }
        set { eventPayload = .subscriberOffer(newValue) }
    }

    var publisherAnswer: Stream_Video_Sfu_Event_PublisherAnswer {
        get {
            if case let .publisherAnswer(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_PublisherAnswer()
        }
        set { eventPayload = .publisherAnswer(newValue) }
    }

    var connectionQualityChanged: Stream_Video_Sfu_Event_ConnectionQualityChanged {
        get {
            if case let .connectionQualityChanged(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_ConnectionQualityChanged()
        }
        set { eventPayload = .connectionQualityChanged(newValue) }
    }

    var audioLevelChanged: Stream_Video_Sfu_Event_AudioLevelChanged {
        get {
            if case let .audioLevelChanged(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_AudioLevelChanged()
        }
        set { eventPayload = .audioLevelChanged(newValue) }
    }

    var iceTrickle: Stream_Video_Sfu_Models_ICETrickle {
        get {
            if case let .iceTrickle(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Models_ICETrickle()
        }
        set { eventPayload = .iceTrickle(newValue) }
    }

    var changePublishQuality: Stream_Video_Sfu_Event_ChangePublishQuality {
        get {
            if case let .changePublishQuality(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_ChangePublishQuality()
        }
        set { eventPayload = .changePublishQuality(newValue) }
    }

    var participantJoined: Stream_Video_Sfu_Event_ParticipantJoined {
        get {
            if case let .participantJoined(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_ParticipantJoined()
        }
        set { eventPayload = .participantJoined(newValue) }
    }

    var participantLeft: Stream_Video_Sfu_Event_ParticipantLeft {
        get {
            if case let .participantLeft(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_ParticipantLeft()
        }
        set { eventPayload = .participantLeft(newValue) }
    }

    var dominantSpeakerChanged: Stream_Video_Sfu_Event_DominantSpeakerChanged {
        get {
            if case let .dominantSpeakerChanged(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_DominantSpeakerChanged()
        }
        set { eventPayload = .dominantSpeakerChanged(newValue) }
    }

    var joinResponse: Stream_Video_Sfu_Event_JoinResponse {
        get {
            if case let .joinResponse(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_JoinResponse()
        }
        set { eventPayload = .joinResponse(newValue) }
    }

    var healthCheckResponse: Stream_Video_Sfu_Event_HealthCheckResponse {
        get {
            if case let .healthCheckResponse(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_HealthCheckResponse()
        }
        set { eventPayload = .healthCheckResponse(newValue) }
    }

    var trackPublished: Stream_Video_Sfu_Event_TrackPublished {
        get {
            if case let .trackPublished(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_TrackPublished()
        }
        set { eventPayload = .trackPublished(newValue) }
    }

    var trackUnpublished: Stream_Video_Sfu_Event_TrackUnpublished {
        get {
            if case let .trackUnpublished(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_TrackUnpublished()
        }
        set { eventPayload = .trackUnpublished(newValue) }
    }

    var error: Stream_Video_Sfu_Event_Error {
        get {
            if case let .error(v)? = eventPayload { return v }
            return Stream_Video_Sfu_Event_Error()
        }
        set { eventPayload = .error(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_EventPayload: Equatable {
        case subscriberOffer(Stream_Video_Sfu_Event_SubscriberOffer)
        case publisherAnswer(Stream_Video_Sfu_Event_PublisherAnswer)
        case connectionQualityChanged(Stream_Video_Sfu_Event_ConnectionQualityChanged)
        case audioLevelChanged(Stream_Video_Sfu_Event_AudioLevelChanged)
        case iceTrickle(Stream_Video_Sfu_Models_ICETrickle)
        case changePublishQuality(Stream_Video_Sfu_Event_ChangePublishQuality)
        case participantJoined(Stream_Video_Sfu_Event_ParticipantJoined)
        case participantLeft(Stream_Video_Sfu_Event_ParticipantLeft)
        case dominantSpeakerChanged(Stream_Video_Sfu_Event_DominantSpeakerChanged)
        case joinResponse(Stream_Video_Sfu_Event_JoinResponse)
        case healthCheckResponse(Stream_Video_Sfu_Event_HealthCheckResponse)
        case trackPublished(Stream_Video_Sfu_Event_TrackPublished)
        case trackUnpublished(Stream_Video_Sfu_Event_TrackUnpublished)
        case error(Stream_Video_Sfu_Event_Error)

        #if !swift(>=4.1)
        static func == (
            lhs: Stream_Video_Sfu_Event_SfuEvent.OneOf_EventPayload,
            rhs: Stream_Video_Sfu_Event_SfuEvent.OneOf_EventPayload
        ) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.subscriberOffer, .subscriberOffer): return {
                    guard case let .subscriberOffer(l) = lhs, case let .subscriberOffer(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.publisherAnswer, .publisherAnswer): return {
                    guard case let .publisherAnswer(l) = lhs, case let .publisherAnswer(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.connectionQualityChanged, .connectionQualityChanged): return {
                    guard case let .connectionQualityChanged(l) = lhs,
                          case let .connectionQualityChanged(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.audioLevelChanged, .audioLevelChanged): return {
                    guard case let .audioLevelChanged(l) = lhs, case let .audioLevelChanged(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.iceTrickle, .iceTrickle): return {
                    guard case let .iceTrickle(l) = lhs, case let .iceTrickle(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.changePublishQuality, .changePublishQuality): return {
                    guard case let .changePublishQuality(l) = lhs,
                          case let .changePublishQuality(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.participantJoined, .participantJoined): return {
                    guard case let .participantJoined(l) = lhs, case let .participantJoined(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.participantLeft, .participantLeft): return {
                    guard case let .participantLeft(l) = lhs, case let .participantLeft(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.dominantSpeakerChanged, .dominantSpeakerChanged): return {
                    guard case let .dominantSpeakerChanged(l) = lhs,
                          case let .dominantSpeakerChanged(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.joinResponse, .joinResponse): return {
                    guard case let .joinResponse(l) = lhs, case let .joinResponse(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.healthCheckResponse, .healthCheckResponse): return {
                    guard case let .healthCheckResponse(l) = lhs,
                          case let .healthCheckResponse(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.trackPublished, .trackPublished): return {
                    guard case let .trackPublished(l) = lhs, case let .trackPublished(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.trackUnpublished, .trackUnpublished): return {
                    guard case let .trackUnpublished(l) = lhs, case let .trackUnpublished(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.error, .error): return {
                    guard case let .error(l) = lhs, case let .error(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            default: return false
            }
        }
        #endif
    }

    init() {}
}

struct Stream_Video_Sfu_Event_Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var error: Stream_Video_Sfu_Models_Error {
        get { _error ?? Stream_Video_Sfu_Models_Error() }
        set { _error = newValue }
    }

    /// Returns true if `error` has been explicitly set.
    var hasError: Bool { self._error != nil }
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    mutating func clearError() { _error = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _error: Stream_Video_Sfu_Models_Error?
}

struct Stream_Video_Sfu_Event_ICETrickle {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var peerType: Stream_Video_Sfu_Models_PeerType = .publisherUnspecified

    var iceCandidate: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// SfuRequest is a message that is sent from the client to the SFU.
struct Stream_Video_Sfu_Event_SfuRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var requestPayload: Stream_Video_Sfu_Event_SfuRequest.OneOf_RequestPayload?

    var joinRequest: Stream_Video_Sfu_Event_JoinRequest {
        get {
            if case let .joinRequest(v)? = requestPayload { return v }
            return Stream_Video_Sfu_Event_JoinRequest()
        }
        set { requestPayload = .joinRequest(newValue) }
    }

    var healthCheckRequest: Stream_Video_Sfu_Event_HealthCheckRequest {
        get {
            if case let .healthCheckRequest(v)? = requestPayload { return v }
            return Stream_Video_Sfu_Event_HealthCheckRequest()
        }
        set { requestPayload = .healthCheckRequest(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_RequestPayload: Equatable {
        case joinRequest(Stream_Video_Sfu_Event_JoinRequest)
        case healthCheckRequest(Stream_Video_Sfu_Event_HealthCheckRequest)

        #if !swift(>=4.1)
        static func == (
            lhs: Stream_Video_Sfu_Event_SfuRequest.OneOf_RequestPayload,
            rhs: Stream_Video_Sfu_Event_SfuRequest.OneOf_RequestPayload
        ) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.joinRequest, .joinRequest): return {
                    guard case let .joinRequest(l) = lhs, case let .joinRequest(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            case (.healthCheckRequest, .healthCheckRequest): return {
                    guard case let .healthCheckRequest(l) = lhs,
                          case let .healthCheckRequest(r) = rhs else { preconditionFailure() }
                    return l == r
                }()
            default: return false
            }
        }
        #endif
    }

    init() {}
}

struct Stream_Video_Sfu_Event_HealthCheckRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_HealthCheckResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_TrackPublished {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: String = String()

    var sessionID: String = String()

    var type: Stream_Video_Sfu_Models_TrackType = .unspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_TrackUnpublished {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: String = String()

    var sessionID: String = String()

    var type: Stream_Video_Sfu_Models_TrackType = .unspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_JoinRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var token: String = String()

    var sessionID: String = String()

    /// dumb SDP that allow us to extract subscriber's decode codecs
    var subscriberSdp: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_JoinResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    // TODO: include full list of participants with track and audio info
    var callState: Stream_Video_Sfu_Models_CallState {
        get { _callState ?? Stream_Video_Sfu_Models_CallState() }
        set { _callState = newValue }
    }

    /// Returns true if `callState` has been explicitly set.
    var hasCallState: Bool { self._callState != nil }
    /// Clears the value of `callState`. Subsequent reads from it will return its default value.
    mutating func clearCallState() { _callState = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _callState: Stream_Video_Sfu_Models_CallState?
}

/// ParticipantJoined is fired when a user joins a call
struct Stream_Video_Sfu_Event_ParticipantJoined {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callCid: String = String()

    var participant: Stream_Video_Sfu_Models_Participant {
        get { _participant ?? Stream_Video_Sfu_Models_Participant() }
        set { _participant = newValue }
    }

    /// Returns true if `participant` has been explicitly set.
    var hasParticipant: Bool { self._participant != nil }
    /// Clears the value of `participant`. Subsequent reads from it will return its default value.
    mutating func clearParticipant() { _participant = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _participant: Stream_Video_Sfu_Models_Participant?
}

/// ParticipantJoined is fired when a user leaves a call
struct Stream_Video_Sfu_Event_ParticipantLeft {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var callCid: String = String()

    var participant: Stream_Video_Sfu_Models_Participant {
        get { _participant ?? Stream_Video_Sfu_Models_Participant() }
        set { _participant = newValue }
    }

    /// Returns true if `participant` has been explicitly set.
    var hasParticipant: Bool { self._participant != nil }
    /// Clears the value of `participant`. Subsequent reads from it will return its default value.
    mutating func clearParticipant() { _participant = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _participant: Stream_Video_Sfu_Models_Participant?
}

/// SubscriberOffer is sent when the SFU adds tracks to a subscription
struct Stream_Video_Sfu_Event_SubscriberOffer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var iceRestart: Bool = false

    var sdp: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_PublisherAnswer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sdp: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// ConnectionQuality is sent to inform about connection quality changes
/// eg. thierry's connection is not good -> render a red icon Zoom style
struct Stream_Video_Sfu_Event_ConnectionQualityChanged {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var connectionQualityUpdates: [Stream_Video_Sfu_Event_ConnectionQualityInfo] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_ConnectionQualityInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: String = String()

    var sessionID: String = String()

    var connectionQuality: Stream_Video_Sfu_Models_ConnectionQuality = .unspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// DominantSpeakerChanged is sent by the SFU to notify when there is a new dominant speaker in the call
struct Stream_Video_Sfu_Event_DominantSpeakerChanged {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: String = String()

    var sessionID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_AudioLevel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: String = String()

    var sessionID: String = String()

    /// 0.0 means complete silence, 1.0 loudest
    var level: Float = 0

    var isSpeaking: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// AudioLevelChanged is sent by the SFU to notify about audio levels by user
struct Stream_Video_Sfu_Event_AudioLevelChanged {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var audioLevels: [Stream_Video_Sfu_Event_AudioLevel] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_AudioMediaRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var channelCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_AudioSender {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mediaRequest: Stream_Video_Sfu_Event_AudioMediaRequest {
        get { _mediaRequest ?? Stream_Video_Sfu_Event_AudioMediaRequest() }
        set { _mediaRequest = newValue }
    }

    /// Returns true if `mediaRequest` has been explicitly set.
    var hasMediaRequest: Bool { self._mediaRequest != nil }
    /// Clears the value of `mediaRequest`. Subsequent reads from it will return its default value.
    mutating func clearMediaRequest() { _mediaRequest = nil }

    var codec: Stream_Video_Sfu_Models_Codec {
        get { _codec ?? Stream_Video_Sfu_Models_Codec() }
        set { _codec = newValue }
    }

    /// Returns true if `codec` has been explicitly set.
    var hasCodec: Bool { self._codec != nil }
    /// Clears the value of `codec`. Subsequent reads from it will return its default value.
    mutating func clearCodec() { _codec = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _mediaRequest: Stream_Video_Sfu_Event_AudioMediaRequest?
    fileprivate var _codec: Stream_Video_Sfu_Models_Codec?
}

struct Stream_Video_Sfu_Event_VideoMediaRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var idealHeight: Int32 = 0

    var idealWidth: Int32 = 0

    var idealFrameRate: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Stream_Video_Sfu_Event_VideoLayerSetting {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var active: Bool = false

    var maxBitrate: Int32 = 0

    var scaleResolutionDownBy: Float = 0

    var priority: Stream_Video_Sfu_Event_VideoLayerSetting.Priority = .highUnspecified

    var codec: Stream_Video_Sfu_Models_Codec {
        get { _codec ?? Stream_Video_Sfu_Models_Codec() }
        set { _codec = newValue }
    }

    /// Returns true if `codec` has been explicitly set.
    var hasCodec: Bool { self._codec != nil }
    /// Clears the value of `codec`. Subsequent reads from it will return its default value.
    mutating func clearCodec() { _codec = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Priority: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case highUnspecified // = 0
        case low // = 1
        case medium // = 2
        case veryLow // = 3
        case UNRECOGNIZED(Int)

        init() {
            self = .highUnspecified
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .highUnspecified
            case 1: self = .low
            case 2: self = .medium
            case 3: self = .veryLow
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .highUnspecified: return 0
            case .low: return 1
            case .medium: return 2
            case .veryLow: return 3
            case let .UNRECOGNIZED(i): return i
            }
        }
    }

    init() {}

    fileprivate var _codec: Stream_Video_Sfu_Models_Codec?
}

#if swift(>=4.2)

extension Stream_Video_Sfu_Event_VideoLayerSetting.Priority: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Stream_Video_Sfu_Event_VideoLayerSetting.Priority] = [
        .highUnspecified,
        .low,
        .medium,
        .veryLow
    ]
}

#endif // swift(>=4.2)

struct Stream_Video_Sfu_Event_VideoSender {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mediaRequest: Stream_Video_Sfu_Event_VideoMediaRequest {
        get { _mediaRequest ?? Stream_Video_Sfu_Event_VideoMediaRequest() }
        set { _mediaRequest = newValue }
    }

    /// Returns true if `mediaRequest` has been explicitly set.
    var hasMediaRequest: Bool { self._mediaRequest != nil }
    /// Clears the value of `mediaRequest`. Subsequent reads from it will return its default value.
    mutating func clearMediaRequest() { _mediaRequest = nil }

    var codec: Stream_Video_Sfu_Models_Codec {
        get { _codec ?? Stream_Video_Sfu_Models_Codec() }
        set { _codec = newValue }
    }

    /// Returns true if `codec` has been explicitly set.
    var hasCodec: Bool { self._codec != nil }
    /// Clears the value of `codec`. Subsequent reads from it will return its default value.
    mutating func clearCodec() { _codec = nil }

    var layers: [Stream_Video_Sfu_Event_VideoLayerSetting] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _mediaRequest: Stream_Video_Sfu_Event_VideoMediaRequest?
    fileprivate var _codec: Stream_Video_Sfu_Models_Codec?
}

/// sent to users when they need to change the quality of their video
struct Stream_Video_Sfu_Event_ChangePublishQuality {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var audioSenders: [Stream_Video_Sfu_Event_AudioSender] = []

    var videoSenders: [Stream_Video_Sfu_Event_VideoSender] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stream_Video_Sfu_Event_SfuEvent: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_SfuEvent.OneOf_EventPayload: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_Error: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ICETrickle: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_SfuRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_SfuRequest.OneOf_RequestPayload: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_HealthCheckRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_HealthCheckResponse: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_TrackPublished: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_TrackUnpublished: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_JoinRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_JoinResponse: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ParticipantJoined: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ParticipantLeft: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_SubscriberOffer: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_PublisherAnswer: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ConnectionQualityChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ConnectionQualityInfo: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_DominantSpeakerChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioLevel: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioLevelChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioMediaRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioSender: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoMediaRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoLayerSetting: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoLayerSetting.Priority: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoSender: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ChangePublishQuality: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "stream.video.sfu.event"

extension Stream_Video_Sfu_Event_SfuEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SfuEvent"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "subscriber_offer"),
        2: .standard(proto: "publisher_answer"),
        3: .standard(proto: "connection_quality_changed"),
        4: .standard(proto: "audio_level_changed"),
        5: .standard(proto: "ice_trickle"),
        6: .standard(proto: "change_publish_quality"),
        10: .standard(proto: "participant_joined"),
        11: .standard(proto: "participant_left"),
        12: .standard(proto: "dominant_speaker_changed"),
        13: .standard(proto: "join_response"),
        14: .standard(proto: "health_check_response"),
        16: .standard(proto: "track_published"),
        17: .standard(proto: "track_unpublished"),
        18: .same(proto: "error")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: Stream_Video_Sfu_Event_SubscriberOffer?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .subscriberOffer(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .subscriberOffer(v)
                    }
                }()
            case 2: try {
                    var v: Stream_Video_Sfu_Event_PublisherAnswer?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .publisherAnswer(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .publisherAnswer(v)
                    }
                }()
            case 3: try {
                    var v: Stream_Video_Sfu_Event_ConnectionQualityChanged?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .connectionQualityChanged(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .connectionQualityChanged(v)
                    }
                }()
            case 4: try {
                    var v: Stream_Video_Sfu_Event_AudioLevelChanged?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .audioLevelChanged(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .audioLevelChanged(v)
                    }
                }()
            case 5: try {
                    var v: Stream_Video_Sfu_Models_ICETrickle?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .iceTrickle(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .iceTrickle(v)
                    }
                }()
            case 6: try {
                    var v: Stream_Video_Sfu_Event_ChangePublishQuality?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .changePublishQuality(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .changePublishQuality(v)
                    }
                }()
            case 10: try {
                    var v: Stream_Video_Sfu_Event_ParticipantJoined?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .participantJoined(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .participantJoined(v)
                    }
                }()
            case 11: try {
                    var v: Stream_Video_Sfu_Event_ParticipantLeft?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .participantLeft(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .participantLeft(v)
                    }
                }()
            case 12: try {
                    var v: Stream_Video_Sfu_Event_DominantSpeakerChanged?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .dominantSpeakerChanged(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .dominantSpeakerChanged(v)
                    }
                }()
            case 13: try {
                    var v: Stream_Video_Sfu_Event_JoinResponse?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .joinResponse(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .joinResponse(v)
                    }
                }()
            case 14: try {
                    var v: Stream_Video_Sfu_Event_HealthCheckResponse?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .healthCheckResponse(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .healthCheckResponse(v)
                    }
                }()
            case 16: try {
                    var v: Stream_Video_Sfu_Event_TrackPublished?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .trackPublished(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .trackPublished(v)
                    }
                }()
            case 17: try {
                    var v: Stream_Video_Sfu_Event_TrackUnpublished?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .trackUnpublished(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .trackUnpublished(v)
                    }
                }()
            case 18: try {
                    var v: Stream_Video_Sfu_Event_Error?
                    var hadOneofValue = false
                    if let current = self.eventPayload {
                        hadOneofValue = true
                        if case let .error(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.eventPayload = .error(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch eventPayload {
        case .subscriberOffer?: try {
                guard case let .subscriberOffer(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .publisherAnswer?: try {
                guard case let .publisherAnswer(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .connectionQualityChanged?: try {
                guard case let .connectionQualityChanged(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .audioLevelChanged?: try {
                guard case let .audioLevelChanged(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .iceTrickle?: try {
                guard case let .iceTrickle(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case .changePublishQuality?: try {
                guard case let .changePublishQuality(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            }()
        case .participantJoined?: try {
                guard case let .participantJoined(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
            }()
        case .participantLeft?: try {
                guard case let .participantLeft(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
            }()
        case .dominantSpeakerChanged?: try {
                guard case let .dominantSpeakerChanged(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
            }()
        case .joinResponse?: try {
                guard case let .joinResponse(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
            }()
        case .healthCheckResponse?: try {
                guard case let .healthCheckResponse(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
            }()
        case .trackPublished?: try {
                guard case let .trackPublished(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
            }()
        case .trackUnpublished?: try {
                guard case let .trackUnpublished(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
            }()
        case .error?: try {
                guard case let .error(v)? = self.eventPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_SfuEvent, rhs: Stream_Video_Sfu_Event_SfuEvent) -> Bool {
        if lhs.eventPayload != rhs.eventPayload { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Error"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        4: .same(proto: "error")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 4: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_Error, rhs: Stream_Video_Sfu_Event_Error) -> Bool {
        if lhs._error != rhs._error { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_ICETrickle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ICETrickle"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "peer_type"),
        2: .standard(proto: "ice_candidate")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularEnumField(value: &self.peerType) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.iceCandidate) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if peerType != .publisherUnspecified {
            try visitor.visitSingularEnumField(value: peerType, fieldNumber: 1)
        }
        if !iceCandidate.isEmpty {
            try visitor.visitSingularStringField(value: iceCandidate, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_ICETrickle, rhs: Stream_Video_Sfu_Event_ICETrickle) -> Bool {
        if lhs.peerType != rhs.peerType { return false }
        if lhs.iceCandidate != rhs.iceCandidate { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_SfuRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SfuRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "join_request"),
        2: .standard(proto: "health_check_request")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: Stream_Video_Sfu_Event_JoinRequest?
                    var hadOneofValue = false
                    if let current = self.requestPayload {
                        hadOneofValue = true
                        if case let .joinRequest(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.requestPayload = .joinRequest(v)
                    }
                }()
            case 2: try {
                    var v: Stream_Video_Sfu_Event_HealthCheckRequest?
                    var hadOneofValue = false
                    if let current = self.requestPayload {
                        hadOneofValue = true
                        if case let .healthCheckRequest(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.requestPayload = .healthCheckRequest(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch requestPayload {
        case .joinRequest?: try {
                guard case let .joinRequest(v)? = self.requestPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .healthCheckRequest?: try {
                guard case let .healthCheckRequest(v)? = self.requestPayload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_SfuRequest, rhs: Stream_Video_Sfu_Event_SfuRequest) -> Bool {
        if lhs.requestPayload != rhs.requestPayload { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_HealthCheckRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".HealthCheckRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_HealthCheckRequest, rhs: Stream_Video_Sfu_Event_HealthCheckRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_HealthCheckResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".HealthCheckResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_HealthCheckResponse, rhs: Stream_Video_Sfu_Event_HealthCheckResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_TrackPublished: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".TrackPublished"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_id"),
        2: .standard(proto: "session_id"),
        3: .same(proto: "type")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
            case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 1)
        }
        if !sessionID.isEmpty {
            try visitor.visitSingularStringField(value: sessionID, fieldNumber: 2)
        }
        if type != .unspecified {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_TrackPublished, rhs: Stream_Video_Sfu_Event_TrackPublished) -> Bool {
        if lhs.userID != rhs.userID { return false }
        if lhs.sessionID != rhs.sessionID { return false }
        if lhs.type != rhs.type { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_TrackUnpublished: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".TrackUnpublished"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_id"),
        2: .standard(proto: "session_id"),
        3: .same(proto: "type")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
            case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 1)
        }
        if !sessionID.isEmpty {
            try visitor.visitSingularStringField(value: sessionID, fieldNumber: 2)
        }
        if type != .unspecified {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_TrackUnpublished, rhs: Stream_Video_Sfu_Event_TrackUnpublished) -> Bool {
        if lhs.userID != rhs.userID { return false }
        if lhs.sessionID != rhs.sessionID { return false }
        if lhs.type != rhs.type { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_JoinRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".JoinRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "token"),
        2: .standard(proto: "session_id"),
        3: .standard(proto: "subscriber_sdp")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.subscriberSdp) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !token.isEmpty {
            try visitor.visitSingularStringField(value: token, fieldNumber: 1)
        }
        if !sessionID.isEmpty {
            try visitor.visitSingularStringField(value: sessionID, fieldNumber: 2)
        }
        if !subscriberSdp.isEmpty {
            try visitor.visitSingularStringField(value: subscriberSdp, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_JoinRequest, rhs: Stream_Video_Sfu_Event_JoinRequest) -> Bool {
        if lhs.token != rhs.token { return false }
        if lhs.sessionID != rhs.sessionID { return false }
        if lhs.subscriberSdp != rhs.subscriberSdp { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_JoinResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".JoinResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_state")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._callState) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._callState {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_JoinResponse, rhs: Stream_Video_Sfu_Event_JoinResponse) -> Bool {
        if lhs._callState != rhs._callState { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_ParticipantJoined: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ParticipantJoined"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .same(proto: "participant")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._participant) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        try { if let v = self._participant {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_ParticipantJoined, rhs: Stream_Video_Sfu_Event_ParticipantJoined) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs._participant != rhs._participant { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_ParticipantLeft: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ParticipantLeft"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "call_cid"),
        2: .same(proto: "participant")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.callCid) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._participant) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !callCid.isEmpty {
            try visitor.visitSingularStringField(value: callCid, fieldNumber: 1)
        }
        try { if let v = self._participant {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_ParticipantLeft, rhs: Stream_Video_Sfu_Event_ParticipantLeft) -> Bool {
        if lhs.callCid != rhs.callCid { return false }
        if lhs._participant != rhs._participant { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_SubscriberOffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SubscriberOffer"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "ice_restart"),
        2: .same(proto: "sdp")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBoolField(value: &self.iceRestart) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.sdp) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if iceRestart != false {
            try visitor.visitSingularBoolField(value: iceRestart, fieldNumber: 1)
        }
        if !sdp.isEmpty {
            try visitor.visitSingularStringField(value: sdp, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_SubscriberOffer, rhs: Stream_Video_Sfu_Event_SubscriberOffer) -> Bool {
        if lhs.iceRestart != rhs.iceRestart { return false }
        if lhs.sdp != rhs.sdp { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_PublisherAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PublisherAnswer"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "sdp")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.sdp) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !sdp.isEmpty {
            try visitor.visitSingularStringField(value: sdp, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_PublisherAnswer, rhs: Stream_Video_Sfu_Event_PublisherAnswer) -> Bool {
        if lhs.sdp != rhs.sdp { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_ConnectionQualityChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ConnectionQualityChanged"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "connection_quality_updates")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.connectionQualityUpdates) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !connectionQualityUpdates.isEmpty {
            try visitor.visitRepeatedMessageField(value: connectionQualityUpdates, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Sfu_Event_ConnectionQualityChanged,
        rhs: Stream_Video_Sfu_Event_ConnectionQualityChanged
    ) -> Bool {
        if lhs.connectionQualityUpdates != rhs.connectionQualityUpdates { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_ConnectionQualityInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ConnectionQualityInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_id"),
        2: .standard(proto: "session_id"),
        3: .standard(proto: "connection_quality")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
            case 3: try { try decoder.decodeSingularEnumField(value: &self.connectionQuality) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 1)
        }
        if !sessionID.isEmpty {
            try visitor.visitSingularStringField(value: sessionID, fieldNumber: 2)
        }
        if connectionQuality != .unspecified {
            try visitor.visitSingularEnumField(value: connectionQuality, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_ConnectionQualityInfo, rhs: Stream_Video_Sfu_Event_ConnectionQualityInfo) -> Bool {
        if lhs.userID != rhs.userID { return false }
        if lhs.sessionID != rhs.sessionID { return false }
        if lhs.connectionQuality != rhs.connectionQuality { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_DominantSpeakerChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DominantSpeakerChanged"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_id"),
        2: .standard(proto: "session_id")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 1)
        }
        if !sessionID.isEmpty {
            try visitor.visitSingularStringField(value: sessionID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Stream_Video_Sfu_Event_DominantSpeakerChanged,
        rhs: Stream_Video_Sfu_Event_DominantSpeakerChanged
    ) -> Bool {
        if lhs.userID != rhs.userID { return false }
        if lhs.sessionID != rhs.sessionID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_AudioLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AudioLevel"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "user_id"),
        2: .standard(proto: "session_id"),
        3: .same(proto: "level"),
        4: .standard(proto: "is_speaking")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
            case 3: try { try decoder.decodeSingularFloatField(value: &self.level) }()
            case 4: try { try decoder.decodeSingularBoolField(value: &self.isSpeaking) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !userID.isEmpty {
            try visitor.visitSingularStringField(value: userID, fieldNumber: 1)
        }
        if !sessionID.isEmpty {
            try visitor.visitSingularStringField(value: sessionID, fieldNumber: 2)
        }
        if level != 0 {
            try visitor.visitSingularFloatField(value: level, fieldNumber: 3)
        }
        if isSpeaking != false {
            try visitor.visitSingularBoolField(value: isSpeaking, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_AudioLevel, rhs: Stream_Video_Sfu_Event_AudioLevel) -> Bool {
        if lhs.userID != rhs.userID { return false }
        if lhs.sessionID != rhs.sessionID { return false }
        if lhs.level != rhs.level { return false }
        if lhs.isSpeaking != rhs.isSpeaking { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_AudioLevelChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AudioLevelChanged"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "audio_levels")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.audioLevels) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !audioLevels.isEmpty {
            try visitor.visitRepeatedMessageField(value: audioLevels, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_AudioLevelChanged, rhs: Stream_Video_Sfu_Event_AudioLevelChanged) -> Bool {
        if lhs.audioLevels != rhs.audioLevels { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_AudioMediaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AudioMediaRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "channel_count")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularInt32Field(value: &self.channelCount) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if channelCount != 0 {
            try visitor.visitSingularInt32Field(value: channelCount, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_AudioMediaRequest, rhs: Stream_Video_Sfu_Event_AudioMediaRequest) -> Bool {
        if lhs.channelCount != rhs.channelCount { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_AudioSender: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AudioSender"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "media_request"),
        2: .same(proto: "codec")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._mediaRequest) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._codec) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._mediaRequest {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._codec {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_AudioSender, rhs: Stream_Video_Sfu_Event_AudioSender) -> Bool {
        if lhs._mediaRequest != rhs._mediaRequest { return false }
        if lhs._codec != rhs._codec { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_VideoMediaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".VideoMediaRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "ideal_height"),
        2: .standard(proto: "ideal_width"),
        3: .standard(proto: "ideal_frame_rate")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularInt32Field(value: &self.idealHeight) }()
            case 2: try { try decoder.decodeSingularInt32Field(value: &self.idealWidth) }()
            case 3: try { try decoder.decodeSingularInt32Field(value: &self.idealFrameRate) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if idealHeight != 0 {
            try visitor.visitSingularInt32Field(value: idealHeight, fieldNumber: 1)
        }
        if idealWidth != 0 {
            try visitor.visitSingularInt32Field(value: idealWidth, fieldNumber: 2)
        }
        if idealFrameRate != 0 {
            try visitor.visitSingularInt32Field(value: idealFrameRate, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_VideoMediaRequest, rhs: Stream_Video_Sfu_Event_VideoMediaRequest) -> Bool {
        if lhs.idealHeight != rhs.idealHeight { return false }
        if lhs.idealWidth != rhs.idealWidth { return false }
        if lhs.idealFrameRate != rhs.idealFrameRate { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_VideoLayerSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".VideoLayerSetting"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "active"),
        3: .standard(proto: "max_bitrate"),
        4: .standard(proto: "scale_resolution_down_by"),
        5: .same(proto: "priority"),
        6: .same(proto: "codec")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.active) }()
            case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxBitrate) }()
            case 4: try { try decoder.decodeSingularFloatField(value: &self.scaleResolutionDownBy) }()
            case 5: try { try decoder.decodeSingularEnumField(value: &self.priority) }()
            case 6: try { try decoder.decodeSingularMessageField(value: &self._codec) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if active != false {
            try visitor.visitSingularBoolField(value: active, fieldNumber: 2)
        }
        if maxBitrate != 0 {
            try visitor.visitSingularInt32Field(value: maxBitrate, fieldNumber: 3)
        }
        if scaleResolutionDownBy != 0 {
            try visitor.visitSingularFloatField(value: scaleResolutionDownBy, fieldNumber: 4)
        }
        if priority != .highUnspecified {
            try visitor.visitSingularEnumField(value: priority, fieldNumber: 5)
        }
        try { if let v = self._codec {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_VideoLayerSetting, rhs: Stream_Video_Sfu_Event_VideoLayerSetting) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.active != rhs.active { return false }
        if lhs.maxBitrate != rhs.maxBitrate { return false }
        if lhs.scaleResolutionDownBy != rhs.scaleResolutionDownBy { return false }
        if lhs.priority != rhs.priority { return false }
        if lhs._codec != rhs._codec { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_VideoLayerSetting.Priority: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "PRIORITY_HIGH_UNSPECIFIED"),
        1: .same(proto: "PRIORITY_LOW"),
        2: .same(proto: "PRIORITY_MEDIUM"),
        3: .same(proto: "PRIORITY_VERY_LOW")
    ]
}

extension Stream_Video_Sfu_Event_VideoSender: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".VideoSender"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "media_request"),
        2: .same(proto: "codec"),
        3: .same(proto: "layers")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._mediaRequest) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._codec) }()
            case 3: try { try decoder.decodeRepeatedMessageField(value: &self.layers) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._mediaRequest {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._codec {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !layers.isEmpty {
            try visitor.visitRepeatedMessageField(value: layers, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_VideoSender, rhs: Stream_Video_Sfu_Event_VideoSender) -> Bool {
        if lhs._mediaRequest != rhs._mediaRequest { return false }
        if lhs._codec != rhs._codec { return false }
        if lhs.layers != rhs.layers { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Stream_Video_Sfu_Event_ChangePublishQuality: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ChangePublishQuality"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "audio_senders"),
        2: .standard(proto: "video_senders")
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.audioSenders) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.videoSenders) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !audioSenders.isEmpty {
            try visitor.visitRepeatedMessageField(value: audioSenders, fieldNumber: 1)
        }
        if !videoSenders.isEmpty {
            try visitor.visitRepeatedMessageField(value: videoSenders, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Stream_Video_Sfu_Event_ChangePublishQuality, rhs: Stream_Video_Sfu_Event_ChangePublishQuality) -> Bool {
        if lhs.audioSenders != rhs.audioSenders { return false }
        if lhs.videoSenders != rhs.videoSenders { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
