// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: video/sfu/event/events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// SFUEvent is a message that is sent from the SFU to the client.
struct Stream_Video_Sfu_Event_SfuEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventPayload: Stream_Video_Sfu_Event_SfuEvent.OneOf_EventPayload? = nil

  var subscriberOffer: Stream_Video_Sfu_Event_SubscriberOffer {
    get {
      if case .subscriberOffer(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_SubscriberOffer()
    }
    set {eventPayload = .subscriberOffer(newValue)}
  }

  var publisherAnswer: Stream_Video_Sfu_Event_PublisherAnswer {
    get {
      if case .publisherAnswer(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_PublisherAnswer()
    }
    set {eventPayload = .publisherAnswer(newValue)}
  }

  var connectionQualityChanged: Stream_Video_Sfu_Event_ConnectionQualityChanged {
    get {
      if case .connectionQualityChanged(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_ConnectionQualityChanged()
    }
    set {eventPayload = .connectionQualityChanged(newValue)}
  }

  var audioLevelChanged: Stream_Video_Sfu_Event_AudioLevelChanged {
    get {
      if case .audioLevelChanged(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_AudioLevelChanged()
    }
    set {eventPayload = .audioLevelChanged(newValue)}
  }

  var iceTrickle: Stream_Video_Sfu_Models_ICETrickle {
    get {
      if case .iceTrickle(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Models_ICETrickle()
    }
    set {eventPayload = .iceTrickle(newValue)}
  }

  var changePublishQuality: Stream_Video_Sfu_Event_ChangePublishQuality {
    get {
      if case .changePublishQuality(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_ChangePublishQuality()
    }
    set {eventPayload = .changePublishQuality(newValue)}
  }

  var localDeviceChange: Stream_Video_Sfu_Event_LocalDeviceChange {
    get {
      if case .localDeviceChange(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_LocalDeviceChange()
    }
    set {eventPayload = .localDeviceChange(newValue)}
  }

  var muteStateChanged: Stream_Video_Sfu_Event_MuteStateChanged {
    get {
      if case .muteStateChanged(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_MuteStateChanged()
    }
    set {eventPayload = .muteStateChanged(newValue)}
  }

  var videoQualityChanged: Stream_Video_Sfu_Event_VideoQualityChanged {
    get {
      if case .videoQualityChanged(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_VideoQualityChanged()
    }
    set {eventPayload = .videoQualityChanged(newValue)}
  }

  var participantJoined: Stream_Video_Sfu_Event_ParticipantJoined {
    get {
      if case .participantJoined(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_ParticipantJoined()
    }
    set {eventPayload = .participantJoined(newValue)}
  }

  var participantLeft: Stream_Video_Sfu_Event_ParticipantLeft {
    get {
      if case .participantLeft(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_ParticipantLeft()
    }
    set {eventPayload = .participantLeft(newValue)}
  }

  var dominantSpeakerChanged: Stream_Video_Sfu_Event_DominantSpeakerChanged {
    get {
      if case .dominantSpeakerChanged(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_DominantSpeakerChanged()
    }
    set {eventPayload = .dominantSpeakerChanged(newValue)}
  }

  var joinResponse: Stream_Video_Sfu_Event_JoinResponse {
    get {
      if case .joinResponse(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_JoinResponse()
    }
    set {eventPayload = .joinResponse(newValue)}
  }

  var healthCheckResponse: Stream_Video_Sfu_Event_HealthCheckResponse {
    get {
      if case .healthCheckResponse(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_HealthCheckResponse()
    }
    set {eventPayload = .healthCheckResponse(newValue)}
  }

  var callEnded: Stream_Video_Sfu_Event_CallEnded {
    get {
      if case .callEnded(let v)? = eventPayload {return v}
      return Stream_Video_Sfu_Event_CallEnded()
    }
    set {eventPayload = .callEnded(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_EventPayload: Equatable {
    case subscriberOffer(Stream_Video_Sfu_Event_SubscriberOffer)
    case publisherAnswer(Stream_Video_Sfu_Event_PublisherAnswer)
    case connectionQualityChanged(Stream_Video_Sfu_Event_ConnectionQualityChanged)
    case audioLevelChanged(Stream_Video_Sfu_Event_AudioLevelChanged)
    case iceTrickle(Stream_Video_Sfu_Models_ICETrickle)
    case changePublishQuality(Stream_Video_Sfu_Event_ChangePublishQuality)
    case localDeviceChange(Stream_Video_Sfu_Event_LocalDeviceChange)
    case muteStateChanged(Stream_Video_Sfu_Event_MuteStateChanged)
    case videoQualityChanged(Stream_Video_Sfu_Event_VideoQualityChanged)
    case participantJoined(Stream_Video_Sfu_Event_ParticipantJoined)
    case participantLeft(Stream_Video_Sfu_Event_ParticipantLeft)
    case dominantSpeakerChanged(Stream_Video_Sfu_Event_DominantSpeakerChanged)
    case joinResponse(Stream_Video_Sfu_Event_JoinResponse)
    case healthCheckResponse(Stream_Video_Sfu_Event_HealthCheckResponse)
    case callEnded(Stream_Video_Sfu_Event_CallEnded)

  #if !swift(>=4.1)
    static func ==(lhs: Stream_Video_Sfu_Event_SfuEvent.OneOf_EventPayload, rhs: Stream_Video_Sfu_Event_SfuEvent.OneOf_EventPayload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.subscriberOffer, .subscriberOffer): return {
        guard case .subscriberOffer(let l) = lhs, case .subscriberOffer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.publisherAnswer, .publisherAnswer): return {
        guard case .publisherAnswer(let l) = lhs, case .publisherAnswer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.connectionQualityChanged, .connectionQualityChanged): return {
        guard case .connectionQualityChanged(let l) = lhs, case .connectionQualityChanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audioLevelChanged, .audioLevelChanged): return {
        guard case .audioLevelChanged(let l) = lhs, case .audioLevelChanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iceTrickle, .iceTrickle): return {
        guard case .iceTrickle(let l) = lhs, case .iceTrickle(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.changePublishQuality, .changePublishQuality): return {
        guard case .changePublishQuality(let l) = lhs, case .changePublishQuality(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.localDeviceChange, .localDeviceChange): return {
        guard case .localDeviceChange(let l) = lhs, case .localDeviceChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.muteStateChanged, .muteStateChanged): return {
        guard case .muteStateChanged(let l) = lhs, case .muteStateChanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.videoQualityChanged, .videoQualityChanged): return {
        guard case .videoQualityChanged(let l) = lhs, case .videoQualityChanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.participantJoined, .participantJoined): return {
        guard case .participantJoined(let l) = lhs, case .participantJoined(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.participantLeft, .participantLeft): return {
        guard case .participantLeft(let l) = lhs, case .participantLeft(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dominantSpeakerChanged, .dominantSpeakerChanged): return {
        guard case .dominantSpeakerChanged(let l) = lhs, case .dominantSpeakerChanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.joinResponse, .joinResponse): return {
        guard case .joinResponse(let l) = lhs, case .joinResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.healthCheckResponse, .healthCheckResponse): return {
        guard case .healthCheckResponse(let l) = lhs, case .healthCheckResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callEnded, .callEnded): return {
        guard case .callEnded(let l) = lhs, case .callEnded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// SfuRequest is a message that is sent from the client to the SFU.
struct Stream_Video_Sfu_Event_SfuRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestPayload: Stream_Video_Sfu_Event_SfuRequest.OneOf_RequestPayload? = nil

  var joinRequest: Stream_Video_Sfu_Event_JoinRequest {
    get {
      if case .joinRequest(let v)? = requestPayload {return v}
      return Stream_Video_Sfu_Event_JoinRequest()
    }
    set {requestPayload = .joinRequest(newValue)}
  }

  var healthCheckRequest: Stream_Video_Sfu_Event_HealthCheckRequest {
    get {
      if case .healthCheckRequest(let v)? = requestPayload {return v}
      return Stream_Video_Sfu_Event_HealthCheckRequest()
    }
    set {requestPayload = .healthCheckRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_RequestPayload: Equatable {
    case joinRequest(Stream_Video_Sfu_Event_JoinRequest)
    case healthCheckRequest(Stream_Video_Sfu_Event_HealthCheckRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Stream_Video_Sfu_Event_SfuRequest.OneOf_RequestPayload, rhs: Stream_Video_Sfu_Event_SfuRequest.OneOf_RequestPayload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.joinRequest, .joinRequest): return {
        guard case .joinRequest(let l) = lhs, case .joinRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.healthCheckRequest, .healthCheckRequest): return {
        guard case .healthCheckRequest(let l) = lhs, case .healthCheckRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Stream_Video_Sfu_Event_HealthCheckRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_HealthCheckResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_JoinRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var sessionID: String = String()

  var publish: Bool = false

  /// TODO: we should know if this is going to be
  /// - publishing and subscribing, or just subscribing for future routing
  var codecSettings: Stream_Video_Sfu_Models_CodecSettings {
    get {return _codecSettings ?? Stream_Video_Sfu_Models_CodecSettings()}
    set {_codecSettings = newValue}
  }
  /// Returns true if `codecSettings` has been explicitly set.
  var hasCodecSettings: Bool {return self._codecSettings != nil}
  /// Clears the value of `codecSettings`. Subsequent reads from it will return its default value.
  mutating func clearCodecSettings() {self._codecSettings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _codecSettings: Stream_Video_Sfu_Models_CodecSettings? = nil
}

struct Stream_Video_Sfu_Event_JoinResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var callState: Stream_Video_Sfu_Models_CallState {
    get {return _callState ?? Stream_Video_Sfu_Models_CallState()}
    set {_callState = newValue}
  }
  /// Returns true if `callState` has been explicitly set.
  var hasCallState: Bool {return self._callState != nil}
  /// Clears the value of `callState`. Subsequent reads from it will return its default value.
  mutating func clearCallState() {self._callState = nil}

  /// TODO: include full list of participants with track and audio info
  var ownSessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _callState: Stream_Video_Sfu_Models_CallState? = nil
}

/// ParticipantJoined is fired when a user joins a call
struct Stream_Video_Sfu_Event_ParticipantJoined {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var call: Stream_Video_Sfu_Models_Call {
    get {return _call ?? Stream_Video_Sfu_Models_Call()}
    set {_call = newValue}
  }
  /// Returns true if `call` has been explicitly set.
  var hasCall: Bool {return self._call != nil}
  /// Clears the value of `call`. Subsequent reads from it will return its default value.
  mutating func clearCall() {self._call = nil}

  var participant: Stream_Video_Sfu_Models_Participant {
    get {return _participant ?? Stream_Video_Sfu_Models_Participant()}
    set {_participant = newValue}
  }
  /// Returns true if `participant` has been explicitly set.
  var hasParticipant: Bool {return self._participant != nil}
  /// Clears the value of `participant`. Subsequent reads from it will return its default value.
  mutating func clearParticipant() {self._participant = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _call: Stream_Video_Sfu_Models_Call? = nil
  fileprivate var _participant: Stream_Video_Sfu_Models_Participant? = nil
}

/// ParticipantJoined is fired when a user leaves a call
struct Stream_Video_Sfu_Event_ParticipantLeft {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var call: Stream_Video_Sfu_Models_Call {
    get {return _call ?? Stream_Video_Sfu_Models_Call()}
    set {_call = newValue}
  }
  /// Returns true if `call` has been explicitly set.
  var hasCall: Bool {return self._call != nil}
  /// Clears the value of `call`. Subsequent reads from it will return its default value.
  mutating func clearCall() {self._call = nil}

  var participant: Stream_Video_Sfu_Models_Participant {
    get {return _participant ?? Stream_Video_Sfu_Models_Participant()}
    set {_participant = newValue}
  }
  /// Returns true if `participant` has been explicitly set.
  var hasParticipant: Bool {return self._participant != nil}
  /// Clears the value of `participant`. Subsequent reads from it will return its default value.
  mutating func clearParticipant() {self._participant = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _call: Stream_Video_Sfu_Models_Call? = nil
  fileprivate var _participant: Stream_Video_Sfu_Models_Participant? = nil
}

struct Stream_Video_Sfu_Event_MuteStateChanged {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var audioMuted: Bool = false

  var videoMuted: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_VideoQualityChanged {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var streamQualities: [Stream_Video_Sfu_Models_StreamQuality] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SubscriberOffer is sent when the SFU adds tracks to a subscription
/// this usually happens when a user joins a call and starts sending video
struct Stream_Video_Sfu_Event_SubscriberOffer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sdp: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_PublisherAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sdp: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_LocalDeviceChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ICECandidateTrickle is about the ICE nonsense stuff
struct Stream_Video_Sfu_Event_ICECandidateTrickle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var candidate: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ConnectionQuality is sent to inform about connection quality changes
/// eg. thierry's connection is not good -> render a red icon Zoom style
struct Stream_Video_Sfu_Event_ConnectionQualityChanged {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var connectionQuality: Stream_Video_Sfu_Models_ConnectionQuality = .badUnspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DominantSpeakerChanged is sent by the SFU to notify when there is a new dominant speaker in the call
struct Stream_Video_Sfu_Event_DominantSpeakerChanged {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AudioLevelChanged is sent by the SFU to notify about audio levels by user
struct Stream_Video_Sfu_Event_AudioLevelChanged {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var audioLevels: [Stream_Video_Sfu_Event_AudioLevel] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_CallEnded {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_AudioLevel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  /// 0.0 means complete silence, 1.0 loudest
  var level: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_AudioLayerSetting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_AudioMediaRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelCount: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_AudioSender {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mediaRequest: Stream_Video_Sfu_Event_AudioMediaRequest {
    get {return _mediaRequest ?? Stream_Video_Sfu_Event_AudioMediaRequest()}
    set {_mediaRequest = newValue}
  }
  /// Returns true if `mediaRequest` has been explicitly set.
  var hasMediaRequest: Bool {return self._mediaRequest != nil}
  /// Clears the value of `mediaRequest`. Subsequent reads from it will return its default value.
  mutating func clearMediaRequest() {self._mediaRequest = nil}

  var codec: Stream_Video_Sfu_Models_Codec {
    get {return _codec ?? Stream_Video_Sfu_Models_Codec()}
    set {_codec = newValue}
  }
  /// Returns true if `codec` has been explicitly set.
  var hasCodec: Bool {return self._codec != nil}
  /// Clears the value of `codec`. Subsequent reads from it will return its default value.
  mutating func clearCodec() {self._codec = nil}

  var layers: [Stream_Video_Sfu_Event_AudioLayerSetting] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mediaRequest: Stream_Video_Sfu_Event_AudioMediaRequest? = nil
  fileprivate var _codec: Stream_Video_Sfu_Models_Codec? = nil
}

struct Stream_Video_Sfu_Event_VideoMediaRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var idealHeight: Int32 = 0

  var idealWidth: Int32 = 0

  var idealFrameRate: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Stream_Video_Sfu_Event_VideoLayerSetting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var active: Bool = false

  var maxBitrate: Int32 = 0

  var scaleResolutionDownBy: Float = 0

  var priority: Stream_Video_Sfu_Event_VideoLayerSetting.Priority = .highUnspecified

  var codec: Stream_Video_Sfu_Models_Codec {
    get {return _codec ?? Stream_Video_Sfu_Models_Codec()}
    set {_codec = newValue}
  }
  /// Returns true if `codec` has been explicitly set.
  var hasCodec: Bool {return self._codec != nil}
  /// Clears the value of `codec`. Subsequent reads from it will return its default value.
  mutating func clearCodec() {self._codec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Priority: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case highUnspecified // = 0
    case low // = 1
    case medium // = 2
    case veryLow // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .highUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .highUnspecified
      case 1: self = .low
      case 2: self = .medium
      case 3: self = .veryLow
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .highUnspecified: return 0
      case .low: return 1
      case .medium: return 2
      case .veryLow: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _codec: Stream_Video_Sfu_Models_Codec? = nil
}

#if swift(>=4.2)

extension Stream_Video_Sfu_Event_VideoLayerSetting.Priority: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Stream_Video_Sfu_Event_VideoLayerSetting.Priority] = [
    .highUnspecified,
    .low,
    .medium,
    .veryLow,
  ]
}

#endif  // swift(>=4.2)

struct Stream_Video_Sfu_Event_VideoSender {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mediaRequest: Stream_Video_Sfu_Event_VideoMediaRequest {
    get {return _mediaRequest ?? Stream_Video_Sfu_Event_VideoMediaRequest()}
    set {_mediaRequest = newValue}
  }
  /// Returns true if `mediaRequest` has been explicitly set.
  var hasMediaRequest: Bool {return self._mediaRequest != nil}
  /// Clears the value of `mediaRequest`. Subsequent reads from it will return its default value.
  mutating func clearMediaRequest() {self._mediaRequest = nil}

  var codec: Stream_Video_Sfu_Models_Codec {
    get {return _codec ?? Stream_Video_Sfu_Models_Codec()}
    set {_codec = newValue}
  }
  /// Returns true if `codec` has been explicitly set.
  var hasCodec: Bool {return self._codec != nil}
  /// Clears the value of `codec`. Subsequent reads from it will return its default value.
  mutating func clearCodec() {self._codec = nil}

  var layers: [Stream_Video_Sfu_Event_VideoLayerSetting] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mediaRequest: Stream_Video_Sfu_Event_VideoMediaRequest? = nil
  fileprivate var _codec: Stream_Video_Sfu_Models_Codec? = nil
}

/// sent to users when they need to change the quality of their video
struct Stream_Video_Sfu_Event_ChangePublishQuality {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var audioSenders: [Stream_Video_Sfu_Event_AudioSender] = []

  var videoSenders: [Stream_Video_Sfu_Event_VideoSender] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stream_Video_Sfu_Event_SfuEvent: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_SfuEvent.OneOf_EventPayload: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_SfuRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_SfuRequest.OneOf_RequestPayload: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_HealthCheckRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_HealthCheckResponse: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_JoinRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_JoinResponse: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ParticipantJoined: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ParticipantLeft: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_MuteStateChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoQualityChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_SubscriberOffer: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_PublisherAnswer: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_LocalDeviceChange: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ICECandidateTrickle: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ConnectionQualityChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_DominantSpeakerChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioLevelChanged: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_CallEnded: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioLevel: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioLayerSetting: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioMediaRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_AudioSender: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoMediaRequest: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoLayerSetting: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoLayerSetting.Priority: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_VideoSender: @unchecked Sendable {}
extension Stream_Video_Sfu_Event_ChangePublishQuality: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stream.video.sfu.event"

extension Stream_Video_Sfu_Event_SfuEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SfuEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscriber_offer"),
    2: .standard(proto: "publisher_answer"),
    3: .standard(proto: "connection_quality_changed"),
    4: .standard(proto: "audio_level_changed"),
    5: .standard(proto: "ice_trickle"),
    6: .standard(proto: "change_publish_quality"),
    7: .standard(proto: "local_device_change"),
    8: .standard(proto: "mute_state_changed"),
    9: .standard(proto: "video_quality_changed"),
    10: .standard(proto: "participant_joined"),
    11: .standard(proto: "participant_left"),
    12: .standard(proto: "dominant_speaker_changed"),
    13: .standard(proto: "join_response"),
    14: .standard(proto: "health_check_response"),
    15: .standard(proto: "call_ended"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Stream_Video_Sfu_Event_SubscriberOffer?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .subscriberOffer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .subscriberOffer(v)
        }
      }()
      case 2: try {
        var v: Stream_Video_Sfu_Event_PublisherAnswer?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .publisherAnswer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .publisherAnswer(v)
        }
      }()
      case 3: try {
        var v: Stream_Video_Sfu_Event_ConnectionQualityChanged?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .connectionQualityChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .connectionQualityChanged(v)
        }
      }()
      case 4: try {
        var v: Stream_Video_Sfu_Event_AudioLevelChanged?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .audioLevelChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .audioLevelChanged(v)
        }
      }()
      case 5: try {
        var v: Stream_Video_Sfu_Models_ICETrickle?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .iceTrickle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .iceTrickle(v)
        }
      }()
      case 6: try {
        var v: Stream_Video_Sfu_Event_ChangePublishQuality?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .changePublishQuality(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .changePublishQuality(v)
        }
      }()
      case 7: try {
        var v: Stream_Video_Sfu_Event_LocalDeviceChange?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .localDeviceChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .localDeviceChange(v)
        }
      }()
      case 8: try {
        var v: Stream_Video_Sfu_Event_MuteStateChanged?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .muteStateChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .muteStateChanged(v)
        }
      }()
      case 9: try {
        var v: Stream_Video_Sfu_Event_VideoQualityChanged?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .videoQualityChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .videoQualityChanged(v)
        }
      }()
      case 10: try {
        var v: Stream_Video_Sfu_Event_ParticipantJoined?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .participantJoined(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .participantJoined(v)
        }
      }()
      case 11: try {
        var v: Stream_Video_Sfu_Event_ParticipantLeft?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .participantLeft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .participantLeft(v)
        }
      }()
      case 12: try {
        var v: Stream_Video_Sfu_Event_DominantSpeakerChanged?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .dominantSpeakerChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .dominantSpeakerChanged(v)
        }
      }()
      case 13: try {
        var v: Stream_Video_Sfu_Event_JoinResponse?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .joinResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .joinResponse(v)
        }
      }()
      case 14: try {
        var v: Stream_Video_Sfu_Event_HealthCheckResponse?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .healthCheckResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .healthCheckResponse(v)
        }
      }()
      case 15: try {
        var v: Stream_Video_Sfu_Event_CallEnded?
        var hadOneofValue = false
        if let current = self.eventPayload {
          hadOneofValue = true
          if case .callEnded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.eventPayload = .callEnded(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.eventPayload {
    case .subscriberOffer?: try {
      guard case .subscriberOffer(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .publisherAnswer?: try {
      guard case .publisherAnswer(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .connectionQualityChanged?: try {
      guard case .connectionQualityChanged(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .audioLevelChanged?: try {
      guard case .audioLevelChanged(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .iceTrickle?: try {
      guard case .iceTrickle(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .changePublishQuality?: try {
      guard case .changePublishQuality(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .localDeviceChange?: try {
      guard case .localDeviceChange(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .muteStateChanged?: try {
      guard case .muteStateChanged(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .videoQualityChanged?: try {
      guard case .videoQualityChanged(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .participantJoined?: try {
      guard case .participantJoined(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .participantLeft?: try {
      guard case .participantLeft(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .dominantSpeakerChanged?: try {
      guard case .dominantSpeakerChanged(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .joinResponse?: try {
      guard case .joinResponse(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .healthCheckResponse?: try {
      guard case .healthCheckResponse(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .callEnded?: try {
      guard case .callEnded(let v)? = self.eventPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_SfuEvent, rhs: Stream_Video_Sfu_Event_SfuEvent) -> Bool {
    if lhs.eventPayload != rhs.eventPayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_SfuRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SfuRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "join_request"),
    2: .standard(proto: "health_check_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Stream_Video_Sfu_Event_JoinRequest?
        var hadOneofValue = false
        if let current = self.requestPayload {
          hadOneofValue = true
          if case .joinRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestPayload = .joinRequest(v)
        }
      }()
      case 2: try {
        var v: Stream_Video_Sfu_Event_HealthCheckRequest?
        var hadOneofValue = false
        if let current = self.requestPayload {
          hadOneofValue = true
          if case .healthCheckRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestPayload = .healthCheckRequest(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.requestPayload {
    case .joinRequest?: try {
      guard case .joinRequest(let v)? = self.requestPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .healthCheckRequest?: try {
      guard case .healthCheckRequest(let v)? = self.requestPayload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_SfuRequest, rhs: Stream_Video_Sfu_Event_SfuRequest) -> Bool {
    if lhs.requestPayload != rhs.requestPayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_HealthCheckRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HealthCheckRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_HealthCheckRequest, rhs: Stream_Video_Sfu_Event_HealthCheckRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_HealthCheckResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HealthCheckResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_HealthCheckResponse, rhs: Stream_Video_Sfu_Event_HealthCheckResponse) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_JoinRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JoinRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .standard(proto: "session_id"),
    3: .same(proto: "publish"),
    4: .standard(proto: "codec_settings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.publish) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._codecSettings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    if self.publish != false {
      try visitor.visitSingularBoolField(value: self.publish, fieldNumber: 3)
    }
    try { if let v = self._codecSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_JoinRequest, rhs: Stream_Video_Sfu_Event_JoinRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.publish != rhs.publish {return false}
    if lhs._codecSettings != rhs._codecSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_JoinResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JoinResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_state"),
    2: .standard(proto: "own_session_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._callState) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownSessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._callState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.ownSessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownSessionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_JoinResponse, rhs: Stream_Video_Sfu_Event_JoinResponse) -> Bool {
    if lhs._callState != rhs._callState {return false}
    if lhs.ownSessionID != rhs.ownSessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_ParticipantJoined: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantJoined"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "call"),
    2: .same(proto: "participant"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._participant) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._call {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._participant {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_ParticipantJoined, rhs: Stream_Video_Sfu_Event_ParticipantJoined) -> Bool {
    if lhs._call != rhs._call {return false}
    if lhs._participant != rhs._participant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_ParticipantLeft: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantLeft"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "call"),
    2: .same(proto: "participant"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._call) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._participant) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._call {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._participant {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_ParticipantLeft, rhs: Stream_Video_Sfu_Event_ParticipantLeft) -> Bool {
    if lhs._call != rhs._call {return false}
    if lhs._participant != rhs._participant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_MuteStateChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MuteStateChanged"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "audio_muted"),
    3: .standard(proto: "video_muted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.audioMuted) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.videoMuted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.audioMuted != false {
      try visitor.visitSingularBoolField(value: self.audioMuted, fieldNumber: 2)
    }
    if self.videoMuted != false {
      try visitor.visitSingularBoolField(value: self.videoMuted, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_MuteStateChanged, rhs: Stream_Video_Sfu_Event_MuteStateChanged) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.audioMuted != rhs.audioMuted {return false}
    if lhs.videoMuted != rhs.videoMuted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_VideoQualityChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoQualityChanged"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_qualities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.streamQualities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streamQualities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.streamQualities, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_VideoQualityChanged, rhs: Stream_Video_Sfu_Event_VideoQualityChanged) -> Bool {
    if lhs.streamQualities != rhs.streamQualities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_SubscriberOffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscriberOffer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sdp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sdp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sdp.isEmpty {
      try visitor.visitSingularStringField(value: self.sdp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_SubscriberOffer, rhs: Stream_Video_Sfu_Event_SubscriberOffer) -> Bool {
    if lhs.sdp != rhs.sdp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_PublisherAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublisherAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sdp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sdp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sdp.isEmpty {
      try visitor.visitSingularStringField(value: self.sdp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_PublisherAnswer, rhs: Stream_Video_Sfu_Event_PublisherAnswer) -> Bool {
    if lhs.sdp != rhs.sdp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_LocalDeviceChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LocalDeviceChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_LocalDeviceChange, rhs: Stream_Video_Sfu_Event_LocalDeviceChange) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_ICECandidateTrickle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ICECandidateTrickle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "candidate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.candidate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.candidate.isEmpty {
      try visitor.visitSingularStringField(value: self.candidate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_ICECandidateTrickle, rhs: Stream_Video_Sfu_Event_ICECandidateTrickle) -> Bool {
    if lhs.candidate != rhs.candidate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_ConnectionQualityChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionQualityChanged"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "connection_quality"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.connectionQuality) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.connectionQuality != .badUnspecified {
      try visitor.visitSingularEnumField(value: self.connectionQuality, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_ConnectionQualityChanged, rhs: Stream_Video_Sfu_Event_ConnectionQualityChanged) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.connectionQuality != rhs.connectionQuality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_DominantSpeakerChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DominantSpeakerChanged"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_DominantSpeakerChanged, rhs: Stream_Video_Sfu_Event_DominantSpeakerChanged) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_AudioLevelChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AudioLevelChanged"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_levels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.audioLevels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.audioLevels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.audioLevels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_AudioLevelChanged, rhs: Stream_Video_Sfu_Event_AudioLevelChanged) -> Bool {
    if lhs.audioLevels != rhs.audioLevels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_CallEnded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallEnded"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_CallEnded, rhs: Stream_Video_Sfu_Event_CallEnded) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_AudioLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AudioLevel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.level != 0 {
      try visitor.visitSingularFloatField(value: self.level, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_AudioLevel, rhs: Stream_Video_Sfu_Event_AudioLevel) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_AudioLayerSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AudioLayerSetting"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_AudioLayerSetting, rhs: Stream_Video_Sfu_Event_AudioLayerSetting) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_AudioMediaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AudioMediaRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.channelCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelCount != 0 {
      try visitor.visitSingularInt32Field(value: self.channelCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_AudioMediaRequest, rhs: Stream_Video_Sfu_Event_AudioMediaRequest) -> Bool {
    if lhs.channelCount != rhs.channelCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_AudioSender: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AudioSender"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "media_request"),
    2: .same(proto: "codec"),
    3: .same(proto: "layers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mediaRequest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._codec) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.layers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mediaRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._codec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_AudioSender, rhs: Stream_Video_Sfu_Event_AudioSender) -> Bool {
    if lhs._mediaRequest != rhs._mediaRequest {return false}
    if lhs._codec != rhs._codec {return false}
    if lhs.layers != rhs.layers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_VideoMediaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoMediaRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ideal_height"),
    2: .standard(proto: "ideal_width"),
    3: .standard(proto: "ideal_frame_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.idealHeight) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.idealWidth) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.idealFrameRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.idealHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.idealHeight, fieldNumber: 1)
    }
    if self.idealWidth != 0 {
      try visitor.visitSingularInt32Field(value: self.idealWidth, fieldNumber: 2)
    }
    if self.idealFrameRate != 0 {
      try visitor.visitSingularInt32Field(value: self.idealFrameRate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_VideoMediaRequest, rhs: Stream_Video_Sfu_Event_VideoMediaRequest) -> Bool {
    if lhs.idealHeight != rhs.idealHeight {return false}
    if lhs.idealWidth != rhs.idealWidth {return false}
    if lhs.idealFrameRate != rhs.idealFrameRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_VideoLayerSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoLayerSetting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "active"),
    3: .standard(proto: "max_bitrate"),
    4: .standard(proto: "scale_resolution_down_by"),
    5: .same(proto: "priority"),
    6: .same(proto: "codec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxBitrate) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.scaleResolutionDownBy) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.priority) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._codec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 2)
    }
    if self.maxBitrate != 0 {
      try visitor.visitSingularInt32Field(value: self.maxBitrate, fieldNumber: 3)
    }
    if self.scaleResolutionDownBy != 0 {
      try visitor.visitSingularFloatField(value: self.scaleResolutionDownBy, fieldNumber: 4)
    }
    if self.priority != .highUnspecified {
      try visitor.visitSingularEnumField(value: self.priority, fieldNumber: 5)
    }
    try { if let v = self._codec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_VideoLayerSetting, rhs: Stream_Video_Sfu_Event_VideoLayerSetting) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.active != rhs.active {return false}
    if lhs.maxBitrate != rhs.maxBitrate {return false}
    if lhs.scaleResolutionDownBy != rhs.scaleResolutionDownBy {return false}
    if lhs.priority != rhs.priority {return false}
    if lhs._codec != rhs._codec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_VideoLayerSetting.Priority: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRIORITY_HIGH_UNSPECIFIED"),
    1: .same(proto: "PRIORITY_LOW"),
    2: .same(proto: "PRIORITY_MEDIUM"),
    3: .same(proto: "PRIORITY_VERY_LOW"),
  ]
}

extension Stream_Video_Sfu_Event_VideoSender: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoSender"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "media_request"),
    2: .same(proto: "codec"),
    3: .same(proto: "layers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mediaRequest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._codec) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.layers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mediaRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._codec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_VideoSender, rhs: Stream_Video_Sfu_Event_VideoSender) -> Bool {
    if lhs._mediaRequest != rhs._mediaRequest {return false}
    if lhs._codec != rhs._codec {return false}
    if lhs.layers != rhs.layers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stream_Video_Sfu_Event_ChangePublishQuality: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangePublishQuality"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_senders"),
    2: .standard(proto: "video_senders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.audioSenders) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.videoSenders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.audioSenders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.audioSenders, fieldNumber: 1)
    }
    if !self.videoSenders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.videoSenders, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Stream_Video_Sfu_Event_ChangePublishQuality, rhs: Stream_Video_Sfu_Event_ChangePublishQuality) -> Bool {
    if lhs.audioSenders != rhs.audioSenders {return false}
    if lhs.videoSenders != rhs.videoSenders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
