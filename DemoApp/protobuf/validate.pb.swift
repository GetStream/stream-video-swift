// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: validate/validate.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// DO NOT EDIT!
/// Embedded from https://github.com/GetStream/protoc-gen-validate/blob/main/validate/validate.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// WellKnownRegex contain some well-known patterns.
enum Validate_KnownRegex: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0

  /// HTTP header name as defined by RFC 7230.
  case httpHeaderName // = 1

  /// HTTP header value as defined by RFC 7230.
  case httpHeaderValue // = 2

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .httpHeaderName
    case 2: self = .httpHeaderValue
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .httpHeaderName: return 1
    case .httpHeaderValue: return 2
    }
  }

}

#if swift(>=4.2)

extension Validate_KnownRegex: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// FieldRules encapsulates the rules for each type of field. Depending on the
/// field, the correct set should be used to ensure proper validations.
struct Validate_FieldRules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: Validate_MessageRules {
    get {return _storage._message ?? Validate_MessageRules()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var type: OneOf_Type? {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// Scalar Field Types
  var float: Validate_FloatRules {
    get {
      if case .float(let v)? = _storage._type {return v}
      return Validate_FloatRules()
    }
    set {_uniqueStorage()._type = .float(newValue)}
  }

  var double: Validate_DoubleRules {
    get {
      if case .double(let v)? = _storage._type {return v}
      return Validate_DoubleRules()
    }
    set {_uniqueStorage()._type = .double(newValue)}
  }

  var int32: Validate_Int32Rules {
    get {
      if case .int32(let v)? = _storage._type {return v}
      return Validate_Int32Rules()
    }
    set {_uniqueStorage()._type = .int32(newValue)}
  }

  var int64: Validate_Int64Rules {
    get {
      if case .int64(let v)? = _storage._type {return v}
      return Validate_Int64Rules()
    }
    set {_uniqueStorage()._type = .int64(newValue)}
  }

  var uint32: Validate_UInt32Rules {
    get {
      if case .uint32(let v)? = _storage._type {return v}
      return Validate_UInt32Rules()
    }
    set {_uniqueStorage()._type = .uint32(newValue)}
  }

  var uint64: Validate_UInt64Rules {
    get {
      if case .uint64(let v)? = _storage._type {return v}
      return Validate_UInt64Rules()
    }
    set {_uniqueStorage()._type = .uint64(newValue)}
  }

  var sint32: Validate_SInt32Rules {
    get {
      if case .sint32(let v)? = _storage._type {return v}
      return Validate_SInt32Rules()
    }
    set {_uniqueStorage()._type = .sint32(newValue)}
  }

  var sint64: Validate_SInt64Rules {
    get {
      if case .sint64(let v)? = _storage._type {return v}
      return Validate_SInt64Rules()
    }
    set {_uniqueStorage()._type = .sint64(newValue)}
  }

  var fixed32: Validate_Fixed32Rules {
    get {
      if case .fixed32(let v)? = _storage._type {return v}
      return Validate_Fixed32Rules()
    }
    set {_uniqueStorage()._type = .fixed32(newValue)}
  }

  var fixed64: Validate_Fixed64Rules {
    get {
      if case .fixed64(let v)? = _storage._type {return v}
      return Validate_Fixed64Rules()
    }
    set {_uniqueStorage()._type = .fixed64(newValue)}
  }

  var sfixed32: Validate_SFixed32Rules {
    get {
      if case .sfixed32(let v)? = _storage._type {return v}
      return Validate_SFixed32Rules()
    }
    set {_uniqueStorage()._type = .sfixed32(newValue)}
  }

  var sfixed64: Validate_SFixed64Rules {
    get {
      if case .sfixed64(let v)? = _storage._type {return v}
      return Validate_SFixed64Rules()
    }
    set {_uniqueStorage()._type = .sfixed64(newValue)}
  }

  var bool: Validate_BoolRules {
    get {
      if case .bool(let v)? = _storage._type {return v}
      return Validate_BoolRules()
    }
    set {_uniqueStorage()._type = .bool(newValue)}
  }

  var string: Validate_StringRules {
    get {
      if case .string(let v)? = _storage._type {return v}
      return Validate_StringRules()
    }
    set {_uniqueStorage()._type = .string(newValue)}
  }

  var bytes: Validate_BytesRules {
    get {
      if case .bytes(let v)? = _storage._type {return v}
      return Validate_BytesRules()
    }
    set {_uniqueStorage()._type = .bytes(newValue)}
  }

  /// Complex Field Types
  var `enum`: Validate_EnumRules {
    get {
      if case .enum(let v)? = _storage._type {return v}
      return Validate_EnumRules()
    }
    set {_uniqueStorage()._type = .enum(newValue)}
  }

  var repeated: Validate_RepeatedRules {
    get {
      if case .repeated(let v)? = _storage._type {return v}
      return Validate_RepeatedRules()
    }
    set {_uniqueStorage()._type = .repeated(newValue)}
  }

  var map: Validate_MapRules {
    get {
      if case .map(let v)? = _storage._type {return v}
      return Validate_MapRules()
    }
    set {_uniqueStorage()._type = .map(newValue)}
  }

  /// Well-Known Field Types
  var any: Validate_AnyRules {
    get {
      if case .any(let v)? = _storage._type {return v}
      return Validate_AnyRules()
    }
    set {_uniqueStorage()._type = .any(newValue)}
  }

  var duration: Validate_DurationRules {
    get {
      if case .duration(let v)? = _storage._type {return v}
      return Validate_DurationRules()
    }
    set {_uniqueStorage()._type = .duration(newValue)}
  }

  var timestamp: Validate_TimestampRules {
    get {
      if case .timestamp(let v)? = _storage._type {return v}
      return Validate_TimestampRules()
    }
    set {_uniqueStorage()._type = .timestamp(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    /// Scalar Field Types
    case float(Validate_FloatRules)
    case double(Validate_DoubleRules)
    case int32(Validate_Int32Rules)
    case int64(Validate_Int64Rules)
    case uint32(Validate_UInt32Rules)
    case uint64(Validate_UInt64Rules)
    case sint32(Validate_SInt32Rules)
    case sint64(Validate_SInt64Rules)
    case fixed32(Validate_Fixed32Rules)
    case fixed64(Validate_Fixed64Rules)
    case sfixed32(Validate_SFixed32Rules)
    case sfixed64(Validate_SFixed64Rules)
    case bool(Validate_BoolRules)
    case string(Validate_StringRules)
    case bytes(Validate_BytesRules)
    /// Complex Field Types
    case `enum`(Validate_EnumRules)
    case repeated(Validate_RepeatedRules)
    case map(Validate_MapRules)
    /// Well-Known Field Types
    case any(Validate_AnyRules)
    case duration(Validate_DurationRules)
    case timestamp(Validate_TimestampRules)

  #if !swift(>=4.1)
    static func ==(lhs: Validate_FieldRules.OneOf_Type, rhs: Validate_FieldRules.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.float, .float): return {
        guard case .float(let l) = lhs, case .float(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.double, .double): return {
        guard case .double(let l) = lhs, case .double(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.int32, .int32): return {
        guard case .int32(let l) = lhs, case .int32(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.int64, .int64): return {
        guard case .int64(let l) = lhs, case .int64(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uint32, .uint32): return {
        guard case .uint32(let l) = lhs, case .uint32(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uint64, .uint64): return {
        guard case .uint64(let l) = lhs, case .uint64(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sint32, .sint32): return {
        guard case .sint32(let l) = lhs, case .sint32(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sint64, .sint64): return {
        guard case .sint64(let l) = lhs, case .sint64(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fixed32, .fixed32): return {
        guard case .fixed32(let l) = lhs, case .fixed32(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fixed64, .fixed64): return {
        guard case .fixed64(let l) = lhs, case .fixed64(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sfixed32, .sfixed32): return {
        guard case .sfixed32(let l) = lhs, case .sfixed32(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sfixed64, .sfixed64): return {
        guard case .sfixed64(let l) = lhs, case .sfixed64(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bool, .bool): return {
        guard case .bool(let l) = lhs, case .bool(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.string, .string): return {
        guard case .string(let l) = lhs, case .string(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bytes, .bytes): return {
        guard case .bytes(let l) = lhs, case .bytes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.enum, .enum): return {
        guard case .enum(let l) = lhs, case .enum(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.repeated, .repeated): return {
        guard case .repeated(let l) = lhs, case .repeated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.map, .map): return {
        guard case .map(let l) = lhs, case .map(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.any, .any): return {
        guard case .any(let l) = lhs, case .any(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.duration, .duration): return {
        guard case .duration(let l) = lhs, case .duration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timestamp, .timestamp): return {
        guard case .timestamp(let l) = lhs, case .timestamp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// FloatRules describes the constraints applied to `float` values
struct Validate_FloatRules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Const specifies that this field must be exactly the specified value
  var const: Float {
    get {return _const ?? 0}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  /// Lt specifies that this field must be less than the specified value,
  /// exclusive
  var lt: Float {
    get {return _lt ?? 0}
    set {_lt = newValue}
  }
  /// Returns true if `lt` has been explicitly set.
  var hasLt: Bool {return self._lt != nil}
  /// Clears the value of `lt`. Subsequent reads from it will return its default value.
  mutating func clearLt() {self._lt = nil}

  /// Lte specifies that this field must be less than or equal to the
  /// specified value, inclusive
  var lte: Float {
    get {return _lte ?? 0}
    set {_lte = newValue}
  }
  /// Returns true if `lte` has been explicitly set.
  var hasLte: Bool {return self._lte != nil}
  /// Clears the value of `lte`. Subsequent reads from it will return its default value.
  mutating func clearLte() {self._lte = nil}

  /// Gt specifies that this field must be greater than the specified value,
  /// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
  /// range is reversed.
  var gt: Float {
    get {return _gt ?? 0}
    set {_gt = newValue}
  }
  /// Returns true if `gt` has been explicitly set.
  var hasGt: Bool {return self._gt != nil}
  /// Clears the value of `gt`. Subsequent reads from it will return its default value.
  mutating func clearGt() {self._gt = nil}

  /// Gte specifies that this field must be greater than or equal to the
  /// specified value, inclusive. If the value of Gte is larger than a
  /// specified Lt or Lte, the range is reversed.
  var gte: Float {
    get {return _gte ?? 0}
    set {_gte = newValue}
  }
  /// Returns true if `gte` has been explicitly set.
  var hasGte: Bool {return self._gte != nil}
  /// Clears the value of `gte`. Subsequent reads from it will return its default value.
  mutating func clearGte() {self._gte = nil}

  /// In specifies that this field must be equal to one of the specified
  /// values
  var `in`: [Float] = []

  /// NotIn specifies that this field cannot be equal to one of the specified
  /// values
  var notIn: [Float] = []

  /// IgnoreEmpty specifies that the validation rules of this field should be
  /// evaluated only if the field is not empty
  var ignoreEmpty: Bool {
    get {return _ignoreEmpty ?? false}
    set {_ignoreEmpty = newValue}
  }
  /// Returns true if `ignoreEmpty` has been explicitly set.
  var hasIgnoreEmpty: Bool {return self._ignoreEmpty != nil}
  /// Clears the value of `ignoreEmpty`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreEmpty() {self._ignoreEmpty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _const: Float? = nil
  fileprivate var _lt: Float? = nil
  fileprivate var _lte: Float? = nil
  fileprivate var _gt: Float? = nil
  fileprivate var _gte: Float? = nil
  fileprivate var _ignoreEmpty: Bool? = nil
}

/// DoubleRules describes the constraints applied to `double` values
struct Validate_DoubleRules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Const specifies that this field must be exactly the specified value
  var const: Double {
    get {return _const ?? 0}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  /// Lt specifies that this field must be less than the specified value,
  /// exclusive
  var lt: Double {
    get {return _lt ?? 0}
    set {_lt = newValue}
  }
  /// Returns true if `lt` has been explicitly set.
  var hasLt: Bool {return self._lt != nil}
  /// Clears the value of `lt`. Subsequent reads from it will return its default value.
  mutating func clearLt() {self._lt = nil}

  /// Lte specifies that this field must be less than or equal to the
  /// specified value, inclusive
  var lte: Double {
    get {return _lte ?? 0}
    set {_lte = newValue}
  }
  /// Returns true if `lte` has been explicitly set.
  var hasLte: Bool {return self._lte != nil}
  /// Clears the value of `lte`. Subsequent reads from it will return its default value.
  mutating func clearLte() {self._lte = nil}

  /// Gt specifies that this field must be greater than the specified value,
  /// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
  /// range is reversed.
  var gt: Double {
    get {return _gt ?? 0}
    set {_gt = newValue}
  }
  /// Returns true if `gt` has been explicitly set.
  var hasGt: Bool {return self._gt != nil}
  /// Clears the value of `gt`. Subsequent reads from it will return its default value.
  mutating func clearGt() {self._gt = nil}

  /// Gte specifies that this field must be greater than or equal to the
  /// specified value, inclusive. If the value of Gte is larger than a
  /// specified Lt or Lte, the range is reversed.
  var gte: Double {
    get {return _gte ?? 0}
    set {_gte = newValue}
  }
  /// Returns true if `gte` has been explicitly set.
  var hasGte: Bool {return self._gte != nil}
  /// Clears the value of `gte`. Subsequent reads from it will return its default value.
  mutating func clearGte() {self._gte = nil}

  /// In specifies that this field must be equal to one of the specified
  /// values
  var `in`: [Double] = []

  /// NotIn specifies that this field cannot be equal to one of the specified
  /// values
  var notIn: [Double] = []

  /// IgnoreEmpty specifies that the validation rules of this field should be
  /// evaluated only if the field is not empty
  var ignoreEmpty: Bool {
    get {return _ignoreEmpty ?? false}
    set {_ignoreEmpty = newValue}
  }
  /// Returns true if `ignoreEmpty` has been explicitly set.
  var hasIgnoreEmpty: Bool {return self._ignoreEmpty != nil}
  /// Clears the value of `ignoreEmpty`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreEmpty() {self._ignoreEmpty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _const: Double? = nil
  fileprivate var _lt: Double? = nil
  fileprivate var _lte: Double? = nil
  fileprivate var _gt: Double? = nil
  fileprivate var _gte: Double? = nil
  fileprivate var _ignoreEmpty: Bool? = nil
}

/// Int32Rules describes the constraints applied to `int32` values
struct Validate_Int32Rules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Const specifies that this field must be exactly the specified value
  var const: Int32 {
    get {return _const ?? 0}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  /// Lt specifies that this field must be less than the specified value,
  /// exclusive
  var lt: Int32 {
    get {return _lt ?? 0}
    set {_lt = newValue}
  }
  /// Returns true if `lt` has been explicitly set.
  var hasLt: Bool {return self._lt != nil}
  /// Clears the value of `lt`. Subsequent reads from it will return its default value.
  mutating func clearLt() {self._lt = nil}

  /// Lte specifies that this field must be less than or equal to the
  /// specified value, inclusive
  var lte: Int32 {
    get {return _lte ?? 0}
    set {_lte = newValue}
  }
  /// Returns true if `lte` has been explicitly set.
  var hasLte: Bool {return self._lte != nil}
  /// Clears the value of `lte`. Subsequent reads from it will return its default value.
  mutating func clearLte() {self._lte = nil}

  /// Gt specifies that this field must be greater than the specified value,
  /// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
  /// range is reversed.
  var gt: Int32 {
    get {return _gt ?? 0}
    set {_gt = newValue}
  }
  /// Returns true if `gt` has been explicitly set.
  var hasGt: Bool {return self._gt != nil}
  /// Clears the value of `gt`. Subsequent reads from it will return its default value.
  mutating func clearGt() {self._gt = nil}

  /// Gte specifies that this field must be greater than or equal to the
  /// specified value, inclusive. If the value of Gte is larger than a
  /// specified Lt or Lte, the range is reversed.
  var gte: Int32 {
    get {return _gte ?? 0}
    set {_gte = newValue}
  }
  /// Returns true if `gte` has been explicitly set.
  var hasGte: Bool {return self._gte != nil}
  /// Clears the value of `gte`. Subsequent reads from it will return its default value.
  mutating func clearGte() {self._gte = nil}

  /// In specifies that this field must be equal to one of the specified
  /// values
  var `in`: [Int32] = []

  /// NotIn specifies that this field cannot be equal to one of the specified
  /// values
  var notIn: [Int32] = []

  /// IgnoreEmpty specifies that the validation rules of this field should be
  /// evaluated only if the field is not empty
  var ignoreEmpty: Bool {
    get {return _ignoreEmpty ?? false}
    set {_ignoreEmpty = newValue}
  }
  /// Returns true if `ignoreEmpty` has been explicitly set.
  var hasIgnoreEmpty: Bool {return self._ignoreEmpty != nil}
  /// Clears the value of `ignoreEmpty`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreEmpty() {self._ignoreEmpty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _const: Int32? = nil
  fileprivate var _lt: Int32? = nil
  fileprivate var _lte: Int32? = nil
  fileprivate var _gt: Int32? = nil
  fileprivate var _gte: Int32? = nil
  fileprivate var _ignoreEmpty: Bool? = nil
}

/// Int64Rules describes the constraints applied to `int64` values
struct Validate_Int64Rules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Const specifies that this field must be exactly the specified value
  var const: Int64 {
    get {return _const ?? 0}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  /// Lt specifies that this field must be less than the specified value,
  /// exclusive
  var lt: Int64 {
    get {return _lt ?? 0}
    set {_lt = newValue}
  }
  /// Returns true if `lt` has been explicitly set.
  var hasLt: Bool {return self._lt != nil}
  /// Clears the value of `lt`. Subsequent reads from it will return its default value.
  mutating func clearLt() {self._lt = nil}

  /// Lte specifies that this field must be less than or equal to the
  /// specified value, inclusive
  var lte: Int64 {
    get {return _lte ?? 0}
    set {_lte = newValue}
  }
  /// Returns true if `lte` has been explicitly set.
  var hasLte: Bool {return self._lte != nil}
  /// Clears the value of `lte`. Subsequent reads from it will return its default value.
  mutating func clearLte() {self._lte = nil}

  /// Gt specifies that this field must be greater than the specified value,
  /// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
  /// range is reversed.
  var gt: Int64 {
    get {return _gt ?? 0}
    set {_gt = newValue}
  }
  /// Returns true if `gt` has been explicitly set.
  var hasGt: Bool {return self._gt != nil}
  /// Clears the value of `gt`. Subsequent reads from it will return its default value.
  mutating func clearGt() {self._gt = nil}

  /// Gte specifies that this field must be greater than or equal to the
  /// specified value, inclusive. If the value of Gte is larger than a
  /// specified Lt or Lte, the range is reversed.
  var gte: Int64 {
    get {return _gte ?? 0}
    set {_gte = newValue}
  }
  /// Returns true if `gte` has been explicitly set.
  var hasGte: Bool {return self._gte != nil}
  /// Clears the value of `gte`. Subsequent reads from it will return its default value.
  mutating func clearGte() {self._gte = nil}

  /// In specifies that this field must be equal to one of the specified
  /// values
  var `in`: [Int64] = []

  /// NotIn specifies that this field cannot be equal to one of the specified
  /// values
  var notIn: [Int64] = []

  /// IgnoreEmpty specifies that the validation rules of this field should be
  /// evaluated only if the field is not empty
  var ignoreEmpty: Bool {
    get {return _ignoreEmpty ?? false}
    set {_ignoreEmpty = newValue}
  }
  /// Returns true if `ignoreEmpty` has been explicitly set.
  var hasIgnoreEmpty: Bool {return self._ignoreEmpty != nil}
  /// Clears the value of `ignoreEmpty`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreEmpty() {self._ignoreEmpty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _const: Int64? = nil
  fileprivate var _lt: Int64? = nil
  fileprivate var _lte: Int64? = nil
  fileprivate var _gt: Int64? = nil
  fileprivate var _gte: Int64? = nil
  fileprivate var _ignoreEmpty: Bool? = nil
}

/// UInt32Rules describes the constraints applied to `uint32` values
struct Validate_UInt32Rules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Const specifies that this field must be exactly the specified value
  var const: UInt32 {
    get {return _const ?? 0}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  /// Lt specifies that this field must be less than the specified value,
  /// exclusive
  var lt: UInt32 {
    get {return _lt ?? 0}
    set {_lt = newValue}
  }
  /// Returns true if `lt` has been explicitly set.
  var hasLt: Bool {return self._lt != nil}
  /// Clears the value of `lt`. Subsequent reads from it will return its default value.
  mutating func clearLt() {self._lt = nil}

  /// Lte specifies that this field must be less than or equal to the
  /// specified value, inclusive
  var lte: UInt32 {
    get {return _lte ?? 0}
    set {_lte = newValue}
  }
  /// Returns true if `lte` has been explicitly set.
  var hasLte: Bool {return self._lte != nil}
  /// Clears the value of `lte`. Subsequent reads from it will return its default value.
  mutating func clearLte() {self._lte = nil}

  /// Gt specifies that this field must be greater than the specified value,
  /// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
  /// range is reversed.
  var gt: UInt32 {
    get {return _gt ?? 0}
    set {_gt = newValue}
  }
  /// Returns true if `gt` has been explicitly set.
  var hasGt: Bool {return self._gt != nil}
  /// Clears the value of `gt`. Subsequent reads from it will return its default value.
  mutating func clearGt() {self._gt = nil}

  /// Gte specifies that this field must be greater than or equal to the
  /// specified value, inclusive. If the value of Gte is larger than a
  /// specified Lt or Lte, the range is reversed.
  var gte: UInt32 {
    get {return _gte ?? 0}
    set {_gte = newValue}
  }
  /// Returns true if `gte` has been explicitly set.
  var hasGte: Bool {return self._gte != nil}
  /// Clears the value of `gte`. Subsequent reads from it will return its default value.
  mutating func clearGte() {self._gte = nil}

  /// In specifies that this field must be equal to one of the specified
  /// values
  var `in`: [UInt32] = []

  /// NotIn specifies that this field cannot be equal to one of the specified
  /// values
  var notIn: [UInt32] = []

  /// IgnoreEmpty specifies that the validation rules of this field should be
  /// evaluated only if the field is not empty
  var ignoreEmpty: Bool {
    get {return _ignoreEmpty ?? false}
    set {_ignoreEmpty = newValue}
  }
  /// Returns true if `ignoreEmpty` has been explicitly set.
  var hasIgnoreEmpty: Bool {return self._ignoreEmpty != nil}
  /// Clears the value of `ignoreEmpty`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreEmpty() {self._ignoreEmpty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _const: UInt32? = nil
  fileprivate var _lt: UInt32? = nil
  fileprivate var _lte: UInt32? = nil
  fileprivate var _gt: UInt32? = nil
  fileprivate var _gte: UInt32? = nil
  fileprivate var _ignoreEmpty: Bool? = nil
}

/// UInt64Rules describes the constraints applied to `uint64` values
struct Validate_UInt64Rules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Const specifies that this field must be exactly the specified value
  var const: UInt64 {
    get {return _const ?? 0}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  /// Lt specifies that this field must be less than the specified value,
  /// exclusive
  var lt: UInt64 {
    get {return _lt ?? 0}
    set {_lt = newValue}
  }
  /// Returns true if `lt` has been explicitly set.
  var hasLt: Bool {return self._lt != nil}
  /// Clears the value of `lt`. Subsequent reads from it will return its default value.
  mutating func clearLt() {self._lt = nil}

  /// Lte specifies that this field must be less than or equal to the
  /// specified value, inclusive
  var lte: UInt64 {
    get {return _lte ?? 0}
    set {_lte = newValue}
  }
  /// Returns true if `lte` has been explicitly set.
  var hasLte: Bool {return self._lte != nil}
  /// Clears the value of `lte`. Subsequent reads from it will return its default value.
  mutating func clearLte() {self._lte = nil}

  /// Gt specifies that this field must be greater than the specified value,
  /// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
  /// range is reversed.
  var gt: UInt64 {
    get {return _gt ?? 0}
    set {_gt = newValue}
  }
  /// Returns true if `gt` has been explicitly set.
  var hasGt: Bool {return self._gt != nil}
  /// Clears the value of `gt`. Subsequent reads from it will return its default value.
  mutating func clearGt() {self._gt = nil}

  /// Gte specifies that this field must be greater than or equal to the
  /// specified value, inclusive. If the value of Gte is larger than a
  /// specified Lt or Lte, the range is reversed.
  var gte: UInt64 {
    get {return _gte ?? 0}
    set {_gte = newValue}
  }
  /// Returns true if `gte` has been explicitly set.
  var hasGte: Bool {return self._gte != nil}
  /// Clears the value of `gte`. Subsequent reads from it will return its default value.
  mutating func clearGte() {self._gte = nil}

  /// In specifies that this field must be equal to one of the specified
  /// values
  var `in`: [UInt64] = []

  /// NotIn specifies that this field cannot be equal to one of the specified
  /// values
  var notIn: [UInt64] = []

  /// IgnoreEmpty specifies that the validation rules of this field should be
  /// evaluated only if the field is not empty
  var ignoreEmpty: Bool {
    get {return _ignoreEmpty ?? false}
    set {_ignoreEmpty = newValue}
  }
  /// Returns true if `ignoreEmpty` has been explicitly set.
  var hasIgnoreEmpty: Bool {return self._ignoreEmpty != nil}
  /// Clears the value of `ignoreEmpty`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreEmpty() {self._ignoreEmpty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _const: UInt64? = nil
  fileprivate var _lt: UInt64? = nil
  fileprivate var _lte: UInt64? = nil
  fileprivate var _gt: UInt64? = nil
  fileprivate var _gte: UInt64? = nil
  fileprivate var _ignoreEmpty: Bool? = nil
}

/// SInt32Rules describes the constraints applied to `sint32` values
struct Validate_SInt32Rules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Const specifies that this field must be exactly the specified value
  var const: Int32 {
    get {return _const ?? 0}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  /// Lt specifies that this field must be less than the specified value,
  /// exclusive
  var lt: Int32 {
    get {return _lt ?? 0}
    set {_lt = newValue}
  }
  /// Returns true if `lt` has been explicitly set.
  var hasLt: Bool {return self._lt != nil}
  /// Clears the value of `lt`. Subsequent reads from it will return its default value.
  mutating func clearLt() {self._lt = nil}

  /// Lte specifies that this field must be less than or equal to the
  /// specified value, inclusive
  var lte: Int32 {
    get {return _lte ?? 0}
    set {_lte = newValue}
  }
  /// Returns true if `lte` has been explicitly set.
  var hasLte: Bool {return self._lte != nil}
  /// Clears the value of `lte`. Subsequent reads from it will return its default value.
  mutating func clearLte() {self._lte = nil}

  /// Gt specifies that this field must be greater than the specified value,
  /// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
  /// range is reversed.
  var gt: Int32 {
    get {return _gt ?? 0}
    set {_gt = newValue}
  }
  /// Returns true if `gt` has been explicitly set.
  var hasGt: Bool {return self._gt != nil}
  /// Clears the value of `gt`. Subsequent reads from it will return its default value.
  mutating func clearGt() {self._gt = nil}

  /// Gte specifies that this field must be greater than or equal to the
  /// specified value, inclusive. If the value of Gte is larger than a
  /// specified Lt or Lte, the range is reversed.
  var gte: Int32 {
    get {return _gte ?? 0}
    set {_gte = newValue}
  }
  /// Returns true if `gte` has been explicitly set.
  var hasGte: Bool {return self._gte != nil}
  /// Clears the value of `gte`. Subsequent reads from it will return its default value.
  mutating func clearGte() {self._gte = nil}

  /// In specifies that this field must be equal to one of the specified
  /// values
  var `in`: [Int32] = []

  /// NotIn specifies that this field cannot be equal to one of the specified
  /// values
  var notIn: [Int32] = []

  /// IgnoreEmpty specifies that the validation rules of this field should be
  /// evaluated only if the field is not empty
  var ignoreEmpty: Bool {
    get {return _ignoreEmpty ?? false}
    set {_ignoreEmpty = newValue}
  }
  /// Returns true if `ignoreEmpty` has been explicitly set.
  var hasIgnoreEmpty: Bool {return self._ignoreEmpty != nil}
  /// Clears the value of `ignoreEmpty`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreEmpty() {self._ignoreEmpty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _const: Int32? = nil
  fileprivate var _lt: Int32? = nil
  fileprivate var _lte: Int32? = nil
  fileprivate var _gt: Int32? = nil
  fileprivate var _gte: Int32? = nil
  fileprivate var _ignoreEmpty: Bool? = nil
}

/// SInt64Rules describes the constraints applied to `sint64` values
struct Validate_SInt64Rules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Const specifies that this field must be exactly the specified value
  var const: Int64 {
    get {return _const ?? 0}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  /// Lt specifies that this field must be less than the specified value,
  /// exclusive
  var lt: Int64 {
    get {return _lt ?? 0}
    set {_lt = newValue}
  }
  /// Returns true if `lt` has been explicitly set.
  var hasLt: Bool {return self._lt != nil}
  /// Clears the value of `lt`. Subsequent reads from it will return its default value.
  mutating func clearLt() {self._lt = nil}

  /// Lte specifies that this field must be less than or equal to the
  /// specified value, inclusive
  var lte: Int64 {
    get {return _lte ?? 0}
    set {_lte = newValue}
  }
  /// Returns true if `lte` has been explicitly set.
  var hasLte: Bool {return self._lte != nil}
  /// Clears the value of `lte`. Subsequent reads from it will return its default value.
  mutating func clearLte() {self._lte = nil}

  /// Gt specifies that this field must be greater than the specified value,
  /// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
  /// range is reversed.
  var gt: Int64 {
    get {return _gt ?? 0}
    set {_gt = newValue}
  }
  /// Returns true if `gt` has been explicitly set.
  var hasGt: Bool {return self._gt != nil}
  /// Clears the value of `gt`. Subsequent reads from it will return its default value.
  mutating func clearGt() {self._gt = nil}

  /// Gte specifies that this field must be greater than or equal to the
  /// specified value, inclusive. If the value of Gte is larger than a
  /// specified Lt or Lte, the range is reversed.
  var gte: Int64 {
    get {return _gte ?? 0}
    set {_gte = newValue}
  }
  /// Returns true if `gte` has been explicitly set.
  var hasGte: Bool {return self._gte != nil}
  /// Clears the value of `gte`. Subsequent reads from it will return its default value.
  mutating func clearGte() {self._gte = nil}

  /// In specifies that this field must be equal to one of the specified
  /// values
  var `in`: [Int64] = []

  /// NotIn specifies that this field cannot be equal to one of the specified
  /// values
  var notIn: [Int64] = []

  /// IgnoreEmpty specifies that the validation rules of this field should be
  /// evaluated only if the field is not empty
  var ignoreEmpty: Bool {
    get {return _ignoreEmpty ?? false}
    set {_ignoreEmpty = newValue}
  }
  /// Returns true if `ignoreEmpty` has been explicitly set.
  var hasIgnoreEmpty: Bool {return self._ignoreEmpty != nil}
  /// Clears the value of `ignoreEmpty`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreEmpty() {self._ignoreEmpty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _const: Int64? = nil
  fileprivate var _lt: Int64? = nil
  fileprivate var _lte: Int64? = nil
  fileprivate var _gt: Int64? = nil
  fileprivate var _gte: Int64? = nil
  fileprivate var _ignoreEmpty: Bool? = nil
}

/// Fixed32Rules describes the constraints applied to `fixed32` values
struct Validate_Fixed32Rules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Const specifies that this field must be exactly the specified value
  var const: UInt32 {
    get {return _const ?? 0}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  /// Lt specifies that this field must be less than the specified value,
  /// exclusive
  var lt: UInt32 {
    get {return _lt ?? 0}
    set {_lt = newValue}
  }
  /// Returns true if `lt` has been explicitly set.
  var hasLt: Bool {return self._lt != nil}
  /// Clears the value of `lt`. Subsequent reads from it will return its default value.
  mutating func clearLt() {self._lt = nil}

  /// Lte specifies that this field must be less than or equal to the
  /// specified value, inclusive
  var lte: UInt32 {
    get {return _lte ?? 0}
    set {_lte = newValue}
  }
  /// Returns true if `lte` has been explicitly set.
  var hasLte: Bool {return self._lte != nil}
  /// Clears the value of `lte`. Subsequent reads from it will return its default value.
  mutating func clearLte() {self._lte = nil}

  /// Gt specifies that this field must be greater than the specified value,
  /// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
  /// range is reversed.
  var gt: UInt32 {
    get {return _gt ?? 0}
    set {_gt = newValue}
  }
  /// Returns true if `gt` has been explicitly set.
  var hasGt: Bool {return self._gt != nil}
  /// Clears the value of `gt`. Subsequent reads from it will return its default value.
  mutating func clearGt() {self._gt = nil}

  /// Gte specifies that this field must be greater than or equal to the
  /// specified value, inclusive. If the value of Gte is larger than a
  /// specified Lt or Lte, the range is reversed.
  var gte: UInt32 {
    get {return _gte ?? 0}
    set {_gte = newValue}
  }
  /// Returns true if `gte` has been explicitly set.
  var hasGte: Bool {return self._gte != nil}
  /// Clears the value of `gte`. Subsequent reads from it will return its default value.
  mutating func clearGte() {self._gte = nil}

  /// In specifies that this field must be equal to one of the specified
  /// values
  var `in`: [UInt32] = []

  /// NotIn specifies that this field cannot be equal to one of the specified
  /// values
  var notIn: [UInt32] = []

  /// IgnoreEmpty specifies that the validation rules of this field should be
  /// evaluated only if the field is not empty
  var ignoreEmpty: Bool {
    get {return _ignoreEmpty ?? false}
    set {_ignoreEmpty = newValue}
  }
  /// Returns true if `ignoreEmpty` has been explicitly set.
  var hasIgnoreEmpty: Bool {return self._ignoreEmpty != nil}
  /// Clears the value of `ignoreEmpty`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreEmpty() {self._ignoreEmpty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _const: UInt32? = nil
  fileprivate var _lt: UInt32? = nil
  fileprivate var _lte: UInt32? = nil
  fileprivate var _gt: UInt32? = nil
  fileprivate var _gte: UInt32? = nil
  fileprivate var _ignoreEmpty: Bool? = nil
}

/// Fixed64Rules describes the constraints applied to `fixed64` values
struct Validate_Fixed64Rules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Const specifies that this field must be exactly the specified value
  var const: UInt64 {
    get {return _const ?? 0}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  /// Lt specifies that this field must be less than the specified value,
  /// exclusive
  var lt: UInt64 {
    get {return _lt ?? 0}
    set {_lt = newValue}
  }
  /// Returns true if `lt` has been explicitly set.
  var hasLt: Bool {return self._lt != nil}
  /// Clears the value of `lt`. Subsequent reads from it will return its default value.
  mutating func clearLt() {self._lt = nil}

  /// Lte specifies that this field must be less than or equal to the
  /// specified value, inclusive
  var lte: UInt64 {
    get {return _lte ?? 0}
    set {_lte = newValue}
  }
  /// Returns true if `lte` has been explicitly set.
  var hasLte: Bool {return self._lte != nil}
  /// Clears the value of `lte`. Subsequent reads from it will return its default value.
  mutating func clearLte() {self._lte = nil}

  /// Gt specifies that this field must be greater than the specified value,
  /// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
  /// range is reversed.
  var gt: UInt64 {
    get {return _gt ?? 0}
    set {_gt = newValue}
  }
  /// Returns true if `gt` has been explicitly set.
  var hasGt: Bool {return self._gt != nil}
  /// Clears the value of `gt`. Subsequent reads from it will return its default value.
  mutating func clearGt() {self._gt = nil}

  /// Gte specifies that this field must be greater than or equal to the
  /// specified value, inclusive. If the value of Gte is larger than a
  /// specified Lt or Lte, the range is reversed.
  var gte: UInt64 {
    get {return _gte ?? 0}
    set {_gte = newValue}
  }
  /// Returns true if `gte` has been explicitly set.
  var hasGte: Bool {return self._gte != nil}
  /// Clears the value of `gte`. Subsequent reads from it will return its default value.
  mutating func clearGte() {self._gte = nil}

  /// In specifies that this field must be equal to one of the specified
  /// values
  var `in`: [UInt64] = []

  /// NotIn specifies that this field cannot be equal to one of the specified
  /// values
  var notIn: [UInt64] = []

  /// IgnoreEmpty specifies that the validation rules of this field should be
  /// evaluated only if the field is not empty
  var ignoreEmpty: Bool {
    get {return _ignoreEmpty ?? false}
    set {_ignoreEmpty = newValue}
  }
  /// Returns true if `ignoreEmpty` has been explicitly set.
  var hasIgnoreEmpty: Bool {return self._ignoreEmpty != nil}
  /// Clears the value of `ignoreEmpty`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreEmpty() {self._ignoreEmpty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _const: UInt64? = nil
  fileprivate var _lt: UInt64? = nil
  fileprivate var _lte: UInt64? = nil
  fileprivate var _gt: UInt64? = nil
  fileprivate var _gte: UInt64? = nil
  fileprivate var _ignoreEmpty: Bool? = nil
}

/// SFixed32Rules describes the constraints applied to `sfixed32` values
struct Validate_SFixed32Rules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Const specifies that this field must be exactly the specified value
  var const: Int32 {
    get {return _const ?? 0}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  /// Lt specifies that this field must be less than the specified value,
  /// exclusive
  var lt: Int32 {
    get {return _lt ?? 0}
    set {_lt = newValue}
  }
  /// Returns true if `lt` has been explicitly set.
  var hasLt: Bool {return self._lt != nil}
  /// Clears the value of `lt`. Subsequent reads from it will return its default value.
  mutating func clearLt() {self._lt = nil}

  /// Lte specifies that this field must be less than or equal to the
  /// specified value, inclusive
  var lte: Int32 {
    get {return _lte ?? 0}
    set {_lte = newValue}
  }
  /// Returns true if `lte` has been explicitly set.
  var hasLte: Bool {return self._lte != nil}
  /// Clears the value of `lte`. Subsequent reads from it will return its default value.
  mutating func clearLte() {self._lte = nil}

  /// Gt specifies that this field must be greater than the specified value,
  /// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
  /// range is reversed.
  var gt: Int32 {
    get {return _gt ?? 0}
    set {_gt = newValue}
  }
  /// Returns true if `gt` has been explicitly set.
  var hasGt: Bool {return self._gt != nil}
  /// Clears the value of `gt`. Subsequent reads from it will return its default value.
  mutating func clearGt() {self._gt = nil}

  /// Gte specifies that this field must be greater than or equal to the
  /// specified value, inclusive. If the value of Gte is larger than a
  /// specified Lt or Lte, the range is reversed.
  var gte: Int32 {
    get {return _gte ?? 0}
    set {_gte = newValue}
  }
  /// Returns true if `gte` has been explicitly set.
  var hasGte: Bool {return self._gte != nil}
  /// Clears the value of `gte`. Subsequent reads from it will return its default value.
  mutating func clearGte() {self._gte = nil}

  /// In specifies that this field must be equal to one of the specified
  /// values
  var `in`: [Int32] = []

  /// NotIn specifies that this field cannot be equal to one of the specified
  /// values
  var notIn: [Int32] = []

  /// IgnoreEmpty specifies that the validation rules of this field should be
  /// evaluated only if the field is not empty
  var ignoreEmpty: Bool {
    get {return _ignoreEmpty ?? false}
    set {_ignoreEmpty = newValue}
  }
  /// Returns true if `ignoreEmpty` has been explicitly set.
  var hasIgnoreEmpty: Bool {return self._ignoreEmpty != nil}
  /// Clears the value of `ignoreEmpty`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreEmpty() {self._ignoreEmpty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _const: Int32? = nil
  fileprivate var _lt: Int32? = nil
  fileprivate var _lte: Int32? = nil
  fileprivate var _gt: Int32? = nil
  fileprivate var _gte: Int32? = nil
  fileprivate var _ignoreEmpty: Bool? = nil
}

/// SFixed64Rules describes the constraints applied to `sfixed64` values
struct Validate_SFixed64Rules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Const specifies that this field must be exactly the specified value
  var const: Int64 {
    get {return _const ?? 0}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  /// Lt specifies that this field must be less than the specified value,
  /// exclusive
  var lt: Int64 {
    get {return _lt ?? 0}
    set {_lt = newValue}
  }
  /// Returns true if `lt` has been explicitly set.
  var hasLt: Bool {return self._lt != nil}
  /// Clears the value of `lt`. Subsequent reads from it will return its default value.
  mutating func clearLt() {self._lt = nil}

  /// Lte specifies that this field must be less than or equal to the
  /// specified value, inclusive
  var lte: Int64 {
    get {return _lte ?? 0}
    set {_lte = newValue}
  }
  /// Returns true if `lte` has been explicitly set.
  var hasLte: Bool {return self._lte != nil}
  /// Clears the value of `lte`. Subsequent reads from it will return its default value.
  mutating func clearLte() {self._lte = nil}

  /// Gt specifies that this field must be greater than the specified value,
  /// exclusive. If the value of Gt is larger than a specified Lt or Lte, the
  /// range is reversed.
  var gt: Int64 {
    get {return _gt ?? 0}
    set {_gt = newValue}
  }
  /// Returns true if `gt` has been explicitly set.
  var hasGt: Bool {return self._gt != nil}
  /// Clears the value of `gt`. Subsequent reads from it will return its default value.
  mutating func clearGt() {self._gt = nil}

  /// Gte specifies that this field must be greater than or equal to the
  /// specified value, inclusive. If the value of Gte is larger than a
  /// specified Lt or Lte, the range is reversed.
  var gte: Int64 {
    get {return _gte ?? 0}
    set {_gte = newValue}
  }
  /// Returns true if `gte` has been explicitly set.
  var hasGte: Bool {return self._gte != nil}
  /// Clears the value of `gte`. Subsequent reads from it will return its default value.
  mutating func clearGte() {self._gte = nil}

  /// In specifies that this field must be equal to one of the specified
  /// values
  var `in`: [Int64] = []

  /// NotIn specifies that this field cannot be equal to one of the specified
  /// values
  var notIn: [Int64] = []

  /// IgnoreEmpty specifies that the validation rules of this field should be
  /// evaluated only if the field is not empty
  var ignoreEmpty: Bool {
    get {return _ignoreEmpty ?? false}
    set {_ignoreEmpty = newValue}
  }
  /// Returns true if `ignoreEmpty` has been explicitly set.
  var hasIgnoreEmpty: Bool {return self._ignoreEmpty != nil}
  /// Clears the value of `ignoreEmpty`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreEmpty() {self._ignoreEmpty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _const: Int64? = nil
  fileprivate var _lt: Int64? = nil
  fileprivate var _lte: Int64? = nil
  fileprivate var _gt: Int64? = nil
  fileprivate var _gte: Int64? = nil
  fileprivate var _ignoreEmpty: Bool? = nil
}

/// BoolRules describes the constraints applied to `bool` values
struct Validate_BoolRules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Const specifies that this field must be exactly the specified value
  var const: Bool {
    get {return _const ?? false}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _const: Bool? = nil
}

/// StringRules describe the constraints applied to `string` values
struct Validate_StringRules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Const specifies that this field must be exactly the specified value
  var const: String {
    get {return _storage._const ?? String()}
    set {_uniqueStorage()._const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return _storage._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {_uniqueStorage()._const = nil}

  /// Len specifies that this field must be the specified number of
  /// characters (Unicode code points). Note that the number of
  /// characters may differ from the number of bytes in the string.
  var len: UInt64 {
    get {return _storage._len ?? 0}
    set {_uniqueStorage()._len = newValue}
  }
  /// Returns true if `len` has been explicitly set.
  var hasLen: Bool {return _storage._len != nil}
  /// Clears the value of `len`. Subsequent reads from it will return its default value.
  mutating func clearLen() {_uniqueStorage()._len = nil}

  /// MinLen specifies that this field must be the specified number of
  /// characters (Unicode code points) at a minimum. Note that the number of
  /// characters may differ from the number of bytes in the string.
  var minLen: UInt64 {
    get {return _storage._minLen ?? 0}
    set {_uniqueStorage()._minLen = newValue}
  }
  /// Returns true if `minLen` has been explicitly set.
  var hasMinLen: Bool {return _storage._minLen != nil}
  /// Clears the value of `minLen`. Subsequent reads from it will return its default value.
  mutating func clearMinLen() {_uniqueStorage()._minLen = nil}

  /// MaxLen specifies that this field must be the specified number of
  /// characters (Unicode code points) at a maximum. Note that the number of
  /// characters may differ from the number of bytes in the string.
  var maxLen: UInt64 {
    get {return _storage._maxLen ?? 0}
    set {_uniqueStorage()._maxLen = newValue}
  }
  /// Returns true if `maxLen` has been explicitly set.
  var hasMaxLen: Bool {return _storage._maxLen != nil}
  /// Clears the value of `maxLen`. Subsequent reads from it will return its default value.
  mutating func clearMaxLen() {_uniqueStorage()._maxLen = nil}

  /// LenBytes specifies that this field must be the specified number of bytes
  var lenBytes: UInt64 {
    get {return _storage._lenBytes ?? 0}
    set {_uniqueStorage()._lenBytes = newValue}
  }
  /// Returns true if `lenBytes` has been explicitly set.
  var hasLenBytes: Bool {return _storage._lenBytes != nil}
  /// Clears the value of `lenBytes`. Subsequent reads from it will return its default value.
  mutating func clearLenBytes() {_uniqueStorage()._lenBytes = nil}

  /// MinBytes specifies that this field must be the specified number of bytes
  /// at a minimum
  var minBytes: UInt64 {
    get {return _storage._minBytes ?? 0}
    set {_uniqueStorage()._minBytes = newValue}
  }
  /// Returns true if `minBytes` has been explicitly set.
  var hasMinBytes: Bool {return _storage._minBytes != nil}
  /// Clears the value of `minBytes`. Subsequent reads from it will return its default value.
  mutating func clearMinBytes() {_uniqueStorage()._minBytes = nil}

  /// MaxBytes specifies that this field must be the specified number of bytes
  /// at a maximum
  var maxBytes: UInt64 {
    get {return _storage._maxBytes ?? 0}
    set {_uniqueStorage()._maxBytes = newValue}
  }
  /// Returns true if `maxBytes` has been explicitly set.
  var hasMaxBytes: Bool {return _storage._maxBytes != nil}
  /// Clears the value of `maxBytes`. Subsequent reads from it will return its default value.
  mutating func clearMaxBytes() {_uniqueStorage()._maxBytes = nil}

  /// Pattern specifes that this field must match against the specified
  /// regular expression (RE2 syntax). The included expression should elide
  /// any delimiters.
  var pattern: String {
    get {return _storage._pattern ?? String()}
    set {_uniqueStorage()._pattern = newValue}
  }
  /// Returns true if `pattern` has been explicitly set.
  var hasPattern: Bool {return _storage._pattern != nil}
  /// Clears the value of `pattern`. Subsequent reads from it will return its default value.
  mutating func clearPattern() {_uniqueStorage()._pattern = nil}

  /// Prefix specifies that this field must have the specified substring at
  /// the beginning of the string.
  var prefix: String {
    get {return _storage._prefix ?? String()}
    set {_uniqueStorage()._prefix = newValue}
  }
  /// Returns true if `prefix` has been explicitly set.
  var hasPrefix: Bool {return _storage._prefix != nil}
  /// Clears the value of `prefix`. Subsequent reads from it will return its default value.
  mutating func clearPrefix() {_uniqueStorage()._prefix = nil}

  /// Suffix specifies that this field must have the specified substring at
  /// the end of the string.
  var suffix: String {
    get {return _storage._suffix ?? String()}
    set {_uniqueStorage()._suffix = newValue}
  }
  /// Returns true if `suffix` has been explicitly set.
  var hasSuffix: Bool {return _storage._suffix != nil}
  /// Clears the value of `suffix`. Subsequent reads from it will return its default value.
  mutating func clearSuffix() {_uniqueStorage()._suffix = nil}

  /// Contains specifies that this field must have the specified substring
  /// anywhere in the string.
  var contains: String {
    get {return _storage._contains ?? String()}
    set {_uniqueStorage()._contains = newValue}
  }
  /// Returns true if `contains` has been explicitly set.
  var hasContains: Bool {return _storage._contains != nil}
  /// Clears the value of `contains`. Subsequent reads from it will return its default value.
  mutating func clearContains() {_uniqueStorage()._contains = nil}

  /// NotContains specifies that this field cannot have the specified substring
  /// anywhere in the string.
  var notContains: String {
    get {return _storage._notContains ?? String()}
    set {_uniqueStorage()._notContains = newValue}
  }
  /// Returns true if `notContains` has been explicitly set.
  var hasNotContains: Bool {return _storage._notContains != nil}
  /// Clears the value of `notContains`. Subsequent reads from it will return its default value.
  mutating func clearNotContains() {_uniqueStorage()._notContains = nil}

  /// In specifies that this field must be equal to one of the specified
  /// values
  var `in`: [String] {
    get {return _storage._in}
    set {_uniqueStorage()._in = newValue}
  }

  /// NotIn specifies that this field cannot be equal to one of the specified
  /// values
  var notIn: [String] {
    get {return _storage._notIn}
    set {_uniqueStorage()._notIn = newValue}
  }

  /// WellKnown rules provide advanced constraints against common string
  /// patterns
  var wellKnown: OneOf_WellKnown? {
    get {return _storage._wellKnown}
    set {_uniqueStorage()._wellKnown = newValue}
  }

  /// Email specifies that the field must be a valid email address as
  /// defined by RFC 5322
  var email: Bool {
    get {
      if case .email(let v)? = _storage._wellKnown {return v}
      return false
    }
    set {_uniqueStorage()._wellKnown = .email(newValue)}
  }

  /// Hostname specifies that the field must be a valid hostname as
  /// defined by RFC 1034. This constraint does not support
  /// internationalized domain names (IDNs).
  var hostname: Bool {
    get {
      if case .hostname(let v)? = _storage._wellKnown {return v}
      return false
    }
    set {_uniqueStorage()._wellKnown = .hostname(newValue)}
  }

  /// Ip specifies that the field must be a valid IP (v4 or v6) address.
  /// Valid IPv6 addresses should not include surrounding square brackets.
  var ip: Bool {
    get {
      if case .ip(let v)? = _storage._wellKnown {return v}
      return false
    }
    set {_uniqueStorage()._wellKnown = .ip(newValue)}
  }

  /// Ipv4 specifies that the field must be a valid IPv4 address.
  var ipv4: Bool {
    get {
      if case .ipv4(let v)? = _storage._wellKnown {return v}
      return false
    }
    set {_uniqueStorage()._wellKnown = .ipv4(newValue)}
  }

  /// Ipv6 specifies that the field must be a valid IPv6 address. Valid
  /// IPv6 addresses should not include surrounding square brackets.
  var ipv6: Bool {
    get {
      if case .ipv6(let v)? = _storage._wellKnown {return v}
      return false
    }
    set {_uniqueStorage()._wellKnown = .ipv6(newValue)}
  }

  /// Uri specifies that the field must be a valid, absolute URI as defined
  /// by RFC 3986
  var uri: Bool {
    get {
      if case .uri(let v)? = _storage._wellKnown {return v}
      return false
    }
    set {_uniqueStorage()._wellKnown = .uri(newValue)}
  }

  /// UriRef specifies that the field must be a valid URI as defined by RFC
  /// 3986 and may be relative or absolute.
  var uriRef: Bool {
    get {
      if case .uriRef(let v)? = _storage._wellKnown {return v}
      return false
    }
    set {_uniqueStorage()._wellKnown = .uriRef(newValue)}
  }

  /// Address specifies that the field must be either a valid hostname as
  /// defined by RFC 1034 (which does not support internationalized domain
  /// names or IDNs), or it can be a valid IP (v4 or v6).
  var address: Bool {
    get {
      if case .address(let v)? = _storage._wellKnown {return v}
      return false
    }
    set {_uniqueStorage()._wellKnown = .address(newValue)}
  }

  /// Uuid specifies that the field must be a valid UUID as defined by
  /// RFC 4122
  var uuid: Bool {
    get {
      if case .uuid(let v)? = _storage._wellKnown {return v}
      return false
    }
    set {_uniqueStorage()._wellKnown = .uuid(newValue)}
  }

  /// WellKnownRegex specifies a common well known pattern defined as a regex.
  var wellKnownRegex: Validate_KnownRegex {
    get {
      if case .wellKnownRegex(let v)? = _storage._wellKnown {return v}
      return .unknown
    }
    set {_uniqueStorage()._wellKnown = .wellKnownRegex(newValue)}
  }

  /// This applies to regexes HTTP_HEADER_NAME and HTTP_HEADER_VALUE to enable
  /// strict header validation.
  /// By default, this is true, and HTTP header validations are RFC-compliant.
  /// Setting to false will enable a looser validations that only disallows
  /// \r\n\0 characters, which can be used to bypass header matching rules.
  var strict: Bool {
    get {return _storage._strict ?? true}
    set {_uniqueStorage()._strict = newValue}
  }
  /// Returns true if `strict` has been explicitly set.
  var hasStrict: Bool {return _storage._strict != nil}
  /// Clears the value of `strict`. Subsequent reads from it will return its default value.
  mutating func clearStrict() {_uniqueStorage()._strict = nil}

  /// IgnoreEmpty specifies that the validation rules of this field should be
  /// evaluated only if the field is not empty
  var ignoreEmpty: Bool {
    get {return _storage._ignoreEmpty ?? false}
    set {_uniqueStorage()._ignoreEmpty = newValue}
  }
  /// Returns true if `ignoreEmpty` has been explicitly set.
  var hasIgnoreEmpty: Bool {return _storage._ignoreEmpty != nil}
  /// Clears the value of `ignoreEmpty`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreEmpty() {_uniqueStorage()._ignoreEmpty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// WellKnown rules provide advanced constraints against common string
  /// patterns
  enum OneOf_WellKnown: Equatable {
    /// Email specifies that the field must be a valid email address as
    /// defined by RFC 5322
    case email(Bool)
    /// Hostname specifies that the field must be a valid hostname as
    /// defined by RFC 1034. This constraint does not support
    /// internationalized domain names (IDNs).
    case hostname(Bool)
    /// Ip specifies that the field must be a valid IP (v4 or v6) address.
    /// Valid IPv6 addresses should not include surrounding square brackets.
    case ip(Bool)
    /// Ipv4 specifies that the field must be a valid IPv4 address.
    case ipv4(Bool)
    /// Ipv6 specifies that the field must be a valid IPv6 address. Valid
    /// IPv6 addresses should not include surrounding square brackets.
    case ipv6(Bool)
    /// Uri specifies that the field must be a valid, absolute URI as defined
    /// by RFC 3986
    case uri(Bool)
    /// UriRef specifies that the field must be a valid URI as defined by RFC
    /// 3986 and may be relative or absolute.
    case uriRef(Bool)
    /// Address specifies that the field must be either a valid hostname as
    /// defined by RFC 1034 (which does not support internationalized domain
    /// names or IDNs), or it can be a valid IP (v4 or v6).
    case address(Bool)
    /// Uuid specifies that the field must be a valid UUID as defined by
    /// RFC 4122
    case uuid(Bool)
    /// WellKnownRegex specifies a common well known pattern defined as a regex.
    case wellKnownRegex(Validate_KnownRegex)

  #if !swift(>=4.1)
    static func ==(lhs: Validate_StringRules.OneOf_WellKnown, rhs: Validate_StringRules.OneOf_WellKnown) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.email, .email): return {
        guard case .email(let l) = lhs, case .email(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hostname, .hostname): return {
        guard case .hostname(let l) = lhs, case .hostname(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ip, .ip): return {
        guard case .ip(let l) = lhs, case .ip(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ipv4, .ipv4): return {
        guard case .ipv4(let l) = lhs, case .ipv4(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ipv6, .ipv6): return {
        guard case .ipv6(let l) = lhs, case .ipv6(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uri, .uri): return {
        guard case .uri(let l) = lhs, case .uri(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uriRef, .uriRef): return {
        guard case .uriRef(let l) = lhs, case .uriRef(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.address, .address): return {
        guard case .address(let l) = lhs, case .address(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uuid, .uuid): return {
        guard case .uuid(let l) = lhs, case .uuid(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.wellKnownRegex, .wellKnownRegex): return {
        guard case .wellKnownRegex(let l) = lhs, case .wellKnownRegex(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// BytesRules describe the constraints applied to `bytes` values
struct Validate_BytesRules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Const specifies that this field must be exactly the specified value
  var const: Data {
    get {return _const ?? Data()}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  /// Len specifies that this field must be the specified number of bytes
  var len: UInt64 {
    get {return _len ?? 0}
    set {_len = newValue}
  }
  /// Returns true if `len` has been explicitly set.
  var hasLen: Bool {return self._len != nil}
  /// Clears the value of `len`. Subsequent reads from it will return its default value.
  mutating func clearLen() {self._len = nil}

  /// MinLen specifies that this field must be the specified number of bytes
  /// at a minimum
  var minLen: UInt64 {
    get {return _minLen ?? 0}
    set {_minLen = newValue}
  }
  /// Returns true if `minLen` has been explicitly set.
  var hasMinLen: Bool {return self._minLen != nil}
  /// Clears the value of `minLen`. Subsequent reads from it will return its default value.
  mutating func clearMinLen() {self._minLen = nil}

  /// MaxLen specifies that this field must be the specified number of bytes
  /// at a maximum
  var maxLen: UInt64 {
    get {return _maxLen ?? 0}
    set {_maxLen = newValue}
  }
  /// Returns true if `maxLen` has been explicitly set.
  var hasMaxLen: Bool {return self._maxLen != nil}
  /// Clears the value of `maxLen`. Subsequent reads from it will return its default value.
  mutating func clearMaxLen() {self._maxLen = nil}

  /// Pattern specifes that this field must match against the specified
  /// regular expression (RE2 syntax). The included expression should elide
  /// any delimiters.
  var pattern: String {
    get {return _pattern ?? String()}
    set {_pattern = newValue}
  }
  /// Returns true if `pattern` has been explicitly set.
  var hasPattern: Bool {return self._pattern != nil}
  /// Clears the value of `pattern`. Subsequent reads from it will return its default value.
  mutating func clearPattern() {self._pattern = nil}

  /// Prefix specifies that this field must have the specified bytes at the
  /// beginning of the string.
  var prefix: Data {
    get {return _prefix ?? Data()}
    set {_prefix = newValue}
  }
  /// Returns true if `prefix` has been explicitly set.
  var hasPrefix: Bool {return self._prefix != nil}
  /// Clears the value of `prefix`. Subsequent reads from it will return its default value.
  mutating func clearPrefix() {self._prefix = nil}

  /// Suffix specifies that this field must have the specified bytes at the
  /// end of the string.
  var suffix: Data {
    get {return _suffix ?? Data()}
    set {_suffix = newValue}
  }
  /// Returns true if `suffix` has been explicitly set.
  var hasSuffix: Bool {return self._suffix != nil}
  /// Clears the value of `suffix`. Subsequent reads from it will return its default value.
  mutating func clearSuffix() {self._suffix = nil}

  /// Contains specifies that this field must have the specified bytes
  /// anywhere in the string.
  var contains: Data {
    get {return _contains ?? Data()}
    set {_contains = newValue}
  }
  /// Returns true if `contains` has been explicitly set.
  var hasContains: Bool {return self._contains != nil}
  /// Clears the value of `contains`. Subsequent reads from it will return its default value.
  mutating func clearContains() {self._contains = nil}

  /// In specifies that this field must be equal to one of the specified
  /// values
  var `in`: [Data] = []

  /// NotIn specifies that this field cannot be equal to one of the specified
  /// values
  var notIn: [Data] = []

  /// WellKnown rules provide advanced constraints against common byte
  /// patterns
  var wellKnown: Validate_BytesRules.OneOf_WellKnown? = nil

  /// Ip specifies that the field must be a valid IP (v4 or v6) address in
  /// byte format
  var ip: Bool {
    get {
      if case .ip(let v)? = wellKnown {return v}
      return false
    }
    set {wellKnown = .ip(newValue)}
  }

  /// Ipv4 specifies that the field must be a valid IPv4 address in byte
  /// format
  var ipv4: Bool {
    get {
      if case .ipv4(let v)? = wellKnown {return v}
      return false
    }
    set {wellKnown = .ipv4(newValue)}
  }

  /// Ipv6 specifies that the field must be a valid IPv6 address in byte
  /// format
  var ipv6: Bool {
    get {
      if case .ipv6(let v)? = wellKnown {return v}
      return false
    }
    set {wellKnown = .ipv6(newValue)}
  }

  /// IgnoreEmpty specifies that the validation rules of this field should be
  /// evaluated only if the field is not empty
  var ignoreEmpty: Bool {
    get {return _ignoreEmpty ?? false}
    set {_ignoreEmpty = newValue}
  }
  /// Returns true if `ignoreEmpty` has been explicitly set.
  var hasIgnoreEmpty: Bool {return self._ignoreEmpty != nil}
  /// Clears the value of `ignoreEmpty`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreEmpty() {self._ignoreEmpty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// WellKnown rules provide advanced constraints against common byte
  /// patterns
  enum OneOf_WellKnown: Equatable {
    /// Ip specifies that the field must be a valid IP (v4 or v6) address in
    /// byte format
    case ip(Bool)
    /// Ipv4 specifies that the field must be a valid IPv4 address in byte
    /// format
    case ipv4(Bool)
    /// Ipv6 specifies that the field must be a valid IPv6 address in byte
    /// format
    case ipv6(Bool)

  #if !swift(>=4.1)
    static func ==(lhs: Validate_BytesRules.OneOf_WellKnown, rhs: Validate_BytesRules.OneOf_WellKnown) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.ip, .ip): return {
        guard case .ip(let l) = lhs, case .ip(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ipv4, .ipv4): return {
        guard case .ipv4(let l) = lhs, case .ipv4(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ipv6, .ipv6): return {
        guard case .ipv6(let l) = lhs, case .ipv6(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _const: Data? = nil
  fileprivate var _len: UInt64? = nil
  fileprivate var _minLen: UInt64? = nil
  fileprivate var _maxLen: UInt64? = nil
  fileprivate var _pattern: String? = nil
  fileprivate var _prefix: Data? = nil
  fileprivate var _suffix: Data? = nil
  fileprivate var _contains: Data? = nil
  fileprivate var _ignoreEmpty: Bool? = nil
}

/// EnumRules describe the constraints applied to enum values
struct Validate_EnumRules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Const specifies that this field must be exactly the specified value
  var const: Int32 {
    get {return _const ?? 0}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  /// DefinedOnly specifies that this field must be only one of the defined
  /// values for this enum, failing on any undefined value.
  var definedOnly: Bool {
    get {return _definedOnly ?? false}
    set {_definedOnly = newValue}
  }
  /// Returns true if `definedOnly` has been explicitly set.
  var hasDefinedOnly: Bool {return self._definedOnly != nil}
  /// Clears the value of `definedOnly`. Subsequent reads from it will return its default value.
  mutating func clearDefinedOnly() {self._definedOnly = nil}

  /// In specifies that this field must be equal to one of the specified
  /// values
  var `in`: [Int32] = []

  /// NotIn specifies that this field cannot be equal to one of the specified
  /// values
  var notIn: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _const: Int32? = nil
  fileprivate var _definedOnly: Bool? = nil
}

/// MessageRules describe the constraints applied to embedded message values.
/// For message-type fields, validation is performed recursively.
struct Validate_MessageRules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Skip specifies that the validation rules of this field should not be
  /// evaluated
  var skip: Bool {
    get {return _skip ?? false}
    set {_skip = newValue}
  }
  /// Returns true if `skip` has been explicitly set.
  var hasSkip: Bool {return self._skip != nil}
  /// Clears the value of `skip`. Subsequent reads from it will return its default value.
  mutating func clearSkip() {self._skip = nil}

  /// Required specifies that this field must be set
  var required: Bool {
    get {return _required ?? false}
    set {_required = newValue}
  }
  /// Returns true if `required` has been explicitly set.
  var hasRequired: Bool {return self._required != nil}
  /// Clears the value of `required`. Subsequent reads from it will return its default value.
  mutating func clearRequired() {self._required = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _skip: Bool? = nil
  fileprivate var _required: Bool? = nil
}

/// RepeatedRules describe the constraints applied to `repeated` values
struct Validate_RepeatedRules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// MinItems specifies that this field must have the specified number of
  /// items at a minimum
  var minItems: UInt64 {
    get {return _storage._minItems ?? 0}
    set {_uniqueStorage()._minItems = newValue}
  }
  /// Returns true if `minItems` has been explicitly set.
  var hasMinItems: Bool {return _storage._minItems != nil}
  /// Clears the value of `minItems`. Subsequent reads from it will return its default value.
  mutating func clearMinItems() {_uniqueStorage()._minItems = nil}

  /// MaxItems specifies that this field must have the specified number of
  /// items at a maximum
  var maxItems: UInt64 {
    get {return _storage._maxItems ?? 0}
    set {_uniqueStorage()._maxItems = newValue}
  }
  /// Returns true if `maxItems` has been explicitly set.
  var hasMaxItems: Bool {return _storage._maxItems != nil}
  /// Clears the value of `maxItems`. Subsequent reads from it will return its default value.
  mutating func clearMaxItems() {_uniqueStorage()._maxItems = nil}

  /// Unique specifies that all elements in this field must be unique. This
  /// contraint is only applicable to scalar and enum types (messages are not
  /// supported).
  var unique: Bool {
    get {return _storage._unique ?? false}
    set {_uniqueStorage()._unique = newValue}
  }
  /// Returns true if `unique` has been explicitly set.
  var hasUnique: Bool {return _storage._unique != nil}
  /// Clears the value of `unique`. Subsequent reads from it will return its default value.
  mutating func clearUnique() {_uniqueStorage()._unique = nil}

  /// Items specifies the contraints to be applied to each item in the field.
  /// Repeated message fields will still execute validation against each item
  /// unless skip is specified here.
  var items: Validate_FieldRules {
    get {return _storage._items ?? Validate_FieldRules()}
    set {_uniqueStorage()._items = newValue}
  }
  /// Returns true if `items` has been explicitly set.
  var hasItems: Bool {return _storage._items != nil}
  /// Clears the value of `items`. Subsequent reads from it will return its default value.
  mutating func clearItems() {_uniqueStorage()._items = nil}

  /// IgnoreEmpty specifies that the validation rules of this field should be
  /// evaluated only if the field is not empty
  var ignoreEmpty: Bool {
    get {return _storage._ignoreEmpty ?? false}
    set {_uniqueStorage()._ignoreEmpty = newValue}
  }
  /// Returns true if `ignoreEmpty` has been explicitly set.
  var hasIgnoreEmpty: Bool {return _storage._ignoreEmpty != nil}
  /// Clears the value of `ignoreEmpty`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreEmpty() {_uniqueStorage()._ignoreEmpty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MapRules describe the constraints applied to `map` values
struct Validate_MapRules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// MinPairs specifies that this field must have the specified number of
  /// KVs at a minimum
  var minPairs: UInt64 {
    get {return _storage._minPairs ?? 0}
    set {_uniqueStorage()._minPairs = newValue}
  }
  /// Returns true if `minPairs` has been explicitly set.
  var hasMinPairs: Bool {return _storage._minPairs != nil}
  /// Clears the value of `minPairs`. Subsequent reads from it will return its default value.
  mutating func clearMinPairs() {_uniqueStorage()._minPairs = nil}

  /// MaxPairs specifies that this field must have the specified number of
  /// KVs at a maximum
  var maxPairs: UInt64 {
    get {return _storage._maxPairs ?? 0}
    set {_uniqueStorage()._maxPairs = newValue}
  }
  /// Returns true if `maxPairs` has been explicitly set.
  var hasMaxPairs: Bool {return _storage._maxPairs != nil}
  /// Clears the value of `maxPairs`. Subsequent reads from it will return its default value.
  mutating func clearMaxPairs() {_uniqueStorage()._maxPairs = nil}

  /// NoSparse specifies values in this field cannot be unset. This only
  /// applies to map's with message value types.
  var noSparse: Bool {
    get {return _storage._noSparse ?? false}
    set {_uniqueStorage()._noSparse = newValue}
  }
  /// Returns true if `noSparse` has been explicitly set.
  var hasNoSparse: Bool {return _storage._noSparse != nil}
  /// Clears the value of `noSparse`. Subsequent reads from it will return its default value.
  mutating func clearNoSparse() {_uniqueStorage()._noSparse = nil}

  /// Keys specifies the constraints to be applied to each key in the field.
  var keys: Validate_FieldRules {
    get {return _storage._keys ?? Validate_FieldRules()}
    set {_uniqueStorage()._keys = newValue}
  }
  /// Returns true if `keys` has been explicitly set.
  var hasKeys: Bool {return _storage._keys != nil}
  /// Clears the value of `keys`. Subsequent reads from it will return its default value.
  mutating func clearKeys() {_uniqueStorage()._keys = nil}

  /// Values specifies the constraints to be applied to the value of each key
  /// in the field. Message values will still have their validations evaluated
  /// unless skip is specified here.
  var values: Validate_FieldRules {
    get {return _storage._values ?? Validate_FieldRules()}
    set {_uniqueStorage()._values = newValue}
  }
  /// Returns true if `values` has been explicitly set.
  var hasValues: Bool {return _storage._values != nil}
  /// Clears the value of `values`. Subsequent reads from it will return its default value.
  mutating func clearValues() {_uniqueStorage()._values = nil}

  /// IgnoreEmpty specifies that the validation rules of this field should be
  /// evaluated only if the field is not empty
  var ignoreEmpty: Bool {
    get {return _storage._ignoreEmpty ?? false}
    set {_uniqueStorage()._ignoreEmpty = newValue}
  }
  /// Returns true if `ignoreEmpty` has been explicitly set.
  var hasIgnoreEmpty: Bool {return _storage._ignoreEmpty != nil}
  /// Clears the value of `ignoreEmpty`. Subsequent reads from it will return its default value.
  mutating func clearIgnoreEmpty() {_uniqueStorage()._ignoreEmpty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AnyRules describe constraints applied exclusively to the
/// `google.protobuf.Any` well-known type
struct Validate_AnyRules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required specifies that this field must be set
  var required: Bool {
    get {return _required ?? false}
    set {_required = newValue}
  }
  /// Returns true if `required` has been explicitly set.
  var hasRequired: Bool {return self._required != nil}
  /// Clears the value of `required`. Subsequent reads from it will return its default value.
  mutating func clearRequired() {self._required = nil}

  /// In specifies that this field's `type_url` must be equal to one of the
  /// specified values.
  var `in`: [String] = []

  /// NotIn specifies that this field's `type_url` must not be equal to any of
  /// the specified values.
  var notIn: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _required: Bool? = nil
}

/// DurationRules describe the constraints applied exclusively to the
/// `google.protobuf.Duration` well-known type
struct Validate_DurationRules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required specifies that this field must be set
  var required: Bool {
    get {return _required ?? false}
    set {_required = newValue}
  }
  /// Returns true if `required` has been explicitly set.
  var hasRequired: Bool {return self._required != nil}
  /// Clears the value of `required`. Subsequent reads from it will return its default value.
  mutating func clearRequired() {self._required = nil}

  /// Const specifies that this field must be exactly the specified value
  var const: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _const ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  /// Lt specifies that this field must be less than the specified value,
  /// exclusive
  var lt: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _lt ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_lt = newValue}
  }
  /// Returns true if `lt` has been explicitly set.
  var hasLt: Bool {return self._lt != nil}
  /// Clears the value of `lt`. Subsequent reads from it will return its default value.
  mutating func clearLt() {self._lt = nil}

  /// Lt specifies that this field must be less than the specified value,
  /// inclusive
  var lte: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _lte ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_lte = newValue}
  }
  /// Returns true if `lte` has been explicitly set.
  var hasLte: Bool {return self._lte != nil}
  /// Clears the value of `lte`. Subsequent reads from it will return its default value.
  mutating func clearLte() {self._lte = nil}

  /// Gt specifies that this field must be greater than the specified value,
  /// exclusive
  var gt: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _gt ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_gt = newValue}
  }
  /// Returns true if `gt` has been explicitly set.
  var hasGt: Bool {return self._gt != nil}
  /// Clears the value of `gt`. Subsequent reads from it will return its default value.
  mutating func clearGt() {self._gt = nil}

  /// Gte specifies that this field must be greater than the specified value,
  /// inclusive
  var gte: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _gte ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_gte = newValue}
  }
  /// Returns true if `gte` has been explicitly set.
  var hasGte: Bool {return self._gte != nil}
  /// Clears the value of `gte`. Subsequent reads from it will return its default value.
  mutating func clearGte() {self._gte = nil}

  /// In specifies that this field must be equal to one of the specified
  /// values
  var `in`: [SwiftProtobuf.Google_Protobuf_Duration] = []

  /// NotIn specifies that this field cannot be equal to one of the specified
  /// values
  var notIn: [SwiftProtobuf.Google_Protobuf_Duration] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _required: Bool? = nil
  fileprivate var _const: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _lt: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _lte: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _gt: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _gte: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// TimestampRules describe the constraints applied exclusively to the
/// `google.protobuf.Timestamp` well-known type
struct Validate_TimestampRules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required specifies that this field must be set
  var required: Bool {
    get {return _required ?? false}
    set {_required = newValue}
  }
  /// Returns true if `required` has been explicitly set.
  var hasRequired: Bool {return self._required != nil}
  /// Clears the value of `required`. Subsequent reads from it will return its default value.
  mutating func clearRequired() {self._required = nil}

  /// Const specifies that this field must be exactly the specified value
  var const: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _const ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_const = newValue}
  }
  /// Returns true if `const` has been explicitly set.
  var hasConst: Bool {return self._const != nil}
  /// Clears the value of `const`. Subsequent reads from it will return its default value.
  mutating func clearConst() {self._const = nil}

  /// Lt specifies that this field must be less than the specified value,
  /// exclusive
  var lt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lt = newValue}
  }
  /// Returns true if `lt` has been explicitly set.
  var hasLt: Bool {return self._lt != nil}
  /// Clears the value of `lt`. Subsequent reads from it will return its default value.
  mutating func clearLt() {self._lt = nil}

  /// Lte specifies that this field must be less than the specified value,
  /// inclusive
  var lte: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lte ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lte = newValue}
  }
  /// Returns true if `lte` has been explicitly set.
  var hasLte: Bool {return self._lte != nil}
  /// Clears the value of `lte`. Subsequent reads from it will return its default value.
  mutating func clearLte() {self._lte = nil}

  /// Gt specifies that this field must be greater than the specified value,
  /// exclusive
  var gt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _gt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_gt = newValue}
  }
  /// Returns true if `gt` has been explicitly set.
  var hasGt: Bool {return self._gt != nil}
  /// Clears the value of `gt`. Subsequent reads from it will return its default value.
  mutating func clearGt() {self._gt = nil}

  /// Gte specifies that this field must be greater than the specified value,
  /// inclusive
  var gte: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _gte ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_gte = newValue}
  }
  /// Returns true if `gte` has been explicitly set.
  var hasGte: Bool {return self._gte != nil}
  /// Clears the value of `gte`. Subsequent reads from it will return its default value.
  mutating func clearGte() {self._gte = nil}

  /// LtNow specifies that this must be less than the current time. LtNow
  /// can only be used with the Within rule.
  var ltNow: Bool {
    get {return _ltNow ?? false}
    set {_ltNow = newValue}
  }
  /// Returns true if `ltNow` has been explicitly set.
  var hasLtNow: Bool {return self._ltNow != nil}
  /// Clears the value of `ltNow`. Subsequent reads from it will return its default value.
  mutating func clearLtNow() {self._ltNow = nil}

  /// GtNow specifies that this must be greater than the current time. GtNow
  /// can only be used with the Within rule.
  var gtNow: Bool {
    get {return _gtNow ?? false}
    set {_gtNow = newValue}
  }
  /// Returns true if `gtNow` has been explicitly set.
  var hasGtNow: Bool {return self._gtNow != nil}
  /// Clears the value of `gtNow`. Subsequent reads from it will return its default value.
  mutating func clearGtNow() {self._gtNow = nil}

  /// Within specifies that this field must be within this duration of the
  /// current time. This constraint can be used alone or with the LtNow and
  /// GtNow rules.
  var within: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _within ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_within = newValue}
  }
  /// Returns true if `within` has been explicitly set.
  var hasWithin: Bool {return self._within != nil}
  /// Clears the value of `within`. Subsequent reads from it will return its default value.
  mutating func clearWithin() {self._within = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _required: Bool? = nil
  fileprivate var _const: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lte: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _gt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _gte: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _ltNow: Bool? = nil
  fileprivate var _gtNow: Bool? = nil
  fileprivate var _within: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Validate_KnownRegex: @unchecked Sendable {}
extension Validate_FieldRules: @unchecked Sendable {}
extension Validate_FieldRules.OneOf_Type: @unchecked Sendable {}
extension Validate_FloatRules: @unchecked Sendable {}
extension Validate_DoubleRules: @unchecked Sendable {}
extension Validate_Int32Rules: @unchecked Sendable {}
extension Validate_Int64Rules: @unchecked Sendable {}
extension Validate_UInt32Rules: @unchecked Sendable {}
extension Validate_UInt64Rules: @unchecked Sendable {}
extension Validate_SInt32Rules: @unchecked Sendable {}
extension Validate_SInt64Rules: @unchecked Sendable {}
extension Validate_Fixed32Rules: @unchecked Sendable {}
extension Validate_Fixed64Rules: @unchecked Sendable {}
extension Validate_SFixed32Rules: @unchecked Sendable {}
extension Validate_SFixed64Rules: @unchecked Sendable {}
extension Validate_BoolRules: @unchecked Sendable {}
extension Validate_StringRules: @unchecked Sendable {}
extension Validate_StringRules.OneOf_WellKnown: @unchecked Sendable {}
extension Validate_BytesRules: @unchecked Sendable {}
extension Validate_BytesRules.OneOf_WellKnown: @unchecked Sendable {}
extension Validate_EnumRules: @unchecked Sendable {}
extension Validate_MessageRules: @unchecked Sendable {}
extension Validate_RepeatedRules: @unchecked Sendable {}
extension Validate_MapRules: @unchecked Sendable {}
extension Validate_AnyRules: @unchecked Sendable {}
extension Validate_DurationRules: @unchecked Sendable {}
extension Validate_TimestampRules: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Extension support defined in validate.proto.

// MARK: - Extension Properties

// Swift Extensions on the exteneded Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension SwiftProtobuf.Google_Protobuf_FieldOptions {

  /// Rules specify the validations to be performed on this field. By default,
  /// no validation is performed against a field.
  var Validate_rules: Validate_FieldRules {
    get {return getExtensionValue(ext: Validate_Extensions_rules) ?? Validate_FieldRules()}
    set {setExtensionValue(ext: Validate_Extensions_rules, value: newValue)}
  }
  /// Returns true if extension `Validate_Extensions_rules`
  /// has been explicitly set.
  var hasValidate_rules: Bool {
    return hasExtensionValue(ext: Validate_Extensions_rules)
  }
  /// Clears the value of extension `Validate_Extensions_rules`.
  /// Subsequent reads from it will return its default value.
  mutating func clearValidate_rules() {
    clearExtensionValue(ext: Validate_Extensions_rules)
  }
}

extension SwiftProtobuf.Google_Protobuf_MessageOptions {

  /// Disabled nullifies any validation rules for this message, including any
  /// message fields associated with it that do support validation.
  var Validate_disabled: Bool {
    get {return getExtensionValue(ext: Validate_Extensions_disabled) ?? false}
    set {setExtensionValue(ext: Validate_Extensions_disabled, value: newValue)}
  }
  /// Returns true if extension `Validate_Extensions_disabled`
  /// has been explicitly set.
  var hasValidate_disabled: Bool {
    return hasExtensionValue(ext: Validate_Extensions_disabled)
  }
  /// Clears the value of extension `Validate_Extensions_disabled`.
  /// Subsequent reads from it will return its default value.
  mutating func clearValidate_disabled() {
    clearExtensionValue(ext: Validate_Extensions_disabled)
  }

  /// Ignore skips generation of validation methods for this message.
  var Validate_ignored: Bool {
    get {return getExtensionValue(ext: Validate_Extensions_ignored) ?? false}
    set {setExtensionValue(ext: Validate_Extensions_ignored, value: newValue)}
  }
  /// Returns true if extension `Validate_Extensions_ignored`
  /// has been explicitly set.
  var hasValidate_ignored: Bool {
    return hasExtensionValue(ext: Validate_Extensions_ignored)
  }
  /// Clears the value of extension `Validate_Extensions_ignored`.
  /// Subsequent reads from it will return its default value.
  mutating func clearValidate_ignored() {
    clearExtensionValue(ext: Validate_Extensions_ignored)
  }
}

extension SwiftProtobuf.Google_Protobuf_OneofOptions {

  /// Required ensures that exactly one the field options in a oneof is set;
  /// validation fails if no fields in the oneof are set.
  var Validate_required: Bool {
    get {return getExtensionValue(ext: Validate_Extensions_required) ?? false}
    set {setExtensionValue(ext: Validate_Extensions_required, value: newValue)}
  }
  /// Returns true if extension `Validate_Extensions_required`
  /// has been explicitly set.
  var hasValidate_required: Bool {
    return hasExtensionValue(ext: Validate_Extensions_required)
  }
  /// Clears the value of extension `Validate_Extensions_required`.
  /// Subsequent reads from it will return its default value.
  mutating func clearValidate_required() {
    clearExtensionValue(ext: Validate_Extensions_required)
  }

}

// MARK: - File's ExtensionMap: Validate_Validate_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
let Validate_Validate_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  Validate_Extensions_disabled,
  Validate_Extensions_ignored,
  Validate_Extensions_required,
  Validate_Extensions_rules
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

/// Disabled nullifies any validation rules for this message, including any
/// message fields associated with it that do support validation.
let Validate_Extensions_disabled = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufBool>, SwiftProtobuf.Google_Protobuf_MessageOptions>(
  _protobuf_fieldNumber: 1071,
  fieldName: "validate.disabled"
)

/// Ignore skips generation of validation methods for this message.
let Validate_Extensions_ignored = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufBool>, SwiftProtobuf.Google_Protobuf_MessageOptions>(
  _protobuf_fieldNumber: 1072,
  fieldName: "validate.ignored"
)

/// Required ensures that exactly one the field options in a oneof is set;
/// validation fails if no fields in the oneof are set.
let Validate_Extensions_required = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalExtensionField<SwiftProtobuf.ProtobufBool>, SwiftProtobuf.Google_Protobuf_OneofOptions>(
  _protobuf_fieldNumber: 1071,
  fieldName: "validate.required"
)

/// Rules specify the validations to be performed on this field. By default,
/// no validation is performed against a field.
let Validate_Extensions_rules = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<Validate_FieldRules>, SwiftProtobuf.Google_Protobuf_FieldOptions>(
  _protobuf_fieldNumber: 1071,
  fieldName: "validate.rules"
)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "validate"

extension Validate_KnownRegex: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "HTTP_HEADER_NAME"),
    2: .same(proto: "HTTP_HEADER_VALUE"),
  ]
}

extension Validate_FieldRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FieldRules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    17: .same(proto: "message"),
    1: .same(proto: "float"),
    2: .same(proto: "double"),
    3: .same(proto: "int32"),
    4: .same(proto: "int64"),
    5: .same(proto: "uint32"),
    6: .same(proto: "uint64"),
    7: .same(proto: "sint32"),
    8: .same(proto: "sint64"),
    9: .same(proto: "fixed32"),
    10: .same(proto: "fixed64"),
    11: .same(proto: "sfixed32"),
    12: .same(proto: "sfixed64"),
    13: .same(proto: "bool"),
    14: .same(proto: "string"),
    15: .same(proto: "bytes"),
    16: .same(proto: "enum"),
    18: .same(proto: "repeated"),
    19: .same(proto: "map"),
    20: .same(proto: "any"),
    21: .same(proto: "duration"),
    22: .same(proto: "timestamp"),
  ]

  fileprivate class _StorageClass {
    var _message: Validate_MessageRules? = nil
    var _type: Validate_FieldRules.OneOf_Type?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _message = source._message
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Validate_FloatRules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .float(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .float(v)
          }
        }()
        case 2: try {
          var v: Validate_DoubleRules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .double(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .double(v)
          }
        }()
        case 3: try {
          var v: Validate_Int32Rules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .int32(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .int32(v)
          }
        }()
        case 4: try {
          var v: Validate_Int64Rules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .int64(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .int64(v)
          }
        }()
        case 5: try {
          var v: Validate_UInt32Rules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .uint32(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .uint32(v)
          }
        }()
        case 6: try {
          var v: Validate_UInt64Rules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .uint64(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .uint64(v)
          }
        }()
        case 7: try {
          var v: Validate_SInt32Rules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .sint32(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .sint32(v)
          }
        }()
        case 8: try {
          var v: Validate_SInt64Rules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .sint64(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .sint64(v)
          }
        }()
        case 9: try {
          var v: Validate_Fixed32Rules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .fixed32(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .fixed32(v)
          }
        }()
        case 10: try {
          var v: Validate_Fixed64Rules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .fixed64(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .fixed64(v)
          }
        }()
        case 11: try {
          var v: Validate_SFixed32Rules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .sfixed32(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .sfixed32(v)
          }
        }()
        case 12: try {
          var v: Validate_SFixed64Rules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .sfixed64(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .sfixed64(v)
          }
        }()
        case 13: try {
          var v: Validate_BoolRules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .bool(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .bool(v)
          }
        }()
        case 14: try {
          var v: Validate_StringRules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .string(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .string(v)
          }
        }()
        case 15: try {
          var v: Validate_BytesRules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .bytes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .bytes(v)
          }
        }()
        case 16: try {
          var v: Validate_EnumRules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .enum(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .enum(v)
          }
        }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._message) }()
        case 18: try {
          var v: Validate_RepeatedRules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .repeated(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .repeated(v)
          }
        }()
        case 19: try {
          var v: Validate_MapRules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .map(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .map(v)
          }
        }()
        case 20: try {
          var v: Validate_AnyRules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .any(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .any(v)
          }
        }()
        case 21: try {
          var v: Validate_DurationRules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .duration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .duration(v)
          }
        }()
        case 22: try {
          var v: Validate_TimestampRules?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .timestamp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .timestamp(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._type {
      case .float?: try {
        guard case .float(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .double?: try {
        guard case .double(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .int32?: try {
        guard case .int32(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .int64?: try {
        guard case .int64(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .uint32?: try {
        guard case .uint32(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .uint64?: try {
        guard case .uint64(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .sint32?: try {
        guard case .sint32(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .sint64?: try {
        guard case .sint64(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .fixed32?: try {
        guard case .fixed32(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .fixed64?: try {
        guard case .fixed64(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .sfixed32?: try {
        guard case .sfixed32(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .sfixed64?: try {
        guard case .sfixed64(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .bool?: try {
        guard case .bool(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .string?: try {
        guard case .string(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .bytes?: try {
        guard case .bytes(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .enum?: try {
        guard case .enum(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      default: break
      }
      try { if let v = _storage._message {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      switch _storage._type {
      case .repeated?: try {
        guard case .repeated(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .map?: try {
        guard case .map(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .any?: try {
        guard case .any(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .duration?: try {
        guard case .duration(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .timestamp?: try {
        guard case .timestamp(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_FieldRules, rhs: Validate_FieldRules) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._message != rhs_storage._message {return false}
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_FloatRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FloatRules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
    2: .same(proto: "lt"),
    3: .same(proto: "lte"),
    4: .same(proto: "gt"),
    5: .same(proto: "gte"),
    6: .same(proto: "in"),
    7: .standard(proto: "not_in"),
    8: .standard(proto: "ignore_empty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._const) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._lt) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._lte) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._gt) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._gte) }()
      case 6: try { try decoder.decodeRepeatedFloatField(value: &self.`in`) }()
      case 7: try { try decoder.decodeRepeatedFloatField(value: &self.notIn) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._ignoreEmpty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._const {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lt {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedFloatField(value: self.`in`, fieldNumber: 6)
    }
    if !self.notIn.isEmpty {
      try visitor.visitRepeatedFloatField(value: self.notIn, fieldNumber: 7)
    }
    try { if let v = self._ignoreEmpty {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_FloatRules, rhs: Validate_FloatRules) -> Bool {
    if lhs._const != rhs._const {return false}
    if lhs._lt != rhs._lt {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.notIn != rhs.notIn {return false}
    if lhs._ignoreEmpty != rhs._ignoreEmpty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_DoubleRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DoubleRules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
    2: .same(proto: "lt"),
    3: .same(proto: "lte"),
    4: .same(proto: "gt"),
    5: .same(proto: "gte"),
    6: .same(proto: "in"),
    7: .standard(proto: "not_in"),
    8: .standard(proto: "ignore_empty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._const) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._lt) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._lte) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._gt) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self._gte) }()
      case 6: try { try decoder.decodeRepeatedDoubleField(value: &self.`in`) }()
      case 7: try { try decoder.decodeRepeatedDoubleField(value: &self.notIn) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._ignoreEmpty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._const {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lt {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedDoubleField(value: self.`in`, fieldNumber: 6)
    }
    if !self.notIn.isEmpty {
      try visitor.visitRepeatedDoubleField(value: self.notIn, fieldNumber: 7)
    }
    try { if let v = self._ignoreEmpty {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_DoubleRules, rhs: Validate_DoubleRules) -> Bool {
    if lhs._const != rhs._const {return false}
    if lhs._lt != rhs._lt {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.notIn != rhs.notIn {return false}
    if lhs._ignoreEmpty != rhs._ignoreEmpty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_Int32Rules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Int32Rules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
    2: .same(proto: "lt"),
    3: .same(proto: "lte"),
    4: .same(proto: "gt"),
    5: .same(proto: "gte"),
    6: .same(proto: "in"),
    7: .standard(proto: "not_in"),
    8: .standard(proto: "ignore_empty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._const) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._lt) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._lte) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._gt) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._gte) }()
      case 6: try { try decoder.decodeRepeatedInt32Field(value: &self.`in`) }()
      case 7: try { try decoder.decodeRepeatedInt32Field(value: &self.notIn) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._ignoreEmpty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._const {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.`in`, fieldNumber: 6)
    }
    if !self.notIn.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.notIn, fieldNumber: 7)
    }
    try { if let v = self._ignoreEmpty {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_Int32Rules, rhs: Validate_Int32Rules) -> Bool {
    if lhs._const != rhs._const {return false}
    if lhs._lt != rhs._lt {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.notIn != rhs.notIn {return false}
    if lhs._ignoreEmpty != rhs._ignoreEmpty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_Int64Rules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Int64Rules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
    2: .same(proto: "lt"),
    3: .same(proto: "lte"),
    4: .same(proto: "gt"),
    5: .same(proto: "gte"),
    6: .same(proto: "in"),
    7: .standard(proto: "not_in"),
    8: .standard(proto: "ignore_empty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._const) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._lt) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._lte) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._gt) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self._gte) }()
      case 6: try { try decoder.decodeRepeatedInt64Field(value: &self.`in`) }()
      case 7: try { try decoder.decodeRepeatedInt64Field(value: &self.notIn) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._ignoreEmpty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._const {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lt {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedInt64Field(value: self.`in`, fieldNumber: 6)
    }
    if !self.notIn.isEmpty {
      try visitor.visitRepeatedInt64Field(value: self.notIn, fieldNumber: 7)
    }
    try { if let v = self._ignoreEmpty {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_Int64Rules, rhs: Validate_Int64Rules) -> Bool {
    if lhs._const != rhs._const {return false}
    if lhs._lt != rhs._lt {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.notIn != rhs.notIn {return false}
    if lhs._ignoreEmpty != rhs._ignoreEmpty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_UInt32Rules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UInt32Rules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
    2: .same(proto: "lt"),
    3: .same(proto: "lte"),
    4: .same(proto: "gt"),
    5: .same(proto: "gte"),
    6: .same(proto: "in"),
    7: .standard(proto: "not_in"),
    8: .standard(proto: "ignore_empty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._const) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._lt) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._lte) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._gt) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._gte) }()
      case 6: try { try decoder.decodeRepeatedUInt32Field(value: &self.`in`) }()
      case 7: try { try decoder.decodeRepeatedUInt32Field(value: &self.notIn) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._ignoreEmpty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._const {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lt {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.`in`, fieldNumber: 6)
    }
    if !self.notIn.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.notIn, fieldNumber: 7)
    }
    try { if let v = self._ignoreEmpty {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_UInt32Rules, rhs: Validate_UInt32Rules) -> Bool {
    if lhs._const != rhs._const {return false}
    if lhs._lt != rhs._lt {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.notIn != rhs.notIn {return false}
    if lhs._ignoreEmpty != rhs._ignoreEmpty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_UInt64Rules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UInt64Rules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
    2: .same(proto: "lt"),
    3: .same(proto: "lte"),
    4: .same(proto: "gt"),
    5: .same(proto: "gte"),
    6: .same(proto: "in"),
    7: .standard(proto: "not_in"),
    8: .standard(proto: "ignore_empty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._const) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._lt) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._lte) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._gt) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._gte) }()
      case 6: try { try decoder.decodeRepeatedUInt64Field(value: &self.`in`) }()
      case 7: try { try decoder.decodeRepeatedUInt64Field(value: &self.notIn) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._ignoreEmpty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._const {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.`in`, fieldNumber: 6)
    }
    if !self.notIn.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.notIn, fieldNumber: 7)
    }
    try { if let v = self._ignoreEmpty {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_UInt64Rules, rhs: Validate_UInt64Rules) -> Bool {
    if lhs._const != rhs._const {return false}
    if lhs._lt != rhs._lt {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.notIn != rhs.notIn {return false}
    if lhs._ignoreEmpty != rhs._ignoreEmpty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_SInt32Rules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SInt32Rules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
    2: .same(proto: "lt"),
    3: .same(proto: "lte"),
    4: .same(proto: "gt"),
    5: .same(proto: "gte"),
    6: .same(proto: "in"),
    7: .standard(proto: "not_in"),
    8: .standard(proto: "ignore_empty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularSInt32Field(value: &self._const) }()
      case 2: try { try decoder.decodeSingularSInt32Field(value: &self._lt) }()
      case 3: try { try decoder.decodeSingularSInt32Field(value: &self._lte) }()
      case 4: try { try decoder.decodeSingularSInt32Field(value: &self._gt) }()
      case 5: try { try decoder.decodeSingularSInt32Field(value: &self._gte) }()
      case 6: try { try decoder.decodeRepeatedSInt32Field(value: &self.`in`) }()
      case 7: try { try decoder.decodeRepeatedSInt32Field(value: &self.notIn) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._ignoreEmpty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._const {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lt {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedSInt32Field(value: self.`in`, fieldNumber: 6)
    }
    if !self.notIn.isEmpty {
      try visitor.visitRepeatedSInt32Field(value: self.notIn, fieldNumber: 7)
    }
    try { if let v = self._ignoreEmpty {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_SInt32Rules, rhs: Validate_SInt32Rules) -> Bool {
    if lhs._const != rhs._const {return false}
    if lhs._lt != rhs._lt {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.notIn != rhs.notIn {return false}
    if lhs._ignoreEmpty != rhs._ignoreEmpty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_SInt64Rules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SInt64Rules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
    2: .same(proto: "lt"),
    3: .same(proto: "lte"),
    4: .same(proto: "gt"),
    5: .same(proto: "gte"),
    6: .same(proto: "in"),
    7: .standard(proto: "not_in"),
    8: .standard(proto: "ignore_empty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularSInt64Field(value: &self._const) }()
      case 2: try { try decoder.decodeSingularSInt64Field(value: &self._lt) }()
      case 3: try { try decoder.decodeSingularSInt64Field(value: &self._lte) }()
      case 4: try { try decoder.decodeSingularSInt64Field(value: &self._gt) }()
      case 5: try { try decoder.decodeSingularSInt64Field(value: &self._gte) }()
      case 6: try { try decoder.decodeRepeatedSInt64Field(value: &self.`in`) }()
      case 7: try { try decoder.decodeRepeatedSInt64Field(value: &self.notIn) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._ignoreEmpty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._const {
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lt {
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 5)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedSInt64Field(value: self.`in`, fieldNumber: 6)
    }
    if !self.notIn.isEmpty {
      try visitor.visitRepeatedSInt64Field(value: self.notIn, fieldNumber: 7)
    }
    try { if let v = self._ignoreEmpty {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_SInt64Rules, rhs: Validate_SInt64Rules) -> Bool {
    if lhs._const != rhs._const {return false}
    if lhs._lt != rhs._lt {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.notIn != rhs.notIn {return false}
    if lhs._ignoreEmpty != rhs._ignoreEmpty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_Fixed32Rules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Fixed32Rules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
    2: .same(proto: "lt"),
    3: .same(proto: "lte"),
    4: .same(proto: "gt"),
    5: .same(proto: "gte"),
    6: .same(proto: "in"),
    7: .standard(proto: "not_in"),
    8: .standard(proto: "ignore_empty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._const) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._lt) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._lte) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._gt) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._gte) }()
      case 6: try { try decoder.decodeRepeatedFixed32Field(value: &self.`in`) }()
      case 7: try { try decoder.decodeRepeatedFixed32Field(value: &self.notIn) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._ignoreEmpty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._const {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lt {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedFixed32Field(value: self.`in`, fieldNumber: 6)
    }
    if !self.notIn.isEmpty {
      try visitor.visitRepeatedFixed32Field(value: self.notIn, fieldNumber: 7)
    }
    try { if let v = self._ignoreEmpty {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_Fixed32Rules, rhs: Validate_Fixed32Rules) -> Bool {
    if lhs._const != rhs._const {return false}
    if lhs._lt != rhs._lt {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.notIn != rhs.notIn {return false}
    if lhs._ignoreEmpty != rhs._ignoreEmpty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_Fixed64Rules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Fixed64Rules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
    2: .same(proto: "lt"),
    3: .same(proto: "lte"),
    4: .same(proto: "gt"),
    5: .same(proto: "gte"),
    6: .same(proto: "in"),
    7: .standard(proto: "not_in"),
    8: .standard(proto: "ignore_empty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._const) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self._lt) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self._lte) }()
      case 4: try { try decoder.decodeSingularFixed64Field(value: &self._gt) }()
      case 5: try { try decoder.decodeSingularFixed64Field(value: &self._gte) }()
      case 6: try { try decoder.decodeRepeatedFixed64Field(value: &self.`in`) }()
      case 7: try { try decoder.decodeRepeatedFixed64Field(value: &self.notIn) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._ignoreEmpty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._const {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lt {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 5)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedFixed64Field(value: self.`in`, fieldNumber: 6)
    }
    if !self.notIn.isEmpty {
      try visitor.visitRepeatedFixed64Field(value: self.notIn, fieldNumber: 7)
    }
    try { if let v = self._ignoreEmpty {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_Fixed64Rules, rhs: Validate_Fixed64Rules) -> Bool {
    if lhs._const != rhs._const {return false}
    if lhs._lt != rhs._lt {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.notIn != rhs.notIn {return false}
    if lhs._ignoreEmpty != rhs._ignoreEmpty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_SFixed32Rules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SFixed32Rules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
    2: .same(proto: "lt"),
    3: .same(proto: "lte"),
    4: .same(proto: "gt"),
    5: .same(proto: "gte"),
    6: .same(proto: "in"),
    7: .standard(proto: "not_in"),
    8: .standard(proto: "ignore_empty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularSFixed32Field(value: &self._const) }()
      case 2: try { try decoder.decodeSingularSFixed32Field(value: &self._lt) }()
      case 3: try { try decoder.decodeSingularSFixed32Field(value: &self._lte) }()
      case 4: try { try decoder.decodeSingularSFixed32Field(value: &self._gt) }()
      case 5: try { try decoder.decodeSingularSFixed32Field(value: &self._gte) }()
      case 6: try { try decoder.decodeRepeatedSFixed32Field(value: &self.`in`) }()
      case 7: try { try decoder.decodeRepeatedSFixed32Field(value: &self.notIn) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._ignoreEmpty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._const {
      try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lt {
      try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 5)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedSFixed32Field(value: self.`in`, fieldNumber: 6)
    }
    if !self.notIn.isEmpty {
      try visitor.visitRepeatedSFixed32Field(value: self.notIn, fieldNumber: 7)
    }
    try { if let v = self._ignoreEmpty {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_SFixed32Rules, rhs: Validate_SFixed32Rules) -> Bool {
    if lhs._const != rhs._const {return false}
    if lhs._lt != rhs._lt {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.notIn != rhs.notIn {return false}
    if lhs._ignoreEmpty != rhs._ignoreEmpty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_SFixed64Rules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SFixed64Rules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
    2: .same(proto: "lt"),
    3: .same(proto: "lte"),
    4: .same(proto: "gt"),
    5: .same(proto: "gte"),
    6: .same(proto: "in"),
    7: .standard(proto: "not_in"),
    8: .standard(proto: "ignore_empty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularSFixed64Field(value: &self._const) }()
      case 2: try { try decoder.decodeSingularSFixed64Field(value: &self._lt) }()
      case 3: try { try decoder.decodeSingularSFixed64Field(value: &self._lte) }()
      case 4: try { try decoder.decodeSingularSFixed64Field(value: &self._gt) }()
      case 5: try { try decoder.decodeSingularSFixed64Field(value: &self._gte) }()
      case 6: try { try decoder.decodeRepeatedSFixed64Field(value: &self.`in`) }()
      case 7: try { try decoder.decodeRepeatedSFixed64Field(value: &self.notIn) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._ignoreEmpty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._const {
      try visitor.visitSingularSFixed64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lt {
      try visitor.visitSingularSFixed64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularSFixed64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularSFixed64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularSFixed64Field(value: v, fieldNumber: 5)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedSFixed64Field(value: self.`in`, fieldNumber: 6)
    }
    if !self.notIn.isEmpty {
      try visitor.visitRepeatedSFixed64Field(value: self.notIn, fieldNumber: 7)
    }
    try { if let v = self._ignoreEmpty {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_SFixed64Rules, rhs: Validate_SFixed64Rules) -> Bool {
    if lhs._const != rhs._const {return false}
    if lhs._lt != rhs._lt {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.notIn != rhs.notIn {return false}
    if lhs._ignoreEmpty != rhs._ignoreEmpty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_BoolRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BoolRules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._const) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._const {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_BoolRules, rhs: Validate_BoolRules) -> Bool {
    if lhs._const != rhs._const {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_StringRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StringRules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
    19: .same(proto: "len"),
    2: .standard(proto: "min_len"),
    3: .standard(proto: "max_len"),
    20: .standard(proto: "len_bytes"),
    4: .standard(proto: "min_bytes"),
    5: .standard(proto: "max_bytes"),
    6: .same(proto: "pattern"),
    7: .same(proto: "prefix"),
    8: .same(proto: "suffix"),
    9: .same(proto: "contains"),
    23: .standard(proto: "not_contains"),
    10: .same(proto: "in"),
    11: .standard(proto: "not_in"),
    12: .same(proto: "email"),
    13: .same(proto: "hostname"),
    14: .same(proto: "ip"),
    15: .same(proto: "ipv4"),
    16: .same(proto: "ipv6"),
    17: .same(proto: "uri"),
    18: .standard(proto: "uri_ref"),
    21: .same(proto: "address"),
    22: .same(proto: "uuid"),
    24: .standard(proto: "well_known_regex"),
    25: .same(proto: "strict"),
    26: .standard(proto: "ignore_empty"),
  ]

  fileprivate class _StorageClass {
    var _const: String? = nil
    var _len: UInt64? = nil
    var _minLen: UInt64? = nil
    var _maxLen: UInt64? = nil
    var _lenBytes: UInt64? = nil
    var _minBytes: UInt64? = nil
    var _maxBytes: UInt64? = nil
    var _pattern: String? = nil
    var _prefix: String? = nil
    var _suffix: String? = nil
    var _contains: String? = nil
    var _notContains: String? = nil
    var _in: [String] = []
    var _notIn: [String] = []
    var _wellKnown: Validate_StringRules.OneOf_WellKnown?
    var _strict: Bool? = nil
    var _ignoreEmpty: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _const = source._const
      _len = source._len
      _minLen = source._minLen
      _maxLen = source._maxLen
      _lenBytes = source._lenBytes
      _minBytes = source._minBytes
      _maxBytes = source._maxBytes
      _pattern = source._pattern
      _prefix = source._prefix
      _suffix = source._suffix
      _contains = source._contains
      _notContains = source._notContains
      _in = source._in
      _notIn = source._notIn
      _wellKnown = source._wellKnown
      _strict = source._strict
      _ignoreEmpty = source._ignoreEmpty
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._const) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._minLen) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxLen) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._minBytes) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxBytes) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._pattern) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._prefix) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._suffix) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._contains) }()
        case 10: try { try decoder.decodeRepeatedStringField(value: &_storage._in) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._notIn) }()
        case 12: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._wellKnown != nil {try decoder.handleConflictingOneOf()}
            _storage._wellKnown = .email(v)
          }
        }()
        case 13: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._wellKnown != nil {try decoder.handleConflictingOneOf()}
            _storage._wellKnown = .hostname(v)
          }
        }()
        case 14: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._wellKnown != nil {try decoder.handleConflictingOneOf()}
            _storage._wellKnown = .ip(v)
          }
        }()
        case 15: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._wellKnown != nil {try decoder.handleConflictingOneOf()}
            _storage._wellKnown = .ipv4(v)
          }
        }()
        case 16: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._wellKnown != nil {try decoder.handleConflictingOneOf()}
            _storage._wellKnown = .ipv6(v)
          }
        }()
        case 17: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._wellKnown != nil {try decoder.handleConflictingOneOf()}
            _storage._wellKnown = .uri(v)
          }
        }()
        case 18: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._wellKnown != nil {try decoder.handleConflictingOneOf()}
            _storage._wellKnown = .uriRef(v)
          }
        }()
        case 19: try { try decoder.decodeSingularUInt64Field(value: &_storage._len) }()
        case 20: try { try decoder.decodeSingularUInt64Field(value: &_storage._lenBytes) }()
        case 21: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._wellKnown != nil {try decoder.handleConflictingOneOf()}
            _storage._wellKnown = .address(v)
          }
        }()
        case 22: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._wellKnown != nil {try decoder.handleConflictingOneOf()}
            _storage._wellKnown = .uuid(v)
          }
        }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._notContains) }()
        case 24: try {
          var v: Validate_KnownRegex?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._wellKnown != nil {try decoder.handleConflictingOneOf()}
            _storage._wellKnown = .wellKnownRegex(v)
          }
        }()
        case 25: try { try decoder.decodeSingularBoolField(value: &_storage._strict) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._ignoreEmpty) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._const {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._minLen {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._maxLen {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._minBytes {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._maxBytes {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._pattern {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._prefix {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._suffix {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._contains {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      if !_storage._in.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._in, fieldNumber: 10)
      }
      if !_storage._notIn.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._notIn, fieldNumber: 11)
      }
      switch _storage._wellKnown {
      case .email?: try {
        guard case .email(let v)? = _storage._wellKnown else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      }()
      case .hostname?: try {
        guard case .hostname(let v)? = _storage._wellKnown else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      }()
      case .ip?: try {
        guard case .ip(let v)? = _storage._wellKnown else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      }()
      case .ipv4?: try {
        guard case .ipv4(let v)? = _storage._wellKnown else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      }()
      case .ipv6?: try {
        guard case .ipv6(let v)? = _storage._wellKnown else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      }()
      case .uri?: try {
        guard case .uri(let v)? = _storage._wellKnown else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      }()
      case .uriRef?: try {
        guard case .uriRef(let v)? = _storage._wellKnown else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      }()
      default: break
      }
      try { if let v = _storage._len {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._lenBytes {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 20)
      } }()
      switch _storage._wellKnown {
      case .address?: try {
        guard case .address(let v)? = _storage._wellKnown else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 21)
      }()
      case .uuid?: try {
        guard case .uuid(let v)? = _storage._wellKnown else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 22)
      }()
      default: break
      }
      try { if let v = _storage._notContains {
        try visitor.visitSingularStringField(value: v, fieldNumber: 23)
      } }()
      try { if case .wellKnownRegex(let v)? = _storage._wellKnown {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._strict {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._ignoreEmpty {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 26)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_StringRules, rhs: Validate_StringRules) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._const != rhs_storage._const {return false}
        if _storage._len != rhs_storage._len {return false}
        if _storage._minLen != rhs_storage._minLen {return false}
        if _storage._maxLen != rhs_storage._maxLen {return false}
        if _storage._lenBytes != rhs_storage._lenBytes {return false}
        if _storage._minBytes != rhs_storage._minBytes {return false}
        if _storage._maxBytes != rhs_storage._maxBytes {return false}
        if _storage._pattern != rhs_storage._pattern {return false}
        if _storage._prefix != rhs_storage._prefix {return false}
        if _storage._suffix != rhs_storage._suffix {return false}
        if _storage._contains != rhs_storage._contains {return false}
        if _storage._notContains != rhs_storage._notContains {return false}
        if _storage._in != rhs_storage._in {return false}
        if _storage._notIn != rhs_storage._notIn {return false}
        if _storage._wellKnown != rhs_storage._wellKnown {return false}
        if _storage._strict != rhs_storage._strict {return false}
        if _storage._ignoreEmpty != rhs_storage._ignoreEmpty {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_BytesRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BytesRules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
    13: .same(proto: "len"),
    2: .standard(proto: "min_len"),
    3: .standard(proto: "max_len"),
    4: .same(proto: "pattern"),
    5: .same(proto: "prefix"),
    6: .same(proto: "suffix"),
    7: .same(proto: "contains"),
    8: .same(proto: "in"),
    9: .standard(proto: "not_in"),
    10: .same(proto: "ip"),
    11: .same(proto: "ipv4"),
    12: .same(proto: "ipv6"),
    14: .standard(proto: "ignore_empty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._const) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._minLen) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._maxLen) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._pattern) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._prefix) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._suffix) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self._contains) }()
      case 8: try { try decoder.decodeRepeatedBytesField(value: &self.`in`) }()
      case 9: try { try decoder.decodeRepeatedBytesField(value: &self.notIn) }()
      case 10: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.wellKnown != nil {try decoder.handleConflictingOneOf()}
          self.wellKnown = .ip(v)
        }
      }()
      case 11: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.wellKnown != nil {try decoder.handleConflictingOneOf()}
          self.wellKnown = .ipv4(v)
        }
      }()
      case 12: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.wellKnown != nil {try decoder.handleConflictingOneOf()}
          self.wellKnown = .ipv6(v)
        }
      }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self._len) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self._ignoreEmpty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._const {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._minLen {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._maxLen {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pattern {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._prefix {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._suffix {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._contains {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.`in`, fieldNumber: 8)
    }
    if !self.notIn.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.notIn, fieldNumber: 9)
    }
    switch self.wellKnown {
    case .ip?: try {
      guard case .ip(let v)? = self.wellKnown else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    }()
    case .ipv4?: try {
      guard case .ipv4(let v)? = self.wellKnown else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    }()
    case .ipv6?: try {
      guard case .ipv6(let v)? = self.wellKnown else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try { if let v = self._len {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._ignoreEmpty {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_BytesRules, rhs: Validate_BytesRules) -> Bool {
    if lhs._const != rhs._const {return false}
    if lhs._len != rhs._len {return false}
    if lhs._minLen != rhs._minLen {return false}
    if lhs._maxLen != rhs._maxLen {return false}
    if lhs._pattern != rhs._pattern {return false}
    if lhs._prefix != rhs._prefix {return false}
    if lhs._suffix != rhs._suffix {return false}
    if lhs._contains != rhs._contains {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.notIn != rhs.notIn {return false}
    if lhs.wellKnown != rhs.wellKnown {return false}
    if lhs._ignoreEmpty != rhs._ignoreEmpty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_EnumRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnumRules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "const"),
    2: .standard(proto: "defined_only"),
    3: .same(proto: "in"),
    4: .standard(proto: "not_in"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._const) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._definedOnly) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.`in`) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.notIn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._const {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._definedOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.`in`, fieldNumber: 3)
    }
    if !self.notIn.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.notIn, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_EnumRules, rhs: Validate_EnumRules) -> Bool {
    if lhs._const != rhs._const {return false}
    if lhs._definedOnly != rhs._definedOnly {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.notIn != rhs.notIn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_MessageRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageRules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "skip"),
    2: .same(proto: "required"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._skip) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._required) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._skip {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._required {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_MessageRules, rhs: Validate_MessageRules) -> Bool {
    if lhs._skip != rhs._skip {return false}
    if lhs._required != rhs._required {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_RepeatedRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RepeatedRules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_items"),
    2: .standard(proto: "max_items"),
    3: .same(proto: "unique"),
    4: .same(proto: "items"),
    5: .standard(proto: "ignore_empty"),
  ]

  fileprivate class _StorageClass {
    var _minItems: UInt64? = nil
    var _maxItems: UInt64? = nil
    var _unique: Bool? = nil
    var _items: Validate_FieldRules? = nil
    var _ignoreEmpty: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _minItems = source._minItems
      _maxItems = source._maxItems
      _unique = source._unique
      _items = source._items
      _ignoreEmpty = source._ignoreEmpty
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._minItems) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxItems) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._unique) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._items) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._ignoreEmpty) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._minItems {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._maxItems {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._unique {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._items {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._ignoreEmpty {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_RepeatedRules, rhs: Validate_RepeatedRules) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._minItems != rhs_storage._minItems {return false}
        if _storage._maxItems != rhs_storage._maxItems {return false}
        if _storage._unique != rhs_storage._unique {return false}
        if _storage._items != rhs_storage._items {return false}
        if _storage._ignoreEmpty != rhs_storage._ignoreEmpty {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_MapRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MapRules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_pairs"),
    2: .standard(proto: "max_pairs"),
    3: .standard(proto: "no_sparse"),
    4: .same(proto: "keys"),
    5: .same(proto: "values"),
    6: .standard(proto: "ignore_empty"),
  ]

  fileprivate class _StorageClass {
    var _minPairs: UInt64? = nil
    var _maxPairs: UInt64? = nil
    var _noSparse: Bool? = nil
    var _keys: Validate_FieldRules? = nil
    var _values: Validate_FieldRules? = nil
    var _ignoreEmpty: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _minPairs = source._minPairs
      _maxPairs = source._maxPairs
      _noSparse = source._noSparse
      _keys = source._keys
      _values = source._values
      _ignoreEmpty = source._ignoreEmpty
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._minPairs) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxPairs) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._noSparse) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._keys) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._values) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._ignoreEmpty) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._minPairs {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._maxPairs {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._noSparse {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._keys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._values {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._ignoreEmpty {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_MapRules, rhs: Validate_MapRules) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._minPairs != rhs_storage._minPairs {return false}
        if _storage._maxPairs != rhs_storage._maxPairs {return false}
        if _storage._noSparse != rhs_storage._noSparse {return false}
        if _storage._keys != rhs_storage._keys {return false}
        if _storage._values != rhs_storage._values {return false}
        if _storage._ignoreEmpty != rhs_storage._ignoreEmpty {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_AnyRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AnyRules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "required"),
    2: .same(proto: "in"),
    3: .standard(proto: "not_in"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._required) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.`in`) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.notIn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._required {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedStringField(value: self.`in`, fieldNumber: 2)
    }
    if !self.notIn.isEmpty {
      try visitor.visitRepeatedStringField(value: self.notIn, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_AnyRules, rhs: Validate_AnyRules) -> Bool {
    if lhs._required != rhs._required {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.notIn != rhs.notIn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_DurationRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DurationRules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "required"),
    2: .same(proto: "const"),
    3: .same(proto: "lt"),
    4: .same(proto: "lte"),
    5: .same(proto: "gt"),
    6: .same(proto: "gte"),
    7: .same(proto: "in"),
    8: .standard(proto: "not_in"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._required) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._const) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lte) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._gt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._gte) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.`in`) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.notIn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._required {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._const {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.`in`.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.`in`, fieldNumber: 7)
    }
    if !self.notIn.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notIn, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_DurationRules, rhs: Validate_DurationRules) -> Bool {
    if lhs._required != rhs._required {return false}
    if lhs._const != rhs._const {return false}
    if lhs._lt != rhs._lt {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs.`in` != rhs.`in` {return false}
    if lhs.notIn != rhs.notIn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Validate_TimestampRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimestampRules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "required"),
    2: .same(proto: "const"),
    3: .same(proto: "lt"),
    4: .same(proto: "lte"),
    5: .same(proto: "gt"),
    6: .same(proto: "gte"),
    7: .standard(proto: "lt_now"),
    8: .standard(proto: "gt_now"),
    9: .same(proto: "within"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._required) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._const) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lte) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._gt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._gte) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._ltNow) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._gtNow) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._within) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._required {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._const {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._ltNow {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._gtNow {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._within {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Validate_TimestampRules, rhs: Validate_TimestampRules) -> Bool {
    if lhs._required != rhs._required {return false}
    if lhs._const != rhs._const {return false}
    if lhs._lt != rhs._lt {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs._ltNow != rhs._ltNow {return false}
    if lhs._gtNow != rhs._gtNow {return false}
    if lhs._within != rhs._within {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
